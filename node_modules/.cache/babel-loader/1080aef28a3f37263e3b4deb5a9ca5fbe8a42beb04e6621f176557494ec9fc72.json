{"ast":null,"code":"import { createCollection as e } from \"@radix-ui/react-collection\";\nimport { Primitive as t } from \"@radix-ui/react-primitive\";\nimport { useSize as n } from \"@radix-ui/react-use-size\";\nimport { usePrevious as r } from \"@radix-ui/react-use-previous\";\nimport { useDirection as o } from \"@radix-ui/react-use-direction\";\nimport { useControllableState as i } from \"@radix-ui/react-use-controllable-state\";\nimport { createContextScope as a } from \"@radix-ui/react-context\";\nimport { useComposedRefs as l } from \"@radix-ui/react-compose-refs\";\nimport { composeEventHandlers as d } from \"@radix-ui/primitive\";\nimport { clamp as s } from \"@radix-ui/number\";\nimport * as u from \"react\";\nimport c from \"@babel/runtime/helpers/esm/extends\";\nconst m = [\"PageUp\", \"PageDown\"],\n  f = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"],\n  p = {\n    ltr: [\"ArrowDown\", \"Home\", \"ArrowLeft\", \"PageDown\"],\n    rtl: [\"ArrowDown\", \"Home\", \"ArrowRight\", \"PageDown\"]\n  },\n  [S, h, v] = e(\"Slider\"),\n  [w, g] = a(\"Slider\", [v]);\nexport { g as createSliderScope };\nconst [x, b] = w(\"Slider\");\nexport const Slider = /*#__PURE__*/u.forwardRef((e, t) => {\n  const {\n      name: n,\n      min: r = 0,\n      max: o = 100,\n      step: a = 1,\n      orientation: d = \"horizontal\",\n      disabled: p = !1,\n      minStepsBetweenThumbs: h = 0,\n      defaultValue: v = [r],\n      value: w,\n      onValueChange: g = () => {},\n      ...b\n    } = e,\n    [E, y] = u.useState(null),\n    _ = l(t, e => y(e)),\n    M = u.useRef(new Set()),\n    K = u.useRef(0),\n    T = \"horizontal\" === d,\n    k = !E || Boolean(E.closest(\"form\")),\n    C = T ? R : D,\n    [I = [], z] = i({\n      prop: w,\n      defaultProp: v,\n      onChange: e => {\n        var t;\n        null === (t = [...M.current][K.current]) || void 0 === t || t.focus(), g(e);\n      }\n    });\n  function A(e, t) {\n    const n = function (e) {\n        return (String(e).split(\".\")[1] || \"\").length;\n      }(a),\n      i = function (e, t) {\n        const n = Math.pow(10, t);\n        return Math.round(e * n) / n;\n      }(Math.round((e - r) / a) * a + r, n),\n      l = s(i, [r, o]);\n    z(function () {\n      let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      const n = function () {\n        let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        let t = arguments.length > 1 ? arguments[1] : undefined;\n        let n = arguments.length > 2 ? arguments[2] : undefined;\n        const r = [...e];\n        return r[n] = t, r.sort((e, t) => e - t);\n      }(e, l, t);\n      return function (e, t) {\n        if (t > 0) {\n          const n = function (e) {\n            return e.slice(0, -1).map((t, n) => e[n + 1] - t);\n          }(e);\n          return Math.min(...n) >= t;\n        }\n        return !0;\n      }(n, h * a) ? (K.current = n.indexOf(l), String(n) === String(e) ? e : n) : e;\n    });\n  } /*#__PURE__*/\n  return u.createElement(x, {\n    scope: e.__scopeSlider,\n    disabled: p,\n    min: r,\n    max: o,\n    valueIndexToChangeRef: K,\n    thumbs: M.current,\n    values: I,\n    orientation: d\n  }, /*#__PURE__*/u.createElement(S.Provider, {\n    scope: e.__scopeSlider\n  }, /*#__PURE__*/u.createElement(S.Slot, {\n    scope: e.__scopeSlider\n  }, /*#__PURE__*/u.createElement(C, c({\n    \"aria-disabled\": p,\n    \"data-disabled\": p ? \"\" : void 0\n  }, b, {\n    ref: _,\n    min: r,\n    max: o,\n    onSlideStart: p ? void 0 : function (e) {\n      A(e, function (e, t) {\n        if (1 === e.length) return 0;\n        const n = e.map(e => Math.abs(e - t)),\n          r = Math.min(...n);\n        return n.indexOf(r);\n      }(I, e));\n    },\n    onSlideMove: p ? void 0 : function (e) {\n      A(e, K.current);\n    },\n    onHomeKeyDown: () => !p && A(r, 0),\n    onEndKeyDown: () => !p && A(o, I.length - 1),\n    onStepKeyDown: _ref => {\n      let {\n        event: e,\n        direction: t\n      } = _ref;\n      if (!p) {\n        const n = m.includes(e.key) || e.shiftKey && f.includes(e.key) ? 10 : 1,\n          r = K.current;\n        A(I[r] + a * n * t, r);\n      }\n    }\n  })))), k && I.map((e, t) => /*#__PURE__*/u.createElement(P, {\n    key: t,\n    name: n ? n + (I.length > 1 ? \"[]\" : \"\") : void 0,\n    value: e\n  })));\n}); /*#__PURE__*/\nconst [E, y] = w(\"Slider\", {\n    startEdge: \"left\",\n    endEdge: \"right\",\n    size: \"width\",\n    direction: 1\n  }),\n  R = /*#__PURE__*/u.forwardRef((e, t) => {\n    const {\n        min: n,\n        max: r,\n        dir: i,\n        onSlideStart: a,\n        onSlideMove: d,\n        onStepKeyDown: s,\n        ...m\n      } = e,\n      [f, S] = u.useState(null),\n      h = l(t, e => S(e)),\n      v = u.useRef(),\n      w = o(f, i),\n      g = \"ltr\" === w;\n    function x(e) {\n      const t = v.current || f.getBoundingClientRect(),\n        o = T([0, t.width], g ? [n, r] : [r, n]);\n      return v.current = t, o(e - t.left);\n    } /*#__PURE__*/\n    return u.createElement(E, {\n      scope: e.__scopeSlider,\n      startEdge: g ? \"left\" : \"right\",\n      endEdge: g ? \"right\" : \"left\",\n      direction: g ? 1 : -1,\n      size: \"width\"\n    }, /*#__PURE__*/u.createElement(_, c({\n      \"data-orientation\": \"horizontal\"\n    }, m, {\n      ref: h,\n      style: {\n        ...m.style,\n        \"--radix-slider-thumb-transform\": \"translateX(-50%)\"\n      },\n      onSlideStart: e => {\n        const t = x(e.clientX);\n        null == a || a(t);\n      },\n      onSlideMove: e => {\n        const t = x(e.clientX);\n        null == d || d(t);\n      },\n      onSlideEnd: () => v.current = void 0,\n      onStepKeyDown: e => {\n        const t = p[w].includes(e.key);\n        null == s || s({\n          event: e,\n          direction: t ? -1 : 1\n        });\n      }\n    })));\n  }),\n  D = /*#__PURE__*/u.forwardRef((e, t) => {\n    const {\n        min: n,\n        max: r,\n        onSlideStart: o,\n        onSlideMove: i,\n        onStepKeyDown: a,\n        ...d\n      } = e,\n      s = u.useRef(null),\n      m = l(t, s),\n      f = u.useRef();\n    function S(e) {\n      const t = f.current || s.current.getBoundingClientRect(),\n        o = T([0, t.height], [r, n]);\n      return f.current = t, o(e - t.top);\n    } /*#__PURE__*/\n    return u.createElement(E, {\n      scope: e.__scopeSlider,\n      startEdge: \"bottom\",\n      endEdge: \"top\",\n      size: \"height\",\n      direction: 1\n    }, /*#__PURE__*/u.createElement(_, c({\n      \"data-orientation\": \"vertical\"\n    }, d, {\n      ref: m,\n      style: {\n        ...d.style,\n        \"--radix-slider-thumb-transform\": \"translateY(50%)\"\n      },\n      onSlideStart: e => {\n        const t = S(e.clientY);\n        null == o || o(t);\n      },\n      onSlideMove: e => {\n        const t = S(e.clientY);\n        null == i || i(t);\n      },\n      onSlideEnd: () => f.current = void 0,\n      onStepKeyDown: e => {\n        const t = p.ltr.includes(e.key);\n        null == a || a({\n          event: e,\n          direction: t ? -1 : 1\n        });\n      }\n    })));\n  }),\n  _ = /*#__PURE__*/u.forwardRef((e, n) => {\n    const {\n        __scopeSlider: r,\n        onSlideStart: o,\n        onSlideMove: i,\n        onSlideEnd: a,\n        onHomeKeyDown: l,\n        onEndKeyDown: s,\n        onStepKeyDown: p,\n        ...S\n      } = e,\n      h = b(\"Slider\", r); /*#__PURE__*/\n    return u.createElement(t.span, c({}, S, {\n      ref: n,\n      onKeyDown: d(e.onKeyDown, e => {\n        \"Home\" === e.key ? (l(e), e.preventDefault()) : \"End\" === e.key ? (s(e), e.preventDefault()) : m.concat(f).includes(e.key) && (p(e), e.preventDefault());\n      }),\n      onPointerDown: d(e.onPointerDown, e => {\n        const t = e.target;\n        t.setPointerCapture(e.pointerId), e.preventDefault(), h.thumbs.has(t) ? t.focus() : o(e);\n      }),\n      onPointerMove: d(e.onPointerMove, e => {\n        e.target.hasPointerCapture(e.pointerId) && i(e);\n      }),\n      onPointerUp: d(e.onPointerUp, e => {\n        const t = e.target;\n        t.hasPointerCapture(e.pointerId) && (t.releasePointerCapture(e.pointerId), a(e));\n      })\n    }));\n  });\nexport const SliderTrack = /*#__PURE__*/u.forwardRef((e, n) => {\n  const {\n      __scopeSlider: r,\n      ...o\n    } = e,\n    i = b(\"SliderTrack\", r); /*#__PURE__*/\n  return u.createElement(t.span, c({\n    \"data-disabled\": i.disabled ? \"\" : void 0,\n    \"data-orientation\": i.orientation\n  }, o, {\n    ref: n\n  }));\n}); /*#__PURE__*/\nexport const SliderRange = /*#__PURE__*/u.forwardRef((e, n) => {\n  const {\n      __scopeSlider: r,\n      ...o\n    } = e,\n    i = b(\"SliderRange\", r),\n    a = y(\"SliderRange\", r),\n    d = u.useRef(null),\n    s = l(n, d),\n    m = i.values.length,\n    f = i.values.map(e => K(e, i.min, i.max)),\n    p = m > 1 ? Math.min(...f) : 0,\n    S = 100 - Math.max(...f); /*#__PURE__*/\n  return u.createElement(t.span, c({\n    \"data-orientation\": i.orientation,\n    \"data-disabled\": i.disabled ? \"\" : void 0\n  }, o, {\n    ref: s,\n    style: {\n      ...e.style,\n      [a.startEdge]: p + \"%\",\n      [a.endEdge]: S + \"%\"\n    }\n  }));\n}); /*#__PURE__*/\nexport const SliderThumb = /*#__PURE__*/u.forwardRef((e, t) => {\n  const n = h(e.__scopeSlider),\n    [r, o] = u.useState(null),\n    i = l(t, e => o(e)),\n    a = u.useMemo(() => r ? n().findIndex(e => e.ref.current === r) : -1, [n, r]); /*#__PURE__*/\n  return u.createElement(M, c({}, e, {\n    ref: i,\n    index: a\n  }));\n});\nconst M = /*#__PURE__*/u.forwardRef((e, r) => {\n    const {\n        __scopeSlider: o,\n        index: i,\n        ...a\n      } = e,\n      s = b(\"SliderThumb\", o),\n      m = y(\"SliderThumb\", o),\n      [f, p] = u.useState(null),\n      h = l(r, e => p(e)),\n      v = n(f),\n      w = s.values[i],\n      g = void 0 === w ? 0 : K(w, s.min, s.max),\n      x = function (e, t) {\n        return t > 2 ? `Value ${e + 1} of ${t}` : 2 === t ? [\"Minimum\", \"Maximum\"][e] : void 0;\n      }(i, s.values.length),\n      E = null == v ? void 0 : v[m.size],\n      R = E ? function (e, t, n) {\n        const r = e / 2,\n          o = T([0, 50], [0, r]);\n        return (r - o(t) * n) * n;\n      }(E, g, m.direction) : 0;\n    return u.useEffect(() => {\n      if (f) return s.thumbs.add(f), () => {\n        s.thumbs.delete(f);\n      };\n    }, [f, s.thumbs]), /*#__PURE__*/u.createElement(\"span\", {\n      style: {\n        transform: \"var(--radix-slider-thumb-transform)\",\n        position: \"absolute\",\n        [m.startEdge]: `calc(${g}% + ${R}px)`\n      }\n    }, /*#__PURE__*/u.createElement(S.ItemSlot, {\n      scope: e.__scopeSlider\n    }, /*#__PURE__*/u.createElement(t.span, c({\n      role: \"slider\",\n      \"aria-label\": e[\"aria-label\"] || x,\n      \"aria-valuemin\": s.min,\n      \"aria-valuenow\": w,\n      \"aria-valuemax\": s.max,\n      \"aria-orientation\": s.orientation,\n      \"data-orientation\": s.orientation,\n      \"data-disabled\": s.disabled ? \"\" : void 0,\n      tabIndex: s.disabled ? void 0 : 0\n    }, a, {\n      ref: h,\n      style: void 0 === w ? {\n        display: \"none\"\n      } : e.style,\n      onFocus: d(e.onFocus, () => {\n        s.valueIndexToChangeRef.current = i;\n      })\n    }))));\n  }),\n  P = e => {\n    const {\n        value: t,\n        ...n\n      } = e,\n      o = u.useRef(null),\n      i = r(t);\n    return u.useEffect(() => {\n      const e = o.current,\n        n = window.HTMLInputElement.prototype,\n        r = Object.getOwnPropertyDescriptor(n, \"value\").set;\n      if (i !== t && r) {\n        const n = new Event(\"input\", {\n          bubbles: !0\n        });\n        r.call(e, t), e.dispatchEvent(n);\n      }\n    }, [i, t]), /*#__PURE__*/u.createElement(\"input\", c({\n      style: {\n        display: \"none\"\n      }\n    }, n, {\n      ref: o,\n      defaultValue: t\n    }));\n  }; /*#__PURE__*/\nfunction K(e, t, n) {\n  return 100 / (n - t) * (e - t);\n}\nfunction T(e, t) {\n  return n => {\n    if (e[0] === e[1] || t[0] === t[1]) return t[0];\n    const r = (t[1] - t[0]) / (e[1] - e[0]);\n    return t[0] + r * (n - e[0]);\n  };\n}\nexport const Root = Slider;\nexport const Track = SliderTrack;\nexport const Range = SliderRange;\nexport const Thumb = SliderThumb;","map":{"version":3,"mappings":"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","names":["PAGE_KEYS","ARROW_KEYS","BACK_KEYS","ltr","rtl","Collection","useCollection","createCollectionScope","createCollection","createSliderContext","createSliderScope","createContextScope","SliderProvider","useSliderContext","Slider","React","forwardRef","props","forwardedRef","name","min","max","step","orientation","disabled","minStepsBetweenThumbs","defaultValue","value","onValueChange","sliderProps","slider","setSlider","useState","composedRefs","useComposedRefs","node","thumbRefs","useRef","Set","valueIndexToChangeRef","isHorizontal","isFormControl","Boolean","closest","SliderOrientation","SliderHorizontal","SliderVertical","values","setValues","useControllableState","prop","defaultProp","onChange","current","focus","updateValues","atIndex","decimalCount","String","split","length","getDecimalCount","snapToStep","rounder","Math","pow","round","roundValue","nextValue","clamp","prevValues","nextValues","sort","a","b","getNextSortedValues","minStepsBetweenValues","stepsBetweenValues","slice","map","index","getStepsBetweenValues","hasMinStepsBetweenValues","indexOf","_react","$a68403ced9538b15d14f377d3c557e$var$SliderProvider","scope","__scopeSlider","thumbs","$a68403ced9538b15d14f377d3c557e$var$Collection","Provider","Slot","_babelRuntimeHelpersEsmExtends","undefined","ref","onSlideStart","distances","abs","closestDistance","getClosestValueIndex","onSlideMove","onHomeKeyDown","onEndKeyDown","onStepKeyDown","stepDirection","event","direction","multiplier","includes","key","shiftKey","$a68403ced9538b15d14f377d3c557e$var$BubbleInput","SliderOrientationProvider","useSliderOrientationContext","startEdge","endEdge","size","dir","rectRef","useDirection","isDirectionLTR","getValueFromPointer","pointerPosition","rect","getBoundingClientRect","linearScale","width","left","$a68403ced9538b15d14f377d3c557e$var$SliderOrientationProvider","$a68403ced9538b15d14f377d3c557e$var$SliderImpl","style","clientX","onSlideEnd","isBackKey","sliderRef","height","top","clientY","SliderImpl","context","Primitive","span","onKeyDown","composeEventHandlers","preventDefault","concat","onPointerDown","target","setPointerCapture","pointerId","has","onPointerMove","hasPointerCapture","onPointerUp","releasePointerCapture","SliderTrack","trackProps","SliderRange","rangeProps","valuesCount","percentages","convertValueToPercentage","offsetStart","offsetEnd","SliderThumb","getItems","thumb","setThumb","useMemo","findIndex","item","$a68403ced9538b15d14f377d3c557e$var$SliderThumbImpl","SliderThumbImpl","thumbProps","useSize","percent","label","totalValues","getLabel","orientationSize","thumbInBoundsOffset","halfWidth","offset","getThumbInBoundsOffset","useEffect","add","delete","transform","position","ItemSlot","role","tabIndex","display","onFocus","BubbleInput","inputProps","prevValue","usePrevious","input","inputProto","window","HTMLInputElement","prototype","setValue","Object","getOwnPropertyDescriptor","set","Event","bubbles","call","dispatchEvent","output","ratio","Root","Track","Range","Thumb"],"sources":["C:\\Users\\weida\\Desktop\\playground_CC\\node_modules\\@aws-amplify\\ui-react\\node_modules\\@radix-ui\\react-slider\\dist\\packages\\react\\slider\\src\\Slider.tsx"],"sourcesContent":["import * as React from 'react';\nimport { clamp } from '@radix-ui/number';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-use-direction';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { createCollection } from '@radix-ui/react-collection';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst PAGE_KEYS = ['PageUp', 'PageDown'];\nconst ARROW_KEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n\nconst BACK_KEYS: Record<Direction, string[]> = {\n  ltr: ['ArrowDown', 'Home', 'ArrowLeft', 'PageDown'],\n  rtl: ['ArrowDown', 'Home', 'ArrowRight', 'PageDown'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Slider\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLIDER_NAME = 'Slider';\n\nconst [Collection, useCollection, createCollectionScope] =\n  createCollection<SliderThumbElement>(SLIDER_NAME);\n\ntype ScopedProps<P> = P & { __scopeSlider?: Scope };\nconst [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME, [\n  createCollectionScope,\n]);\n\ntype SliderContextValue = {\n  disabled?: boolean;\n  min: number;\n  max: number;\n  values: number[];\n  valueIndexToChangeRef: React.MutableRefObject<number>;\n  thumbs: Set<SliderThumbElement>;\n  orientation: SliderProps['orientation'];\n};\n\nconst [SliderProvider, useSliderContext] = createSliderContext<SliderContextValue>(SLIDER_NAME);\n\ntype SliderElement = SliderHorizontalElement | SliderVerticalElement;\ninterface SliderProps\n  extends Omit<\n    SliderHorizontalProps | SliderVerticalProps,\n    keyof SliderOrientationPrivateProps | 'defaultValue'\n  > {\n  name?: string;\n  disabled?: boolean;\n  orientation?: React.AriaAttributes['aria-orientation'];\n  dir?: Direction;\n  min?: number;\n  max?: number;\n  step?: number;\n  minStepsBetweenThumbs?: number;\n  value?: number[];\n  defaultValue?: number[];\n  onValueChange?(value: number[]): void;\n}\n\nconst Slider = React.forwardRef<SliderElement, SliderProps>(\n  (props: ScopedProps<SliderProps>, forwardedRef) => {\n    const {\n      name,\n      min = 0,\n      max = 100,\n      step = 1,\n      orientation = 'horizontal',\n      disabled = false,\n      minStepsBetweenThumbs = 0,\n      defaultValue = [min],\n      value,\n      onValueChange = () => {},\n      ...sliderProps\n    } = props;\n    const [slider, setSlider] = React.useState<HTMLSpanElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));\n    const thumbRefs = React.useRef<SliderContextValue['thumbs']>(new Set());\n    const valueIndexToChangeRef = React.useRef<number>(0);\n    const isHorizontal = orientation === 'horizontal';\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    const isFormControl = slider ? Boolean(slider.closest('form')) : true;\n    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;\n\n    const [values = [], setValues] = useControllableState({\n      prop: value,\n      defaultProp: defaultValue,\n      onChange: (value) => {\n        const thumbs = [...thumbRefs.current];\n        thumbs[valueIndexToChangeRef.current]?.focus();\n        onValueChange(value);\n      },\n    });\n\n    function handleSlideStart(value: number) {\n      const closestIndex = getClosestValueIndex(values, value);\n      updateValues(value, closestIndex);\n    }\n\n    function handleSlideMove(value: number) {\n      updateValues(value, valueIndexToChangeRef.current);\n    }\n\n    function updateValues(value: number, atIndex: number) {\n      const decimalCount = getDecimalCount(step);\n      const snapToStep = roundValue(Math.round((value - min) / step) * step + min, decimalCount);\n      const nextValue = clamp(snapToStep, [min, max]);\n\n      setValues((prevValues = []) => {\n        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);\n        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {\n          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);\n          return String(nextValues) === String(prevValues) ? prevValues : nextValues;\n        } else {\n          return prevValues;\n        }\n      });\n    }\n\n    return (\n      <SliderProvider\n        scope={props.__scopeSlider}\n        disabled={disabled}\n        min={min}\n        max={max}\n        valueIndexToChangeRef={valueIndexToChangeRef}\n        thumbs={thumbRefs.current}\n        values={values}\n        orientation={orientation}\n      >\n        <Collection.Provider scope={props.__scopeSlider}>\n          <Collection.Slot scope={props.__scopeSlider}>\n            <SliderOrientation\n              aria-disabled={disabled}\n              data-disabled={disabled ? '' : undefined}\n              {...sliderProps}\n              ref={composedRefs}\n              min={min}\n              max={max}\n              onSlideStart={disabled ? undefined : handleSlideStart}\n              onSlideMove={disabled ? undefined : handleSlideMove}\n              onHomeKeyDown={() => !disabled && updateValues(min, 0)}\n              onEndKeyDown={() => !disabled && updateValues(max, values.length - 1)}\n              onStepKeyDown={({ event, direction: stepDirection }) => {\n                if (!disabled) {\n                  const isPageKey = PAGE_KEYS.includes(event.key);\n                  const isSkipKey = isPageKey || (event.shiftKey && ARROW_KEYS.includes(event.key));\n                  const multiplier = isSkipKey ? 10 : 1;\n                  const atIndex = valueIndexToChangeRef.current;\n                  const value = values[atIndex];\n                  const stepInDirection = step * multiplier * stepDirection;\n                  updateValues(value + stepInDirection, atIndex);\n                }\n              }}\n            />\n          </Collection.Slot>\n        </Collection.Provider>\n        {isFormControl &&\n          values.map((value, index) => (\n            <BubbleInput\n              key={index}\n              name={name ? name + (values.length > 1 ? '[]' : '') : undefined}\n              value={value}\n            />\n          ))}\n      </SliderProvider>\n    );\n  }\n);\n\nSlider.displayName = SLIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderHorizontal\n * -----------------------------------------------------------------------------------------------*/\n\nconst [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext<{\n  startEdge: 'bottom' | 'left' | 'right';\n  endEdge: 'top' | 'right' | 'left';\n  size: keyof NonNullable<ReturnType<typeof useSize>>;\n  direction: number;\n}>(SLIDER_NAME, {\n  startEdge: 'left',\n  endEdge: 'right',\n  size: 'width',\n  direction: 1,\n});\n\ntype SliderOrientationPrivateProps = {\n  min: number;\n  max: number;\n  onSlideStart?(value: number): void;\n  onSlideMove?(value: number): void;\n  onHomeKeyDown(event: React.KeyboardEvent): void;\n  onEndKeyDown(event: React.KeyboardEvent): void;\n  onStepKeyDown(step: { event: React.KeyboardEvent; direction: number }): void;\n};\ninterface SliderOrientationProps\n  extends Omit<SliderImplProps, keyof SliderImplPrivateProps>,\n    SliderOrientationPrivateProps {}\n\ntype SliderHorizontalElement = SliderImplElement;\ninterface SliderHorizontalProps extends SliderOrientationProps {\n  dir?: Direction;\n}\n\nconst SliderHorizontal = React.forwardRef<SliderHorizontalElement, SliderHorizontalProps>(\n  (props: ScopedProps<SliderHorizontalProps>, forwardedRef) => {\n    const { min, max, dir, onSlideStart, onSlideMove, onStepKeyDown, ...sliderProps } = props;\n    const [slider, setSlider] = React.useState<SliderImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));\n    const rectRef = React.useRef<ClientRect>();\n    const direction = useDirection(slider, dir);\n    const isDirectionLTR = direction === 'ltr';\n\n    function getValueFromPointer(pointerPosition: number) {\n      const rect = rectRef.current || slider!.getBoundingClientRect();\n      const input: [number, number] = [0, rect.width];\n      const output: [number, number] = isDirectionLTR ? [min, max] : [max, min];\n      const value = linearScale(input, output);\n\n      rectRef.current = rect;\n      return value(pointerPosition - rect.left);\n    }\n\n    return (\n      <SliderOrientationProvider\n        scope={props.__scopeSlider}\n        startEdge={isDirectionLTR ? 'left' : 'right'}\n        endEdge={isDirectionLTR ? 'right' : 'left'}\n        direction={isDirectionLTR ? 1 : -1}\n        size=\"width\"\n      >\n        <SliderImpl\n          data-orientation=\"horizontal\"\n          {...sliderProps}\n          ref={composedRefs}\n          style={{\n            ...sliderProps.style,\n            ['--radix-slider-thumb-transform' as any]: 'translateX(-50%)',\n          }}\n          onSlideStart={(event) => {\n            const value = getValueFromPointer(event.clientX);\n            onSlideStart?.(value);\n          }}\n          onSlideMove={(event) => {\n            const value = getValueFromPointer(event.clientX);\n            onSlideMove?.(value);\n          }}\n          onSlideEnd={() => (rectRef.current = undefined)}\n          onStepKeyDown={(event) => {\n            const isBackKey = BACK_KEYS[direction].includes(event.key);\n            onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });\n          }}\n        />\n      </SliderOrientationProvider>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderVertical\n * -----------------------------------------------------------------------------------------------*/\n\ntype SliderVerticalElement = SliderImplElement;\ninterface SliderVerticalProps extends SliderOrientationProps {}\n\nconst SliderVertical = React.forwardRef<SliderVerticalElement, SliderVerticalProps>(\n  (props: ScopedProps<SliderVerticalProps>, forwardedRef) => {\n    const { min, max, onSlideStart, onSlideMove, onStepKeyDown, ...sliderProps } = props;\n    const sliderRef = React.useRef<SliderImplElement>(null);\n    const ref = useComposedRefs(forwardedRef, sliderRef);\n    const rectRef = React.useRef<ClientRect>();\n\n    function getValueFromPointer(pointerPosition: number) {\n      const rect = rectRef.current || sliderRef.current!.getBoundingClientRect();\n      const input: [number, number] = [0, rect.height];\n      const output: [number, number] = [max, min];\n      const value = linearScale(input, output);\n\n      rectRef.current = rect;\n      return value(pointerPosition - rect.top);\n    }\n\n    return (\n      <SliderOrientationProvider\n        scope={props.__scopeSlider}\n        startEdge=\"bottom\"\n        endEdge=\"top\"\n        size=\"height\"\n        direction={1}\n      >\n        <SliderImpl\n          data-orientation=\"vertical\"\n          {...sliderProps}\n          ref={ref}\n          style={{\n            ...sliderProps.style,\n            ['--radix-slider-thumb-transform' as any]: 'translateY(50%)',\n          }}\n          onSlideStart={(event) => {\n            const value = getValueFromPointer(event.clientY);\n            onSlideStart?.(value);\n          }}\n          onSlideMove={(event) => {\n            const value = getValueFromPointer(event.clientY);\n            onSlideMove?.(value);\n          }}\n          onSlideEnd={() => (rectRef.current = undefined)}\n          onStepKeyDown={(event) => {\n            const isBackKey = BACK_KEYS.ltr.includes(event.key);\n            onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });\n          }}\n        />\n      </SliderOrientationProvider>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderImpl\n * -----------------------------------------------------------------------------------------------*/\n\ntype SliderImplElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ntype SliderImplPrivateProps = {\n  onSlideStart(event: React.PointerEvent): void;\n  onSlideMove(event: React.PointerEvent): void;\n  onSlideEnd(event: React.PointerEvent): void;\n  onHomeKeyDown(event: React.KeyboardEvent): void;\n  onEndKeyDown(event: React.KeyboardEvent): void;\n  onStepKeyDown(event: React.KeyboardEvent): void;\n};\ninterface SliderImplProps extends PrimitiveDivProps, SliderImplPrivateProps {}\n\nconst SliderImpl = React.forwardRef<SliderImplElement, SliderImplProps>(\n  (props: ScopedProps<SliderImplProps>, forwardedRef) => {\n    const {\n      __scopeSlider,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onHomeKeyDown,\n      onEndKeyDown,\n      onStepKeyDown,\n      ...sliderProps\n    } = props;\n    const context = useSliderContext(SLIDER_NAME, __scopeSlider);\n\n    return (\n      <Primitive.span\n        {...sliderProps}\n        ref={forwardedRef}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          if (event.key === 'Home') {\n            onHomeKeyDown(event);\n            // Prevent scrolling to page start\n            event.preventDefault();\n          } else if (event.key === 'End') {\n            onEndKeyDown(event);\n            // Prevent scrolling to page end\n            event.preventDefault();\n          } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {\n            onStepKeyDown(event);\n            // Prevent scrolling for directional key presses\n            event.preventDefault();\n          }\n        })}\n        onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n          const target = event.target as HTMLElement;\n          target.setPointerCapture(event.pointerId);\n          // Prevent browser focus behaviour because we focus a thumb manually when values change.\n          event.preventDefault();\n          // Touch devices have a delay before focusing so won't focus if touch immediately moves\n          // away from target (sliding). We want thumb to focus regardless.\n          if (context.thumbs.has(target)) {\n            target.focus();\n          } else {\n            onSlideStart(event);\n          }\n        })}\n        onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n          const target = event.target as HTMLElement;\n          if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);\n        })}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          const target = event.target as HTMLElement;\n          if (target.hasPointerCapture(event.pointerId)) {\n            target.releasePointerCapture(event.pointerId);\n            onSlideEnd(event);\n          }\n        })}\n      />\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderTrack\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRACK_NAME = 'SliderTrack';\n\ntype SliderTrackElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface SliderTrackProps extends PrimitiveSpanProps {}\n\nconst SliderTrack = React.forwardRef<SliderTrackElement, SliderTrackProps>(\n  (props: ScopedProps<SliderTrackProps>, forwardedRef) => {\n    const { __scopeSlider, ...trackProps } = props;\n    const context = useSliderContext(TRACK_NAME, __scopeSlider);\n    return (\n      <Primitive.span\n        data-disabled={context.disabled ? '' : undefined}\n        data-orientation={context.orientation}\n        {...trackProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nSliderTrack.displayName = TRACK_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderRange\n * -----------------------------------------------------------------------------------------------*/\n\nconst RANGE_NAME = 'SliderRange';\n\ntype SliderRangeElement = React.ElementRef<typeof Primitive.span>;\ninterface SliderRangeProps extends PrimitiveSpanProps {}\n\nconst SliderRange = React.forwardRef<SliderRangeElement, SliderRangeProps>(\n  (props: ScopedProps<SliderRangeProps>, forwardedRef) => {\n    const { __scopeSlider, ...rangeProps } = props;\n    const context = useSliderContext(RANGE_NAME, __scopeSlider);\n    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);\n    const ref = React.useRef<HTMLSpanElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const valuesCount = context.values.length;\n    const percentages = context.values.map((value) =>\n      convertValueToPercentage(value, context.min, context.max)\n    );\n    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;\n    const offsetEnd = 100 - Math.max(...percentages);\n\n    return (\n      <Primitive.span\n        data-orientation={context.orientation}\n        data-disabled={context.disabled ? '' : undefined}\n        {...rangeProps}\n        ref={composedRefs}\n        style={{\n          ...props.style,\n          [orientation.startEdge]: offsetStart + '%',\n          [orientation.endEdge]: offsetEnd + '%',\n        }}\n      />\n    );\n  }\n);\n\nSliderRange.displayName = RANGE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderThumb\n * -----------------------------------------------------------------------------------------------*/\n\nconst THUMB_NAME = 'SliderThumb';\n\ntype SliderThumbElement = SliderThumbImplElement;\ninterface SliderThumbProps extends Omit<SliderThumbImplProps, 'index'> {}\n\nconst SliderThumb = React.forwardRef<SliderThumbElement, SliderThumbProps>(\n  (props: ScopedProps<SliderThumbProps>, forwardedRef) => {\n    const getItems = useCollection(props.__scopeSlider);\n    const [thumb, setThumb] = React.useState<SliderThumbImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));\n    const index = React.useMemo(\n      () => (thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1),\n      [getItems, thumb]\n    );\n    return <SliderThumbImpl {...props} ref={composedRefs} index={index} />;\n  }\n);\n\ntype SliderThumbImplElement = React.ElementRef<typeof Primitive.span>;\ninterface SliderThumbImplProps extends PrimitiveSpanProps {\n  index: number;\n}\n\nconst SliderThumbImpl = React.forwardRef<SliderThumbImplElement, SliderThumbImplProps>(\n  (props: ScopedProps<SliderThumbImplProps>, forwardedRef) => {\n    const { __scopeSlider, index, ...thumbProps } = props;\n    const context = useSliderContext(THUMB_NAME, __scopeSlider);\n    const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);\n    const [thumb, setThumb] = React.useState<HTMLSpanElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));\n    const size = useSize(thumb);\n    // We cast because index could be `-1` which would return undefined\n    const value = context.values[index] as number | undefined;\n    const percent =\n      value === undefined ? 0 : convertValueToPercentage(value, context.min, context.max);\n    const label = getLabel(index, context.values.length);\n    const orientationSize = size?.[orientation.size];\n    const thumbInBoundsOffset = orientationSize\n      ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction)\n      : 0;\n\n    React.useEffect(() => {\n      if (thumb) {\n        context.thumbs.add(thumb);\n        return () => {\n          context.thumbs.delete(thumb);\n        };\n      }\n    }, [thumb, context.thumbs]);\n\n    return (\n      <span\n        style={{\n          transform: 'var(--radix-slider-thumb-transform)',\n          position: 'absolute',\n          [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`,\n        }}\n      >\n        <Collection.ItemSlot scope={props.__scopeSlider}>\n          <Primitive.span\n            role=\"slider\"\n            aria-label={props['aria-label'] || label}\n            aria-valuemin={context.min}\n            aria-valuenow={value}\n            aria-valuemax={context.max}\n            aria-orientation={context.orientation}\n            data-orientation={context.orientation}\n            data-disabled={context.disabled ? '' : undefined}\n            tabIndex={context.disabled ? undefined : 0}\n            {...thumbProps}\n            ref={composedRefs}\n            /**\n             * There will be no value on initial render while we work out the index so we hide thumbs\n             * without a value, otherwise SSR will render them in the wrong position before they\n             * snap into the correct position during hydration which would be visually jarring for\n             * slower connections.\n             */\n            style={value === undefined ? { display: 'none' } : props.style}\n            onFocus={composeEventHandlers(props.onFocus, () => {\n              context.valueIndexToChangeRef.current = index;\n            })}\n          />\n        </Collection.ItemSlot>\n      </span>\n    );\n  }\n);\n\nSliderThumb.displayName = THUMB_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst BubbleInput = (props: Radix.ComponentPropsWithoutRef<'input'>) => {\n  const { value, ...inputProps } = props;\n  const ref = React.useRef<HTMLInputElement>(null);\n  const prevValue = usePrevious(value);\n\n  // Bubble value change to parents (e.g form change event)\n  React.useEffect(() => {\n    const input = ref.current!;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'value') as PropertyDescriptor;\n    const setValue = descriptor.set;\n    if (prevValue !== value && setValue) {\n      const event = new Event('input', { bubbles: true });\n      setValue.call(input, value);\n      input.dispatchEvent(event);\n    }\n  }, [prevValue, value]);\n\n  /**\n   * We purposefully do not use `type=\"hidden\"` here otherwise forms that\n   * wrap it will not be able to access its value via the FormData API.\n   *\n   * We purposefully do not add the `value` attribute here to allow the value\n   * to be set programatically and bubble to any parent form `onChange` event.\n   * Adding the `value` will cause React to consider the programatic\n   * dispatch a duplicate and it will get swallowed.\n   */\n  return <input style={{ display: 'none' }} {...inputProps} ref={ref} defaultValue={value} />;\n};\n\nfunction getNextSortedValues(prevValues: number[] = [], nextValue: number, atIndex: number) {\n  const nextValues = [...prevValues];\n  nextValues[atIndex] = nextValue;\n  return nextValues.sort((a, b) => a - b);\n}\n\nfunction convertValueToPercentage(value: number, min: number, max: number) {\n  const maxSteps = max - min;\n  const percentPerStep = 100 / maxSteps;\n  return percentPerStep * (value - min);\n}\n\n/**\n * Returns a label for each thumb when there are two or more thumbs\n */\nfunction getLabel(index: number, totalValues: number) {\n  if (totalValues > 2) {\n    return `Value ${index + 1} of ${totalValues}`;\n  } else if (totalValues === 2) {\n    return ['Minimum', 'Maximum'][index];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Given a `values` array and a `nextValue`, determine which value in\n * the array is closest to `nextValue` and return its index.\n *\n * @example\n * // returns 1\n * getClosestValueIndex([10, 30], 25);\n */\nfunction getClosestValueIndex(values: number[], nextValue: number) {\n  if (values.length === 1) return 0;\n  const distances = values.map((value) => Math.abs(value - nextValue));\n  const closestDistance = Math.min(...distances);\n  return distances.indexOf(closestDistance);\n}\n\n/**\n * Offsets the thumb centre point while sliding to ensure it remains\n * within the bounds of the slider when reaching the edges\n */\nfunction getThumbInBoundsOffset(width: number, left: number, direction: number) {\n  const halfWidth = width / 2;\n  const halfPercent = 50;\n  const offset = linearScale([0, halfPercent], [0, halfWidth]);\n  return (halfWidth - offset(left) * direction) * direction;\n}\n\n/**\n * Gets an array of steps between each value.\n *\n * @example\n * // returns [1, 9]\n * getStepsBetweenValues([10, 11, 20]);\n */\nfunction getStepsBetweenValues(values: number[]) {\n  return values.slice(0, -1).map((value, index) => values[index + 1] - value);\n}\n\n/**\n * Verifies the minimum steps between all values is greater than or equal\n * to the expected minimum steps.\n *\n * @example\n * // returns false\n * hasMinStepsBetweenValues([1,2,3], 2);\n *\n * @example\n * // returns true\n * hasMinStepsBetweenValues([1,2,3], 1);\n */\nfunction hasMinStepsBetweenValues(values: number[], minStepsBetweenValues: number) {\n  if (minStepsBetweenValues > 0) {\n    const stepsBetweenValues = getStepsBetweenValues(values);\n    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);\n    return actualMinStepsBetweenValues >= minStepsBetweenValues;\n  }\n  return true;\n}\n\n// https://github.com/tmcw-up-for-adoption/simple-linear-scale/blob/master/index.js\nfunction linearScale(input: readonly [number, number], output: readonly [number, number]) {\n  return (value: number) => {\n    if (input[0] === input[1] || output[0] === output[1]) return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\n\nfunction getDecimalCount(value: number) {\n  return (String(value).split('.')[1] || '').length;\n}\n\nfunction roundValue(value: number, decimalCount: number) {\n  const rounder = Math.pow(10, decimalCount);\n  return Math.round(value * rounder) / rounder;\n}\n\nconst Root = Slider;\nconst Track = SliderTrack;\nconst Range = SliderRange;\nconst Thumb = SliderThumb;\n\nexport {\n  createSliderScope,\n  //\n  Slider,\n  SliderTrack,\n  SliderRange,\n  SliderThumb,\n  //\n  Root,\n  Track,\n  Range,\n  Thumb,\n};\nexport type { SliderProps, SliderTrackProps, SliderRangeProps, SliderThumbProps };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}