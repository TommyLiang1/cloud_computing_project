{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n  return ar;\n};\nimport API from '@aws-amplify/api';\nimport { Auth } from '@aws-amplify/auth';\nimport Cache from '@aws-amplify/cache';\nimport { Amplify, ConsoleLogger as Logger, Hub, JS, BackgroundProcessManager } from '@aws-amplify/core';\nimport { immerable, produce, setAutoFreeze, enablePatches } from 'immer';\nimport { v4 as uuid4 } from 'uuid';\nimport Observable from 'zen-observable-ts';\nimport { defaultAuthStrategy, multiAuthStrategy } from '../authModeStrategies';\nimport { isPredicatesAll, ModelPredicateCreator, ModelSortPredicateCreator } from '../predicates';\nimport { ExclusiveStorage as Storage } from '../storage/storage';\nimport { ControlMessage, SyncEngine } from '../sync';\nimport { GraphQLScalarType, isGraphQLScalarType, isSchemaModelWithAttributes, AuthModeStrategyType, isNonModelFieldType, isModelFieldType, isIdentifierObject } from '../types';\nimport { DATASTORE, errorMessages, establishRelationAndKeys, exhaustiveCheck, isModelConstructor, monotonicUlidFactory, STORAGE, SYNC, USER, isNullOrUndefined, registerNonModelClass, sortCompareFunction, DeferredCallbackResolver, extractPrimaryKeyFieldNames, extractPrimaryKeysAndValues, isIdManaged, isIdOptionallyManaged, validatePredicate, mergePatches } from '../util';\nimport { getIdentifierValue } from '../sync/utils';\nsetAutoFreeze(true);\nenablePatches();\nvar logger = new Logger('DataStore');\nvar ulid = monotonicUlidFactory(Date.now());\nvar isNode = JS.browserOrNode().isNode;\nvar SETTING_SCHEMA_VERSION = 'schemaVersion';\nvar schema;\nvar modelNamespaceMap = new WeakMap();\n// stores data for crafting the correct update mutation input for a model\n// Patch[] - array of changed fields and metadata\n// PersistentModel - the source model, used for diffing object-type fields\nvar modelPatchesMap = new WeakMap();\nvar getModelDefinition = function (modelConstructor) {\n  var namespace = modelNamespaceMap.get(modelConstructor);\n  return schema.namespaces[namespace].models[modelConstructor.name];\n};\nvar isValidModelConstructor = function (obj) {\n  return isModelConstructor(obj) && modelNamespaceMap.has(obj);\n};\nvar namespaceResolver = function (modelConstructor) {\n  return modelNamespaceMap.get(modelConstructor);\n};\n// exporting syncClasses for testing outbox.test.ts\nexport var syncClasses;\nvar userClasses;\nvar dataStoreClasses;\nvar storageClasses;\nvar initSchema = function (userSchema) {\n  var _a;\n  if (schema !== undefined) {\n    console.warn('The schema has already been initialized');\n    return userClasses;\n  }\n  logger.log('validating schema', {\n    schema: userSchema\n  });\n  var internalUserNamespace = __assign({\n    name: USER\n  }, userSchema);\n  logger.log('DataStore', 'Init models');\n  userClasses = createTypeClasses(internalUserNamespace);\n  logger.log('DataStore', 'Models initialized');\n  var dataStoreNamespace = getNamespace();\n  var storageNamespace = Storage.getNamespace();\n  var syncNamespace = SyncEngine.getNamespace();\n  dataStoreClasses = createTypeClasses(dataStoreNamespace);\n  storageClasses = createTypeClasses(storageNamespace);\n  syncClasses = createTypeClasses(syncNamespace);\n  schema = {\n    namespaces: (_a = {}, _a[dataStoreNamespace.name] = dataStoreNamespace, _a[internalUserNamespace.name] = internalUserNamespace, _a[storageNamespace.name] = storageNamespace, _a[syncNamespace.name] = syncNamespace, _a),\n    version: userSchema.version\n  };\n  Object.keys(schema.namespaces).forEach(function (namespace) {\n    var e_1, _a;\n    var _b = __read(establishRelationAndKeys(schema.namespaces[namespace]), 2),\n      relations = _b[0],\n      keys = _b[1];\n    schema.namespaces[namespace].relationships = relations;\n    schema.namespaces[namespace].keys = keys;\n    var modelAssociations = new Map();\n    Object.values(schema.namespaces[namespace].models).forEach(function (model) {\n      var connectedModels = [];\n      Object.values(model.fields).filter(function (field) {\n        return field.association && field.association.connectionType === 'BELONGS_TO' && field.type.model !== model.name;\n      }).forEach(function (field) {\n        return connectedModels.push(field.type.model);\n      });\n      modelAssociations.set(model.name, connectedModels);\n    });\n    var result = new Map();\n    var count = 1000;\n    while (true && count > 0) {\n      if (modelAssociations.size === 0) {\n        break;\n      }\n      count--;\n      if (count === 0) {\n        throw new Error('Models are not topologically sortable. Please verify your schema.');\n      }\n      try {\n        for (var _c = (e_1 = void 0, __values(Array.from(modelAssociations.keys()))), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var modelName = _d.value;\n          var parents = modelAssociations.get(modelName);\n          if (parents.every(function (x) {\n            return result.has(x);\n          })) {\n            result.set(modelName, parents);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      Array.from(result.keys()).forEach(function (x) {\n        return modelAssociations.delete(x);\n      });\n    }\n    schema.namespaces[namespace].modelTopologicalOrdering = result;\n  });\n  return userClasses;\n};\n/**\n * Throws an exception if the schema has *not* been initialized\n * by `initSchema()`.\n *\n * **To be called before trying to access schema.**\n *\n * Currently this only needs to be called in `start()` and `clear()` because\n * all other functions will call start first.\n */\nvar checkSchemaInitialized = function () {\n  if (schema === undefined) {\n    var message = 'Schema is not initialized. DataStore will not function as expected. This could happen if you have multiple versions of DataStore installed. Please see https://docs.amplify.aws/lib/troubleshooting/upgrading/q/platform/js/#check-for-duplicate-versions';\n    logger.error(message);\n    throw new Error(message);\n  }\n};\nvar createTypeClasses = function (namespace) {\n  var classes = {};\n  Object.entries(namespace.models).forEach(function (_a) {\n    var _b = __read(_a, 2),\n      modelName = _b[0],\n      modelDefinition = _b[1];\n    var clazz = createModelClass(modelDefinition);\n    classes[modelName] = clazz;\n    modelNamespaceMap.set(clazz, namespace.name);\n  });\n  Object.entries(namespace.nonModels || {}).forEach(function (_a) {\n    var _b = __read(_a, 2),\n      typeName = _b[0],\n      typeDefinition = _b[1];\n    var clazz = createNonModelClass(typeDefinition);\n    classes[typeName] = clazz;\n  });\n  return classes;\n};\n/**\n * Collection of instantiated models to allow storage of metadata apart from\n * the model visible to the consuming app -- in case the app doesn't have\n * metadata fields (_version, _deleted, etc.) exposed on the model itself.\n */\nvar instancesMetadata = new WeakSet();\nfunction modelInstanceCreator(modelConstructor, init) {\n  instancesMetadata.add(init);\n  return new modelConstructor(init);\n}\nvar validateModelFields = function (modelDefinition) {\n  return function (k, v) {\n    var fieldDefinition = modelDefinition.fields[k];\n    if (fieldDefinition !== undefined) {\n      var type_1 = fieldDefinition.type,\n        isRequired_1 = fieldDefinition.isRequired,\n        isArrayNullable = fieldDefinition.isArrayNullable,\n        name_1 = fieldDefinition.name,\n        isArray = fieldDefinition.isArray;\n      if ((!isArray && isRequired_1 || isArray && !isArrayNullable) && (v === null || v === undefined)) {\n        throw new Error(\"Field \" + name_1 + \" is required\");\n      }\n      if (isSchemaModelWithAttributes(modelDefinition) && !isIdManaged(modelDefinition)) {\n        var keys = extractPrimaryKeyFieldNames(modelDefinition);\n        if (keys.includes(k) && v === '') {\n          logger.error(errorMessages.idEmptyString, {\n            k: k,\n            value: v\n          });\n          throw new Error(errorMessages.idEmptyString);\n        }\n      }\n      if (isGraphQLScalarType(type_1)) {\n        var jsType_1 = GraphQLScalarType.getJSType(type_1);\n        var validateScalar_1 = GraphQLScalarType.getValidationFunction(type_1);\n        if (type_1 === 'AWSJSON') {\n          if (typeof v === jsType_1) {\n            return;\n          }\n          if (typeof v === 'string') {\n            try {\n              JSON.parse(v);\n              return;\n            } catch (error) {\n              throw new Error(\"Field \" + name_1 + \" is an invalid JSON object. \" + v);\n            }\n          }\n        }\n        if (isArray) {\n          var errorTypeText = jsType_1;\n          if (!isRequired_1) {\n            errorTypeText = jsType_1 + \" | null | undefined\";\n          }\n          if (!Array.isArray(v) && !isArrayNullable) {\n            throw new Error(\"Field \" + name_1 + \" should be of type [\" + errorTypeText + \"], \" + typeof v + \" received. \" + v);\n          }\n          if (!isNullOrUndefined(v) && v.some(function (e) {\n            return isNullOrUndefined(e) ? isRequired_1 : typeof e !== jsType_1;\n          })) {\n            var elemTypes = v.map(function (e) {\n              return e === null ? 'null' : typeof e;\n            }).join(',');\n            throw new Error(\"All elements in the \" + name_1 + \" array should be of type \" + errorTypeText + \", [\" + elemTypes + \"] received. \" + v);\n          }\n          if (validateScalar_1 && !isNullOrUndefined(v)) {\n            var validationStatus = v.map(function (e) {\n              if (!isNullOrUndefined(e)) {\n                return validateScalar_1(e);\n              } else if (isNullOrUndefined(e) && !isRequired_1) {\n                return true;\n              } else {\n                return false;\n              }\n            });\n            if (!validationStatus.every(function (s) {\n              return s;\n            })) {\n              throw new Error(\"All elements in the \" + name_1 + \" array should be of type \" + type_1 + \", validation failed for one or more elements. \" + v);\n            }\n          }\n        } else if (!isRequired_1 && v === undefined) {\n          return;\n        } else if (typeof v !== jsType_1 && v !== null) {\n          throw new Error(\"Field \" + name_1 + \" should be of type \" + jsType_1 + \", \" + typeof v + \" received. \" + v);\n        } else if (!isNullOrUndefined(v) && validateScalar_1 && !validateScalar_1(v)) {\n          throw new Error(\"Field \" + name_1 + \" should be of type \" + type_1 + \", validation failed. \" + v);\n        }\n      } else if (isNonModelFieldType(type_1)) {\n        // do not check non model fields if undefined or null\n        if (!isNullOrUndefined(v)) {\n          var subNonModelDefinition_1 = schema.namespaces.user.nonModels[type_1.nonModel];\n          var modelValidator_1 = validateModelFields(subNonModelDefinition_1);\n          if (isArray) {\n            var errorTypeText = type_1.nonModel;\n            if (!isRequired_1) {\n              errorTypeText = type_1.nonModel + \" | null | undefined\";\n            }\n            if (!Array.isArray(v)) {\n              throw new Error(\"Field \" + name_1 + \" should be of type [\" + errorTypeText + \"], \" + typeof v + \" received. \" + v);\n            }\n            v.forEach(function (item) {\n              if (isNullOrUndefined(item) && isRequired_1 || typeof item !== 'object' && typeof item !== 'undefined') {\n                throw new Error(\"All elements in the \" + name_1 + \" array should be of type \" + type_1.nonModel + \", [\" + typeof item + \"] received. \" + item);\n              }\n              if (!isNullOrUndefined(item)) {\n                Object.keys(subNonModelDefinition_1.fields).forEach(function (subKey) {\n                  modelValidator_1(subKey, item[subKey]);\n                });\n              }\n            });\n          } else {\n            if (typeof v !== 'object') {\n              throw new Error(\"Field \" + name_1 + \" should be of type \" + type_1.nonModel + \", \" + typeof v + \" recieved. \" + v);\n            }\n            Object.keys(subNonModelDefinition_1.fields).forEach(function (subKey) {\n              modelValidator_1(subKey, v[subKey]);\n            });\n          }\n        }\n      }\n    }\n  };\n};\nvar castInstanceType = function (modelDefinition, k, v) {\n  var _a = modelDefinition.fields[k] || {},\n    isArray = _a.isArray,\n    type = _a.type;\n  // attempt to parse stringified JSON\n  if (typeof v === 'string' && (isArray || type === 'AWSJSON' || isNonModelFieldType(type) || isModelFieldType(type))) {\n    try {\n      return JSON.parse(v);\n    } catch (_b) {\n      // if JSON is invalid, don't throw and let modelValidator handle it\n    }\n  }\n  // cast from numeric representation of boolean to JS boolean\n  if (typeof v === 'number' && type === 'Boolean') {\n    return Boolean(v);\n  }\n  return v;\n};\nvar initializeInstance = function (init, modelDefinition, draft) {\n  var modelValidator = validateModelFields(modelDefinition);\n  Object.entries(init).forEach(function (_a) {\n    var _b = __read(_a, 2),\n      k = _b[0],\n      v = _b[1];\n    var parsedValue = castInstanceType(modelDefinition, k, v);\n    modelValidator(k, parsedValue);\n    draft[k] = parsedValue;\n  });\n};\nvar createModelClass = function (modelDefinition) {\n  var clazz = /** @class */function () {\n    function Model(init) {\n      var instance = produce(this, function (draft) {\n        initializeInstance(init, modelDefinition, draft);\n        // model is initialized inside a DataStore component (e.g. by Sync Engine, Storage Engine, etc.)\n        var isInternallyInitialized = instancesMetadata.has(init);\n        var modelInstanceMetadata = isInternallyInitialized ? init : {};\n        var _id = modelInstanceMetadata.id;\n        if (isIdManaged(modelDefinition)) {\n          var isInternalModel = _id !== null && _id !== undefined;\n          var id = isInternalModel ? _id : modelDefinition.syncable ? uuid4() : ulid();\n          draft.id = id;\n        } else if (isIdOptionallyManaged(modelDefinition)) {\n          // only auto-populate if the id was not provided\n          draft.id = draft.id || uuid4();\n        }\n        if (!isInternallyInitialized) {\n          checkReadOnlyPropertyOnCreate(draft, modelDefinition);\n        }\n        var _version = modelInstanceMetadata._version,\n          _lastChangedAt = modelInstanceMetadata._lastChangedAt,\n          _deleted = modelInstanceMetadata._deleted;\n        if (modelDefinition.syncable) {\n          draft._version = _version;\n          draft._lastChangedAt = _lastChangedAt;\n          draft._deleted = _deleted;\n        }\n      });\n      return instance;\n    }\n    Model.copyOf = function (source, fn) {\n      var modelConstructor = Object.getPrototypeOf(source || {}).constructor;\n      if (!isValidModelConstructor(modelConstructor)) {\n        var msg = 'The source object is not a valid model';\n        logger.error(msg, {\n          source: source\n        });\n        throw new Error(msg);\n      }\n      var patches;\n      var model = produce(source, function (draft) {\n        fn(draft);\n        var keyNames = extractPrimaryKeyFieldNames(modelDefinition);\n        // Keys are immutable\n        keyNames.forEach(function (key) {\n          return draft[key] = source[key];\n        });\n        var modelValidator = validateModelFields(modelDefinition);\n        Object.entries(draft).forEach(function (_a) {\n          var _b = __read(_a, 2),\n            k = _b[0],\n            v = _b[1];\n          var parsedValue = castInstanceType(modelDefinition, k, v);\n          modelValidator(k, parsedValue);\n        });\n      }, function (p) {\n        return patches = p;\n      });\n      var hasExistingPatches = modelPatchesMap.has(source);\n      if (patches.length || hasExistingPatches) {\n        if (hasExistingPatches) {\n          var _a = __read(modelPatchesMap.get(source), 2),\n            existingPatches = _a[0],\n            existingSource = _a[1];\n          var mergedPatches = mergePatches(existingSource, existingPatches, patches);\n          modelPatchesMap.set(model, [mergedPatches, existingSource]);\n          checkReadOnlyPropertyOnUpdate(mergedPatches, modelDefinition);\n        } else {\n          modelPatchesMap.set(model, [patches, source]);\n          checkReadOnlyPropertyOnUpdate(patches, modelDefinition);\n        }\n      }\n      return model;\n    };\n    // \"private\" method (that's hidden via `Setting`) for `withSSRContext` to use\n    // to gain access to `modelInstanceCreator` and `clazz` for persisting IDs from server to client.\n    Model.fromJSON = function (json) {\n      var _this = this;\n      if (Array.isArray(json)) {\n        return json.map(function (init) {\n          return _this.fromJSON(init);\n        });\n      }\n      var instance = modelInstanceCreator(clazz, json);\n      var modelValidator = validateModelFields(modelDefinition);\n      Object.entries(instance).forEach(function (_a) {\n        var _b = __read(_a, 2),\n          k = _b[0],\n          v = _b[1];\n        modelValidator(k, v);\n      });\n      return instance;\n    };\n    return Model;\n  }();\n  clazz[immerable] = true;\n  Object.defineProperty(clazz, 'name', {\n    value: modelDefinition.name\n  });\n  return clazz;\n};\nvar checkReadOnlyPropertyOnCreate = function (draft, modelDefinition) {\n  var modelKeys = Object.keys(draft);\n  var fields = modelDefinition.fields;\n  modelKeys.forEach(function (key) {\n    if (fields[key] && fields[key].isReadOnly) {\n      throw new Error(key + \" is read-only.\");\n    }\n  });\n};\nvar checkReadOnlyPropertyOnUpdate = function (patches, modelDefinition) {\n  var patchArray = patches.map(function (p) {\n    return [p.path[0], p.value];\n  });\n  var fields = modelDefinition.fields;\n  patchArray.forEach(function (_a) {\n    var _b = __read(_a, 2),\n      key = _b[0],\n      val = _b[1];\n    if (!val || !fields[key]) return;\n    if (fields[key].isReadOnly) {\n      throw new Error(key + \" is read-only.\");\n    }\n  });\n};\nvar createNonModelClass = function (typeDefinition) {\n  var clazz = /** @class */function () {\n    function Model(init) {\n      var instance = produce(this, function (draft) {\n        initializeInstance(init, typeDefinition, draft);\n      });\n      return instance;\n    }\n    return Model;\n  }();\n  clazz[immerable] = true;\n  Object.defineProperty(clazz, 'name', {\n    value: typeDefinition.name\n  });\n  registerNonModelClass(clazz);\n  return clazz;\n};\nfunction isQueryOne(obj) {\n  return typeof obj === 'string';\n}\nfunction defaultConflictHandler(conflictData) {\n  var localModel = conflictData.localModel,\n    modelConstructor = conflictData.modelConstructor,\n    remoteModel = conflictData.remoteModel;\n  var _version = remoteModel._version;\n  return modelInstanceCreator(modelConstructor, __assign(__assign({}, localModel), {\n    _version: _version\n  }));\n}\nfunction defaultErrorHandler(error) {\n  logger.warn(error);\n}\nfunction getModelConstructorByModelName(namespaceName, modelName) {\n  var result;\n  switch (namespaceName) {\n    case DATASTORE:\n      result = dataStoreClasses[modelName];\n      break;\n    case USER:\n      result = userClasses[modelName];\n      break;\n    case SYNC:\n      result = syncClasses[modelName];\n      break;\n    case STORAGE:\n      result = storageClasses[modelName];\n      break;\n    default:\n      exhaustiveCheck(namespaceName);\n      break;\n  }\n  if (isValidModelConstructor(result)) {\n    return result;\n  } else {\n    var msg = \"Model name is not valid for namespace. modelName: \" + modelName + \", namespace: \" + namespaceName;\n    logger.error(msg);\n    throw new Error(msg);\n  }\n}\n/**\n * Queries the DataStore metadata tables to see if they are the expected\n * version. If not, clobbers the whole DB. If so, leaves them alone.\n * Otherwise, simply writes the schema version.\n *\n * SIDE EFFECT:\n * 1. Creates a transaction\n * 1. Updates data.\n *\n * @param storage Storage adapter containing the metadata.\n * @param version The expected schema version.\n */\nfunction checkSchemaVersion(storage, version) {\n  return __awaiter(this, void 0, void 0, function () {\n    var Setting, modelDefinition;\n    var _this = this;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          Setting = dataStoreClasses.Setting;\n          modelDefinition = schema.namespaces[DATASTORE].models.Setting;\n          return [4 /*yield*/, storage.runExclusive(function (s) {\n            return __awaiter(_this, void 0, void 0, function () {\n              var _a, schemaVersionSetting, storedValue;\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    return [4 /*yield*/, s.query(Setting, ModelPredicateCreator.createFromExisting(modelDefinition, function (c) {\n                      return c.key('eq', SETTING_SCHEMA_VERSION);\n                    }), {\n                      page: 0,\n                      limit: 1\n                    })];\n                  case 1:\n                    _a = __read.apply(void 0, [_b.sent(), 1]), schemaVersionSetting = _a[0];\n                    if (!(schemaVersionSetting !== undefined && schemaVersionSetting.value !== undefined)) return [3 /*break*/, 4];\n                    storedValue = JSON.parse(schemaVersionSetting.value);\n                    if (!(storedValue !== version)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, s.clear(false)];\n                  case 2:\n                    _b.sent();\n                    _b.label = 3;\n                  case 3:\n                    return [3 /*break*/, 6];\n                  case 4:\n                    return [4 /*yield*/, s.save(modelInstanceCreator(Setting, {\n                      key: SETTING_SCHEMA_VERSION,\n                      value: JSON.stringify(version)\n                    }))];\n                  case 5:\n                    _b.sent();\n                    _b.label = 6;\n                  case 6:\n                    return [2 /*return*/];\n                }\n              });\n            });\n          })];\n\n        case 1:\n          _a.sent();\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nvar syncSubscription;\nfunction getNamespace() {\n  var namespace = {\n    name: DATASTORE,\n    relationships: {},\n    enums: {},\n    nonModels: {},\n    models: {\n      Setting: {\n        name: 'Setting',\n        pluralName: 'Settings',\n        syncable: false,\n        fields: {\n          id: {\n            name: 'id',\n            type: 'ID',\n            isRequired: true,\n            isArray: false\n          },\n          key: {\n            name: 'key',\n            type: 'String',\n            isRequired: true,\n            isArray: false\n          },\n          value: {\n            name: 'value',\n            type: 'String',\n            isRequired: true,\n            isArray: false\n          }\n        }\n      }\n    }\n  };\n  return namespace;\n}\nvar DataStoreState;\n(function (DataStoreState) {\n  DataStoreState[\"NotRunning\"] = \"Not Running\";\n  DataStoreState[\"Starting\"] = \"Starting\";\n  DataStoreState[\"Running\"] = \"Running\";\n  DataStoreState[\"Stopping\"] = \"Stopping\";\n  DataStoreState[\"Clearing\"] = \"Clearing\";\n})(DataStoreState || (DataStoreState = {}));\nvar DataStore = /** @class */function () {\n  function DataStore() {\n    var _this = this;\n    // reference to configured category instances. Used for preserving SSR context\n    this.Auth = Auth;\n    this.API = API;\n    this.Cache = Cache;\n    this.amplifyConfig = {};\n    this.syncPredicates = new WeakMap();\n    // object that gets passed to descendent classes. Allows us to pass these down by reference\n    this.amplifyContext = {\n      Auth: this.Auth,\n      API: this.API,\n      Cache: this.Cache\n    };\n    /**\n     * **IMPORTANT!**\n     *\n     * Accumulator for background things that can **and MUST** be called when\n     * DataStore stops.\n     *\n     * These jobs **MUST** be *idempotent promises* that resolve ONLY\n     * once the intended jobs are completely finished and/or otherwise destroyed\n     * and cleaned up with ZERO outstanding:\n     *\n     * 1. side effects (e.g., state changes)\n     * 1. callbacks\n     * 1. subscriptions\n     * 1. calls to storage\n     * 1. *etc.*\n     *\n     * Methods that create pending promises, subscriptions, callbacks, or any\n     * type of side effect **MUST** be registered with the manager. And, a new\n     * manager must be created after each `exit()`.\n     *\n     * Failure to comply will put DataStore into a highly unpredictable state\n     * when it needs to stop or clear -- which occurs when restarting with new\n     * sync expressions, during testing, and potentially during app code\n     * recovery handling, etc..\n     *\n     * It is up to the discretion of each disposer whether to wait for job\n     * completion or to cancel operations and issue failures *as long as the\n     * disposer returns in a reasonable amount of time.*\n     *\n     * (Reasonable = *seconds*, not minutes.)\n     */\n    this.runningProcesses = new BackgroundProcessManager();\n    /**\n     * Indicates what state DataStore is in.\n     *\n     * Not [yet?] used for actual state management; but for messaging\n     * when errors occur, to help troubleshoot.\n     */\n    this.state = DataStoreState.NotRunning;\n    /**\n     * If not already done:\n     * 1. Attaches and initializes storage.\n     * 1. Loads the schema and records metadata.\n     * 1. If `this.amplifyConfig.aws_appsync_graphqlEndpoint` contains a URL,\n     * attaches a sync engine, starts it, and subscribes.\n     */\n    this.start = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _this = this;\n        return __generator(this, function (_a) {\n          return [2 /*return*/, this.runningProcesses.add(function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var aws_appsync_graphqlEndpoint, _a, fullSyncIntervalInMilliseconds;\n              var _this = this;\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    this.state = DataStoreState.Starting;\n                    if (!(this.initialized === undefined)) return [3 /*break*/, 1];\n                    logger.debug('Starting DataStore');\n                    this.initialized = new Promise(function (res, rej) {\n                      _this.initResolve = res;\n                      _this.initReject = rej;\n                    });\n                    return [3 /*break*/, 3];\n                  case 1:\n                    return [4 /*yield*/, this.initialized];\n                  case 2:\n                    _b.sent();\n                    return [2 /*return*/];\n                  case 3:\n                    this.storage = new Storage(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, this.storageAdapter, this.sessionId);\n                    return [4 /*yield*/, this.storage.init()];\n                  case 4:\n                    _b.sent();\n                    checkSchemaInitialized();\n                    return [4 /*yield*/, checkSchemaVersion(this.storage, schema.version)];\n                  case 5:\n                    _b.sent();\n                    aws_appsync_graphqlEndpoint = this.amplifyConfig.aws_appsync_graphqlEndpoint;\n                    if (!aws_appsync_graphqlEndpoint) return [3 /*break*/, 7];\n                    logger.debug('GraphQL endpoint available', aws_appsync_graphqlEndpoint);\n                    _a = this;\n                    return [4 /*yield*/, this.processSyncExpressions()];\n                  case 6:\n                    _a.syncPredicates = _b.sent();\n                    this.sync = new SyncEngine(schema, namespaceResolver, syncClasses, userClasses, this.storage, modelInstanceCreator, this.conflictHandler, this.errorHandler, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, this.amplifyContext, this.connectivityMonitor);\n                    fullSyncIntervalInMilliseconds = this.fullSyncInterval * 1000 * 60;\n                    syncSubscription = this.sync.start({\n                      fullSyncInterval: fullSyncIntervalInMilliseconds\n                    }).subscribe({\n                      next: function (_a) {\n                        var type = _a.type,\n                          data = _a.data;\n                        // In Node, we need to wait for queries to be synced to prevent returning empty arrays.\n                        // In the Browser, we can begin returning data once subscriptions are in place.\n                        var readyType = isNode ? ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY : ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED;\n                        if (type === readyType) {\n                          _this.initResolve();\n                        }\n                        Hub.dispatch('datastore', {\n                          event: type,\n                          data: data\n                        });\n                      },\n                      error: function (err) {\n                        logger.warn('Sync error', err);\n                        _this.initReject();\n                      }\n                    });\n                    return [3 /*break*/, 8];\n                  case 7:\n                    logger.warn(\"Data won't be synchronized. No GraphQL endpoint configured. Did you forget `Amplify.configure(awsconfig)`?\", {\n                      config: this.amplifyConfig\n                    });\n                    this.initResolve();\n                    _b.label = 8;\n                  case 8:\n                    return [4 /*yield*/, this.initialized];\n                  case 9:\n                    _b.sent();\n                    this.state = DataStoreState.Running;\n                    return [2 /*return*/];\n                }\n              });\n            });\n          }, 'datastore start').catch(this.handleAddProcError('DataStore.start()'))];\n        });\n      });\n    };\n    this.query = function (modelConstructor, identifierOrCriteria, paginationProducer) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _this = this;\n        return __generator(this, function (_a) {\n          return [2 /*return*/, this.runningProcesses.add(function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var msg, modelDefinition, keyFields, predicate, msg, pagination, result, returnOne;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4 /*yield*/, this.start()];\n                  case 1:\n                    _a.sent();\n                    //#region Input validation\n                    if (!isValidModelConstructor(modelConstructor)) {\n                      msg = 'Constructor is not for a valid model';\n                      logger.error(msg, {\n                        modelConstructor: modelConstructor\n                      });\n                      throw new Error(msg);\n                    }\n                    if (typeof identifierOrCriteria === 'string') {\n                      if (paginationProducer !== undefined) {\n                        logger.warn('Pagination is ignored when querying by id');\n                      }\n                    }\n                    modelDefinition = getModelDefinition(modelConstructor);\n                    keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n                    if (isQueryOne(identifierOrCriteria)) {\n                      if (keyFields.length > 1) {\n                        msg = errorMessages.queryByPkWithCompositeKeyPresent;\n                        logger.error(msg, {\n                          keyFields: keyFields\n                        });\n                        throw new Error(msg);\n                      }\n                      predicate = ModelPredicateCreator.createForSingleField(modelDefinition, keyFields[0], identifierOrCriteria);\n                    } else {\n                      // Object is being queried using object literal syntax\n                      if (isIdentifierObject(identifierOrCriteria, modelDefinition)) {\n                        predicate = ModelPredicateCreator.createForPk(modelDefinition, identifierOrCriteria);\n                      } else if (isPredicatesAll(identifierOrCriteria)) {\n                        // Predicates.ALL means \"all records\", so no predicate (undefined)\n                        predicate = undefined;\n                      } else {\n                        predicate = ModelPredicateCreator.createFromExisting(modelDefinition, identifierOrCriteria);\n                      }\n                    }\n                    pagination = this.processPagination(modelDefinition, paginationProducer);\n                    //#endregion\n                    logger.debug('params ready', {\n                      modelConstructor: modelConstructor,\n                      predicate: ModelPredicateCreator.getPredicates(predicate, false),\n                      pagination: __assign(__assign({}, pagination), {\n                        sort: ModelSortPredicateCreator.getPredicates(pagination && pagination.sort, false)\n                      })\n                    });\n                    return [4 /*yield*/, this.storage.query(modelConstructor, predicate, pagination)];\n                  case 2:\n                    result = _a.sent();\n                    returnOne = isQueryOne(identifierOrCriteria) || isIdentifierObject(identifierOrCriteria, modelDefinition);\n                    return [2 /*return*/, returnOne ? result[0] : result];\n                }\n              });\n            });\n          }, 'datastore query').catch(this.handleAddProcError('DataStore.query()'))];\n        });\n      });\n    };\n    this.save = function (model, condition) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _this = this;\n        return __generator(this, function (_a) {\n          return [2 /*return*/, this.runningProcesses.add(function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var patchesTuple, modelConstructor, msg, modelDefinition, producedCondition, _a, savedModel;\n              var _this = this;\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    return [4 /*yield*/, this.start()];\n                  case 1:\n                    _b.sent();\n                    patchesTuple = modelPatchesMap.get(model);\n                    modelConstructor = model ? model.constructor : undefined;\n                    if (!isValidModelConstructor(modelConstructor)) {\n                      msg = 'Object is not an instance of a valid model';\n                      logger.error(msg, {\n                        model: model\n                      });\n                      throw new Error(msg);\n                    }\n                    modelDefinition = getModelDefinition(modelConstructor);\n                    producedCondition = ModelPredicateCreator.createFromExisting(modelDefinition, condition);\n                    return [4 /*yield*/, this.storage.runExclusive(function (s) {\n                      return __awaiter(_this, void 0, void 0, function () {\n                        return __generator(this, function (_a) {\n                          switch (_a.label) {\n                            case 0:\n                              return [4 /*yield*/, s.save(model, producedCondition, undefined, patchesTuple)];\n                            case 1:\n                              _a.sent();\n                              return [2 /*return*/, s.query(modelConstructor, ModelPredicateCreator.createForPk(modelDefinition, model))];\n                          }\n                        });\n                      });\n                    })];\n                  case 2:\n                    _a = __read.apply(void 0, [_b.sent(), 1]), savedModel = _a[0];\n                    return [2 /*return*/, savedModel];\n                }\n              });\n            });\n          }, 'datastore save').catch(this.handleAddProcError('DataStore.save()'))];\n        });\n      });\n    };\n    this.setConflictHandler = function (config) {\n      var configDataStore = config.DataStore;\n      var conflictHandlerIsDefault = function () {\n        return _this.conflictHandler === defaultConflictHandler;\n      };\n      if (configDataStore && configDataStore.conflictHandler) {\n        return configDataStore.conflictHandler;\n      }\n      if (conflictHandlerIsDefault() && config.conflictHandler) {\n        return config.conflictHandler;\n      }\n      return _this.conflictHandler || defaultConflictHandler;\n    };\n    this.setErrorHandler = function (config) {\n      var configDataStore = config.DataStore;\n      var errorHandlerIsDefault = function () {\n        return _this.errorHandler === defaultErrorHandler;\n      };\n      if (configDataStore && configDataStore.errorHandler) {\n        return configDataStore.errorHandler;\n      }\n      if (errorHandlerIsDefault() && config.errorHandler) {\n        return config.errorHandler;\n      }\n      return _this.errorHandler || defaultErrorHandler;\n    };\n    this.delete = function (modelOrConstructor, identifierOrCriteria) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _this = this;\n        return __generator(this, function (_a) {\n          return [2 /*return*/, this.runningProcesses.add(function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var condition, msg, modelConstructor, msg, modelDefinition, keyFields, msg, msg, _a, deleted, model, modelConstructor, msg, modelDefinition, pkPredicate, msg, _b, _c, deleted;\n              return __generator(this, function (_d) {\n                switch (_d.label) {\n                  case 0:\n                    return [4 /*yield*/, this.start()];\n                  case 1:\n                    _d.sent();\n                    if (!modelOrConstructor) {\n                      msg = 'Model or Model Constructor required';\n                      logger.error(msg, {\n                        modelOrConstructor: modelOrConstructor\n                      });\n                      throw new Error(msg);\n                    }\n                    if (!isValidModelConstructor(modelOrConstructor)) return [3 /*break*/, 3];\n                    modelConstructor = modelOrConstructor;\n                    if (!identifierOrCriteria) {\n                      msg = 'Id to delete or criteria required. Do you want to delete all? Pass Predicates.ALL';\n                      logger.error(msg, {\n                        identifierOrCriteria: identifierOrCriteria\n                      });\n                      throw new Error(msg);\n                    }\n                    modelDefinition = getModelDefinition(modelConstructor);\n                    if (typeof identifierOrCriteria === 'string') {\n                      keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n                      if (keyFields.length > 1) {\n                        msg = errorMessages.deleteByPkWithCompositeKeyPresent;\n                        logger.error(msg, {\n                          keyFields: keyFields\n                        });\n                        throw new Error(msg);\n                      }\n                      condition = ModelPredicateCreator.createForSingleField(getModelDefinition(modelConstructor), keyFields[0], identifierOrCriteria);\n                    } else {\n                      if (isIdentifierObject(identifierOrCriteria, modelDefinition)) {\n                        condition = ModelPredicateCreator.createForPk(modelDefinition, identifierOrCriteria);\n                      } else {\n                        condition = ModelPredicateCreator.createFromExisting(modelDefinition,\n                        /**\n                         * idOrCriteria is always a ProducerModelPredicate<T>, never a symbol.\n                         * The symbol is used only for typing purposes. e.g. see Predicates.ALL\n                         */\n                        identifierOrCriteria);\n                      }\n                      if (!condition || !ModelPredicateCreator.isValidPredicate(condition)) {\n                        msg = 'Criteria required. Do you want to delete all? Pass Predicates.ALL';\n                        logger.error(msg, {\n                          condition: condition\n                        });\n                        throw new Error(msg);\n                      }\n                    }\n                    return [4 /*yield*/, this.storage.delete(modelConstructor, condition)];\n                  case 2:\n                    _a = __read.apply(void 0, [_d.sent(), 1]), deleted = _a[0];\n                    return [2 /*return*/, deleted];\n                  case 3:\n                    model = modelOrConstructor;\n                    modelConstructor = Object.getPrototypeOf(model || {}).constructor;\n                    if (!isValidModelConstructor(modelConstructor)) {\n                      msg = 'Object is not an instance of a valid model';\n                      logger.error(msg, {\n                        model: model\n                      });\n                      throw new Error(msg);\n                    }\n                    modelDefinition = getModelDefinition(modelConstructor);\n                    pkPredicate = ModelPredicateCreator.createForPk(modelDefinition, model);\n                    if (identifierOrCriteria) {\n                      if (typeof identifierOrCriteria !== 'function') {\n                        msg = 'Invalid criteria';\n                        logger.error(msg, {\n                          identifierOrCriteria: identifierOrCriteria\n                        });\n                        throw new Error(msg);\n                      }\n                      condition = identifierOrCriteria(pkPredicate);\n                    } else {\n                      condition = pkPredicate;\n                    }\n                    return [4 /*yield*/, this.storage.delete(model, condition)];\n                  case 4:\n                    _b = __read.apply(void 0, [_d.sent(), 1]), _c = __read(_b[0], 1), deleted = _c[0];\n                    return [2 /*return*/, deleted];\n                }\n              });\n            });\n          }, 'datastore delete').catch(this.handleAddProcError('DataStore.delete()'))];\n        });\n      });\n    };\n    this.observe = function (modelOrConstructor, identifierOrCriteria) {\n      var predicate;\n      var modelConstructor = modelOrConstructor && isValidModelConstructor(modelOrConstructor) ? modelOrConstructor : undefined;\n      if (modelOrConstructor && modelConstructor === undefined) {\n        var model = modelOrConstructor;\n        var modelConstructor_1 = model && Object.getPrototypeOf(model).constructor;\n        if (isValidModelConstructor(modelConstructor_1)) {\n          if (identifierOrCriteria) {\n            logger.warn('idOrCriteria is ignored when using a model instance', {\n              model: model,\n              identifierOrCriteria: identifierOrCriteria\n            });\n          }\n          return _this.observe(modelConstructor_1, model.id);\n        } else {\n          var msg = 'The model is not an instance of a PersistentModelConstructor';\n          logger.error(msg, {\n            model: model\n          });\n          throw new Error(msg);\n        }\n      }\n      // observe should not accept object literal syntax\n      if (identifierOrCriteria && modelConstructor && isIdentifierObject(identifierOrCriteria, getModelDefinition(modelConstructor))) {\n        var msg = errorMessages.observeWithObjectLiteral;\n        logger.error(msg, {\n          objectLiteral: identifierOrCriteria\n        });\n        throw new Error(msg);\n      }\n      if (identifierOrCriteria !== undefined && modelConstructor === undefined) {\n        var msg = 'Cannot provide criteria without a modelConstructor';\n        logger.error(msg, identifierOrCriteria);\n        throw new Error(msg);\n      }\n      if (modelConstructor && !isValidModelConstructor(modelConstructor)) {\n        var msg = 'Constructor is not for a valid model';\n        logger.error(msg, {\n          modelConstructor: modelConstructor\n        });\n        throw new Error(msg);\n      }\n      if (typeof identifierOrCriteria === 'string') {\n        var modelDefinition = getModelDefinition(modelConstructor);\n        var _a = __read(extractPrimaryKeyFieldNames(modelDefinition), 1),\n          keyField = _a[0];\n        predicate = ModelPredicateCreator.createForSingleField(getModelDefinition(modelConstructor), keyField, identifierOrCriteria);\n      } else {\n        if (isPredicatesAll(identifierOrCriteria)) {\n          predicate = undefined;\n        } else {\n          predicate = modelConstructor && ModelPredicateCreator.createFromExisting(getModelDefinition(modelConstructor), identifierOrCriteria);\n        }\n      }\n      return new Observable(function (observer) {\n        var handle;\n        _this.runningProcesses.add(function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  return [4 /*yield*/, this.start()];\n                case 1:\n                  _a.sent();\n                  // Filter the events returned by Storage according to namespace,\n                  // append original element data, and subscribe to the observable\n                  handle = this.storage.observe(modelConstructor, predicate).filter(function (_a) {\n                    var model = _a.model;\n                    return namespaceResolver(model) === USER;\n                  }).subscribe({\n                    next: function (item) {\n                      return _this.runningProcesses.isOpen && _this.runningProcesses.add(function () {\n                        return __awaiter(_this, void 0, void 0, function () {\n                          var message, modelDefinition, keyFields, primaryKeysAndValues, freshElement;\n                          return __generator(this, function (_a) {\n                            switch (_a.label) {\n                              case 0:\n                                message = item;\n                                if (!(item.opType !== 'DELETE')) return [3 /*break*/, 2];\n                                modelDefinition = getModelDefinition(item.model);\n                                keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n                                primaryKeysAndValues = extractPrimaryKeysAndValues(item.element, keyFields);\n                                return [4 /*yield*/, this.query(item.model, primaryKeysAndValues)];\n                              case 1:\n                                freshElement = _a.sent();\n                                message = __assign(__assign({}, message), {\n                                  element: freshElement\n                                });\n                                _a.label = 2;\n                              case 2:\n                                observer.next(message);\n                                return [2 /*return*/];\n                            }\n                          });\n                        });\n                      }, 'datastore observe message handler');\n                    },\n                    error: function (err) {\n                      return observer.error(err);\n                    },\n                    complete: function () {\n                      return observer.complete();\n                    }\n                  });\n                  return [2 /*return*/];\n              }\n            });\n          });\n        }, 'datastore observe observable initialization').catch(_this.handleAddProcError('DataStore.observe()')).catch(function (error) {\n          observer.error(error);\n        });\n        // better than no cleaner, but if the subscriber is handling the\n        // complete() message async and not registering with the context,\n        // this will still be problematic.\n        return _this.runningProcesses.addCleaner(function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n              if (handle) {\n                handle.unsubscribe();\n              }\n              return [2 /*return*/];\n            });\n          });\n        }, 'DataStore.observe() cleanup');\n      });\n    };\n    this.observeQuery = function (model, criteria, options) {\n      return new Observable(function (observer) {\n        var items = new Map();\n        var itemsChanged = new Map();\n        var deletedItemIds = [];\n        var handle;\n        var predicate;\n        /**\n         * As the name suggests, this geneates a snapshot in the form of\n         * \t`{items: T[], isSynced: boolean}`\n         * and sends it to the observer.\n         *\n         * SIDE EFFECT: The underlying generation and emission methods may touch:\n         * `items`, `itemsChanged`, and `deletedItemIds`.\n         *\n         * Refer to `generateSnapshot` and `emitSnapshot` for more details.\n         */\n        var generateAndEmitSnapshot = function () {\n          var snapshot = generateSnapshot();\n          emitSnapshot(snapshot);\n        };\n        // a mechanism to return data after X amount of seconds OR after the\n        // \"limit\" (itemsChanged >= this.syncPageSize) has been reached, whichever comes first\n        var limitTimerRace = new DeferredCallbackResolver({\n          callback: generateAndEmitSnapshot,\n          errorHandler: observer.error,\n          maxInterval: 2000\n        });\n        var sort = (options || {}).sort;\n        var sortOptions = sort ? {\n          sort: sort\n        } : undefined;\n        var modelDefinition = getModelDefinition(model);\n        var keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n        if (isQueryOne(criteria)) {\n          predicate = ModelPredicateCreator.createForSingleField(modelDefinition, keyFields[0], criteria);\n        } else {\n          if (isPredicatesAll(criteria)) {\n            // Predicates.ALL means \"all records\", so no predicate (undefined)\n            predicate = undefined;\n          } else {\n            predicate = ModelPredicateCreator.createFromExisting(modelDefinition, criteria);\n          }\n        }\n        var _a = ModelPredicateCreator.getPredicates(predicate, false) || {},\n          predicates = _a.predicates,\n          predicateGroupType = _a.type;\n        var hasPredicate = !!predicates;\n        _this.runningProcesses.add(function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            var err_1;\n            var _this = this;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  _a.trys.push([0, 2,, 3]);\n                  return [4 /*yield*/, this.query(model, criteria, sortOptions)];\n                case 1:\n                  // first, query and return any locally-available records\n                  _a.sent().forEach(function (item) {\n                    var itemModelDefinition = getModelDefinition(model);\n                    var idOrPk = getIdentifierValue(itemModelDefinition, item);\n                    items.set(idOrPk, item);\n                  });\n                  // Observe the model and send a stream of updates (debounced).\n                  // We need to post-filter results instead of passing criteria through\n                  // to have visibility into items that move from in-set to out-of-set.\n                  // We need to explicitly remove those items from the existing snapshot.\n                  handle = this.observe(model).subscribe(function (_a) {\n                    var element = _a.element,\n                      model = _a.model,\n                      opType = _a.opType;\n                    var _b, _c;\n                    var itemModelDefinition = getModelDefinition(model);\n                    var idOrPk = getIdentifierValue(itemModelDefinition, element);\n                    if (hasPredicate && !validatePredicate(element, predicateGroupType, predicates)) {\n                      if (opType === 'UPDATE' && (items.has(idOrPk) || itemsChanged.has(idOrPk))) {\n                        // tracking as a \"deleted item\" will include the item in\n                        // page limit calculations and ensure it is removed from the\n                        // final items collection, regardless of which collection(s)\n                        // it is currently in. (I mean, it could be in both, right!?)\n                        deletedItemIds.push(idOrPk);\n                      } else {\n                        // ignore updates for irrelevant/filtered items.\n                        return;\n                      }\n                    }\n                    // Flag items which have been recently deleted\n                    // NOTE: Merging of separate operations to the same model instance is handled upstream\n                    // in the `mergePage` method within src/sync/merger.ts. The final state of a model instance\n                    // depends on the LATEST record (for a given id).\n                    if (opType === 'DELETE') {\n                      deletedItemIds.push(idOrPk);\n                    } else {\n                      itemsChanged.set(idOrPk, element);\n                    }\n                    var isSynced = (_c = (_b = _this.sync) === null || _b === void 0 ? void 0 : _b.getModelSyncedStatus(model)) !== null && _c !== void 0 ? _c : false;\n                    var limit = itemsChanged.size - deletedItemIds.length >= _this.syncPageSize;\n                    if (limit || isSynced) {\n                      limitTimerRace.resolve();\n                    }\n                    // kicks off every subsequent race as results sync down\n                    limitTimerRace.start();\n                  });\n                  // returns a set of initial/locally-available results\n                  generateAndEmitSnapshot();\n                  return [3 /*break*/, 3];\n                case 2:\n                  err_1 = _a.sent();\n                  observer.error(err_1);\n                  return [3 /*break*/, 3];\n                case 3:\n                  return [2 /*return*/];\n              }\n            });\n          });\n        }, 'datastore observequery startup').catch(_this.handleAddProcError('DataStore.observeQuery()')).catch(function (error) {\n          observer.error(error);\n        });\n        /**\n         * Combines the `items`, `itemsChanged`, and `deletedItemIds` collections into\n         * a snapshot in the form of `{ items: T[], isSynced: boolean}`.\n         *\n         * SIDE EFFECT: The shared `items` collection is recreated.\n         */\n        var generateSnapshot = function () {\n          var _a, _b;\n          var isSynced = (_b = (_a = _this.sync) === null || _a === void 0 ? void 0 : _a.getModelSyncedStatus(model)) !== null && _b !== void 0 ? _b : false;\n          var itemsArray = __spread(Array.from(items.values()), Array.from(itemsChanged.values()));\n          if (options === null || options === void 0 ? void 0 : options.sort) {\n            sortItems(itemsArray);\n          }\n          items.clear();\n          itemsArray.forEach(function (item) {\n            var itemModelDefinition = getModelDefinition(model);\n            var idOrPk = getIdentifierValue(itemModelDefinition, item);\n            items.set(idOrPk, item);\n          });\n          // remove deleted items from the final result set\n          deletedItemIds.forEach(function (idOrPk) {\n            return items.delete(idOrPk);\n          });\n          return {\n            items: Array.from(items.values()),\n            isSynced: isSynced\n          };\n        };\n        /**\n         * Emits the list of items to the observer.\n         *\n         * SIDE EFFECT: `itemsChanged` and `deletedItemIds` are cleared to prepare\n         * for the next snapshot.\n         *\n         * @param snapshot The generated items data to emit.\n         */\n        var emitSnapshot = function (snapshot) {\n          // send the generated snapshot to the primary subscription.\n          // NOTE: This observer's handler *could* be async ...\n          observer.next(snapshot);\n          // reset the changed items sets\n          itemsChanged.clear();\n          deletedItemIds = [];\n        };\n        /**\n         * Sorts an `Array` of `T` according to the sort instructions given in the\n         * original  `observeQuery()` call.\n         *\n         * @param itemsToSort A array of model type.\n         */\n        var sortItems = function (itemsToSort) {\n          var modelDefinition = getModelDefinition(model);\n          var pagination = _this.processPagination(modelDefinition, options);\n          var sortPredicates = ModelSortPredicateCreator.getPredicates(pagination.sort);\n          if (sortPredicates.length) {\n            var compareFn = sortCompareFunction(sortPredicates);\n            itemsToSort.sort(compareFn);\n          }\n        };\n        /**\n         * Force one last snapshot when the model is fully synced.\n         *\n         * This reduces latency for that last snapshot, which will otherwise\n         * wait for the configured timeout.\n         *\n         * @param payload The payload from the Hub event.\n         */\n        var hubCallback = function (_a) {\n          var payload = _a.payload;\n          var _b;\n          var event = payload.event,\n            data = payload.data;\n          if (event === ControlMessage.SYNC_ENGINE_MODEL_SYNCED && ((_b = data === null || data === void 0 ? void 0 : data.model) === null || _b === void 0 ? void 0 : _b.name) === model.name) {\n            generateAndEmitSnapshot();\n            Hub.remove('datastore', hubCallback);\n          }\n        };\n        Hub.listen('datastore', hubCallback);\n        return _this.runningProcesses.addCleaner(function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n              if (handle) {\n                handle.unsubscribe();\n              }\n              return [2 /*return*/];\n            });\n          });\n        }, 'datastore observequery cleaner');\n      });\n    };\n    this.configure = function (config) {\n      if (config === void 0) {\n        config = {};\n      }\n      _this.amplifyContext.Auth = _this.Auth;\n      _this.amplifyContext.API = _this.API;\n      _this.amplifyContext.Cache = _this.Cache;\n      var configDataStore = config.DataStore,\n        configAuthModeStrategyType = config.authModeStrategyType,\n        configConflictHandler = config.conflictHandler,\n        configErrorHandler = config.errorHandler,\n        configMaxRecordsToSync = config.maxRecordsToSync,\n        configSyncPageSize = config.syncPageSize,\n        configFullSyncInterval = config.fullSyncInterval,\n        configSyncExpressions = config.syncExpressions,\n        configAuthProviders = config.authProviders,\n        configStorageAdapter = config.storageAdapter,\n        configFromAmplify = __rest(config, [\"DataStore\", \"authModeStrategyType\", \"conflictHandler\", \"errorHandler\", \"maxRecordsToSync\", \"syncPageSize\", \"fullSyncInterval\", \"syncExpressions\", \"authProviders\", \"storageAdapter\"]);\n      _this.amplifyConfig = __assign(__assign({}, configFromAmplify), _this.amplifyConfig);\n      _this.conflictHandler = _this.setConflictHandler(config);\n      _this.errorHandler = _this.setErrorHandler(config);\n      var authModeStrategyType = configDataStore && configDataStore.authModeStrategyType || configAuthModeStrategyType || AuthModeStrategyType.DEFAULT;\n      switch (authModeStrategyType) {\n        case AuthModeStrategyType.MULTI_AUTH:\n          _this.authModeStrategy = multiAuthStrategy(_this.amplifyContext);\n          break;\n        case AuthModeStrategyType.DEFAULT:\n          _this.authModeStrategy = defaultAuthStrategy;\n          break;\n        default:\n          _this.authModeStrategy = defaultAuthStrategy;\n          break;\n      }\n      // store on config object, so that Sync, Subscription, and Mutation processors can have access\n      _this.amplifyConfig.authProviders = configDataStore && configDataStore.authProviders || configAuthProviders;\n      _this.syncExpressions = configDataStore && configDataStore.syncExpressions || configSyncExpressions || _this.syncExpressions;\n      _this.maxRecordsToSync = configDataStore && configDataStore.maxRecordsToSync || configMaxRecordsToSync || _this.maxRecordsToSync || 10000;\n      // store on config object, so that Sync, Subscription, and Mutation processors can have access\n      _this.amplifyConfig.maxRecordsToSync = _this.maxRecordsToSync;\n      _this.syncPageSize = configDataStore && configDataStore.syncPageSize || configSyncPageSize || _this.syncPageSize || 1000;\n      // store on config object, so that Sync, Subscription, and Mutation processors can have access\n      _this.amplifyConfig.syncPageSize = _this.syncPageSize;\n      _this.fullSyncInterval = configDataStore && configDataStore.fullSyncInterval || configFullSyncInterval || _this.fullSyncInterval || 24 * 60; // 1 day\n      _this.storageAdapter = configDataStore && configDataStore.storageAdapter || configStorageAdapter || _this.storageAdapter || undefined;\n      _this.sessionId = _this.retrieveSessionId();\n    };\n  }\n  DataStore.prototype.getModuleName = function () {\n    return 'DataStore';\n  };\n  /**\n   * Builds a function to capture `BackgroundManagerNotOpenError`'s to produce friendlier,\n   * more instructive errors for customers.\n   *\n   * @param operation The name of the operation (usually a Datastore method) the customer\n   * tried to call.\n   */\n  DataStore.prototype.handleAddProcError = function (operation) {\n    var _this = this;\n    /**\n     * If the tested error is a `BackgroundManagerNotOpenError`, it will be captured\n     * and replaced with a friendlier message that instructs the App Developer.\n     *\n     * @param err An error to test.\n     */\n    var handler = function (err) {\n      if (err.message.startsWith('BackgroundManagerNotOpenError')) {\n        throw new Error([\"DataStoreStateError: Tried to execute `\" + operation + \"` while DataStore was \\\"\" + _this.state + \"\\\".\", \"This can only be done while DataStore is \\\"Started\\\" or \\\"Stopped\\\". To remedy:\", 'Ensure all calls to `stop()` and `clear()` have completed first.', 'If this is not possible, retry the operation until it succeeds.'].join('\\n'));\n      } else {\n        throw err;\n      }\n    };\n    return handler;\n  };\n  /**\n   * Clears all data from storage and removes all data, schema info, other\n   * initialization details, and then stops DataStore.\n   *\n   * That said, reinitialization is required after clearing. This can be done\n   * by explicitiliy calling `start()` or any method that implicitly starts\n   * DataStore, such as `query()`, `save()`, or `delete()`.\n   */\n  DataStore.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            checkSchemaInitialized();\n            this.state = DataStoreState.Clearing;\n            return [4 /*yield*/, this.runningProcesses.close()];\n          case 1:\n            _a.sent();\n            if (!(this.storage === undefined)) return [3 /*break*/, 3];\n            // connect to storage so that it can be cleared without fully starting DataStore\n            this.storage = new Storage(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, this.storageAdapter, this.sessionId);\n            return [4 /*yield*/, this.storage.init()];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            if (syncSubscription && !syncSubscription.closed) {\n              syncSubscription.unsubscribe();\n            }\n            if (!this.sync) return [3 /*break*/, 5];\n            return [4 /*yield*/, this.sync.stop()];\n          case 4:\n            _a.sent();\n            _a.label = 5;\n          case 5:\n            return [4 /*yield*/, this.storage.clear()];\n          case 6:\n            _a.sent();\n            this.initialized = undefined; // Should re-initialize when start() is called.\n            this.storage = undefined;\n            this.sync = undefined;\n            this.syncPredicates = new WeakMap();\n            return [4 /*yield*/, this.runningProcesses.open()];\n          case 7:\n            _a.sent();\n            this.state = DataStoreState.NotRunning;\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Stops all DataStore sync activities.\n   *\n   * TODO: \"Waits for graceful termination of\n   * running queries and terminates subscriptions.\"\n   */\n  DataStore.prototype.stop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.state = DataStoreState.Stopping;\n            return [4 /*yield*/, this.runningProcesses.close()];\n          case 1:\n            _a.sent();\n            if (syncSubscription && !syncSubscription.closed) {\n              syncSubscription.unsubscribe();\n            }\n            if (!this.sync) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.sync.stop()];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            this.initialized = undefined; // Should re-initialize when start() is called.\n            this.sync = undefined;\n            return [4 /*yield*/, this.runningProcesses.open()];\n          case 4:\n            _a.sent();\n            this.state = DataStoreState.NotRunning;\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Validates given pagination input from a query and creates a pagination\n   * argument for use against the storage layer.\n   *\n   * @param modelDefinition\n   * @param paginationProducer\n   */\n  DataStore.prototype.processPagination = function (modelDefinition, paginationProducer) {\n    var sortPredicate;\n    var _a = paginationProducer || {},\n      limit = _a.limit,\n      page = _a.page,\n      sort = _a.sort;\n    if (limit === undefined && page === undefined && sort === undefined) {\n      return undefined;\n    }\n    if (page !== undefined && limit === undefined) {\n      throw new Error('Limit is required when requesting a page');\n    }\n    if (page !== undefined) {\n      if (typeof page !== 'number') {\n        throw new Error('Page should be a number');\n      }\n      if (page < 0) {\n        throw new Error(\"Page can't be negative\");\n      }\n    }\n    if (limit !== undefined) {\n      if (typeof limit !== 'number') {\n        throw new Error('Limit should be a number');\n      }\n      if (limit < 0) {\n        throw new Error(\"Limit can't be negative\");\n      }\n    }\n    if (sort) {\n      sortPredicate = ModelSortPredicateCreator.createFromExisting(modelDefinition, paginationProducer.sort);\n    }\n    return {\n      limit: limit,\n      page: page,\n      sort: sortPredicate\n    };\n  };\n  /**\n   * Examines the configured `syncExpressions` and produces a WeakMap of\n   * SchemaModel -> predicate to use during sync.\n   */\n  DataStore.prototype.processSyncExpressions = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var syncPredicates;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.syncExpressions || !this.syncExpressions.length) {\n              return [2 /*return*/, new WeakMap()];\n            }\n            return [4 /*yield*/, Promise.all(this.syncExpressions.map(function (syncExpression) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var _a, modelConstructor, conditionProducer, modelDefinition, condition, predicate;\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      return [4 /*yield*/, syncExpression];\n                    case 1:\n                      _a = _b.sent(), modelConstructor = _a.modelConstructor, conditionProducer = _a.conditionProducer;\n                      modelDefinition = getModelDefinition(modelConstructor);\n                      return [4 /*yield*/, this.unwrapPromise(conditionProducer)];\n                    case 2:\n                      condition = _b.sent();\n                      if (isPredicatesAll(condition)) {\n                        return [2 /*return*/, [modelDefinition, null]];\n                      }\n                      predicate = this.createFromCondition(modelDefinition, condition);\n                      return [2 /*return*/, [modelDefinition, predicate]];\n                  }\n                });\n              });\n            }))];\n          case 1:\n            syncPredicates = _a.sent();\n            return [2 /*return*/, this.weakMapFromEntries(syncPredicates)];\n        }\n      });\n    });\n  };\n  DataStore.prototype.createFromCondition = function (modelDefinition, condition) {\n    try {\n      return ModelPredicateCreator.createFromExisting(modelDefinition, condition);\n    } catch (error) {\n      logger.error('Error creating Sync Predicate');\n      throw error;\n    }\n  };\n  DataStore.prototype.unwrapPromise = function (conditionProducer) {\n    return __awaiter(this, void 0, void 0, function () {\n      var condition, error_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n            return [4 /*yield*/, conditionProducer()];\n          case 1:\n            condition = _a.sent();\n            return [2 /*return*/, condition];\n          case 2:\n            error_1 = _a.sent();\n            if (error_1 instanceof TypeError) {\n              return [2 /*return*/, conditionProducer];\n            }\n            throw error_1;\n          case 3:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  DataStore.prototype.weakMapFromEntries = function (entries) {\n    return entries.reduce(function (map, _a) {\n      var _b = __read(_a, 2),\n        modelDefinition = _b[0],\n        predicate = _b[1];\n      if (map.has(modelDefinition)) {\n        var name_2 = modelDefinition.name;\n        logger.warn(\"You can only utilize one Sync Expression per model.\\n          Subsequent sync expressions for the \" + name_2 + \" model will be ignored.\");\n        return map;\n      }\n      if (predicate) {\n        map.set(modelDefinition, predicate);\n      }\n      return map;\n    }, new WeakMap());\n  };\n  /**\n   * A session ID to allow CMS to open databases against multiple apps.\n   * This session ID is only expected be set by AWS Amplify Studio.\n   */\n  DataStore.prototype.retrieveSessionId = function () {\n    try {\n      var sessionId = sessionStorage.getItem('datastoreSessionId');\n      if (sessionId) {\n        var aws_appsync_graphqlEndpoint = this.amplifyConfig.aws_appsync_graphqlEndpoint;\n        var appSyncUrl = aws_appsync_graphqlEndpoint.split('/')[2];\n        var _a = __read(appSyncUrl.split('.'), 1),\n          appSyncId = _a[0];\n        return sessionId + \"-\" + appSyncId;\n      }\n    } catch (_b) {}\n    return undefined;\n  };\n  return DataStore;\n}();\nvar instance = new DataStore();\nAmplify.register(instance);\nexport { DataStore as DataStoreClass, initSchema, instance as DataStore };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,GAAG,MAAM,kBAAkB;AAClC,SAASC,IAAI,QAAQ,mBAAmB;AACxC,OAAOC,KAAK,MAAM,oBAAoB;AACtC,SACCC,OAAO,EACPC,aAAa,IAAIC,MAAM,EACvBC,GAAG,EACHC,EAAE,EACFC,wBAAwB,QAClB,mBAAmB;AAC1B,SAECC,SAAS,EACTC,OAAO,EACPC,aAAa,EACbC,aAAa,QAEP,OAAO;AACd,SAASC,EAAE,IAAIC,KAAK,QAAQ,MAAM;AAClC,OAAOC,UAA6B,MAAM,mBAAmB;AAC7D,SAASC,mBAAmB,EAAEC,iBAAiB,QAAQ,uBAAuB;AAC9E,SACCC,eAAe,EACfC,qBAAqB,EACrBC,yBAAyB,QAEnB,eAAe;AAEtB,SAASC,gBAAgB,IAAIC,OAAO,QAAQ,oBAAoB;AAChE,SAASC,cAAc,EAAEC,UAAU,QAAQ,SAAS;AACpD,SAICC,iBAAiB,EAEjBC,mBAAmB,EACnBC,2BAA2B,EAyB3BC,oBAAoB,EACpBC,mBAAmB,EACnBC,gBAAgB,EAKhBC,kBAAkB,QAEZ,UAAU;AAIjB,SACCC,SAAS,EACTC,aAAa,EACbC,wBAAwB,EACxBC,eAAe,EACfC,kBAAkB,EAClBC,oBAAoB,EAEpBC,OAAO,EACPC,IAAI,EACJC,IAAI,EACJC,iBAAiB,EACjBC,qBAAqB,EACrBC,mBAAmB,EACnBC,wBAAwB,EACxBC,2BAA2B,EAC3BC,2BAA2B,EAC3BC,WAAW,EACXC,qBAAqB,EACrBC,iBAAiB,EACjBC,YAAY,QACN,SAAS;AAChB,SAASC,kBAAkB,QAAQ,eAAe;AAGlDxC,aAAa,CAAC,IAAI,CAAC;AACnBC,aAAa,EAAE;AAEf,IAAMwC,MAAM,GAAG,IAAI/C,MAAM,CAAC,WAAW,CAAC;AAEtC,IAAMgD,IAAI,GAAGhB,oBAAoB,CAACiB,IAAI,CAACC,GAAG,EAAE,CAAC;AACrC,sCAAM;AAkBd,IAAMC,sBAAsB,GAAG,eAAe;AAE9C,IAAIC,MAAsB;AAC1B,IAAMC,iBAAiB,GAAG,IAAIC,OAAO,EAGlC;AACH;AACA;AACA;AACA,IAAMC,eAAe,GAAG,IAAID,OAAO,EAGhC;AAEH,IAAME,kBAAkB,GAAG,UAC1BC,gBAAiD;EAEjD,IAAMC,SAAS,GAAGL,iBAAiB,CAACM,GAAG,CAACF,gBAAgB,CAAC;EAEzD,OAAOL,MAAM,CAACQ,UAAU,CAACF,SAAS,CAAC,CAACG,MAAM,CAACJ,gBAAgB,CAACK,IAAI,CAAC;AAClE,CAAC;AAED,IAAMC,uBAAuB,GAAG,UAC/BC,GAAQ;EAER,OAAOjC,kBAAkB,CAACiC,GAAG,CAAC,IAAIX,iBAAiB,CAACY,GAAG,CAACD,GAAG,CAAC;AAC7D,CAAC;AAED,IAAME,iBAAiB,GAAsB,0BAAgB;EAC5D,wBAAiB,CAACP,GAAG,CAACF,gBAAgB,CAAC;AAAvC,CAAuC;AAExC;AACA,OAAO,IAAIU,WAA+B;AAC1C,IAAIC,WAA+B;AACnC,IAAIC,gBAAoC;AACxC,IAAIC,cAAkC;AAEtC,IAAMC,UAAU,GAAG,UAACC,UAAkB;;EACrC,IAAIpB,MAAM,KAAKqB,SAAS,EAAE;IACzBC,OAAO,CAACC,IAAI,CAAC,yCAAyC,CAAC;IAEvD,OAAOP,WAAW;;EAGnBrB,MAAM,CAAC6B,GAAG,CAAC,mBAAmB,EAAE;IAAExB,MAAM,EAAEoB;EAAU,CAAE,CAAC;EAEvD,IAAMK,qBAAqB;IAC1Bf,IAAI,EAAE3B;EAAI,GACPqC,UAAU,CACb;EAEDzB,MAAM,CAAC6B,GAAG,CAAC,WAAW,EAAE,aAAa,CAAC;EACtCR,WAAW,GAAGU,iBAAiB,CAACD,qBAAqB,CAAC;EACtD9B,MAAM,CAAC6B,GAAG,CAAC,WAAW,EAAE,oBAAoB,CAAC;EAE7C,IAAMG,kBAAkB,GAAGC,YAAY,EAAE;EACzC,IAAMC,gBAAgB,GAAGhE,OAAO,CAAC+D,YAAY,EAAE;EAC/C,IAAME,aAAa,GAAG/D,UAAU,CAAC6D,YAAY,EAAE;EAE/CX,gBAAgB,GAAGS,iBAAiB,CAACC,kBAAkB,CAAC;EACxDT,cAAc,GAAGQ,iBAAiB,CAACG,gBAAgB,CAAC;EACpDd,WAAW,GAAGW,iBAAiB,CAACI,aAAa,CAAC;EAE9C9B,MAAM,GAAG;IACRQ,UAAU,YACTuB,GAACJ,kBAAkB,CAACjB,IAAI,IAAGiB,kBAAkB,EAC7CI,GAACN,qBAAqB,CAACf,IAAI,IAAGe,qBAAqB,EACnDM,GAACF,gBAAgB,CAACnB,IAAI,IAAGmB,gBAAgB,EACzCE,GAACD,aAAa,CAACpB,IAAI,IAAGoB,aAAa,KACnC;IACDE,OAAO,EAAEZ,UAAU,CAACY;GACpB;EAEDC,MAAM,CAACC,IAAI,CAAClC,MAAM,CAACQ,UAAU,CAAC,CAAC2B,OAAO,CAAC,mBAAS;;IACzC,0EAEL;MAFMC,iBAAS;MAAEF,YAEjB;IAEDlC,MAAM,CAACQ,UAAU,CAACF,SAAS,CAAC,CAAC+B,aAAa,GAAGD,SAAS;IACtDpC,MAAM,CAACQ,UAAU,CAACF,SAAS,CAAC,CAAC4B,IAAI,GAAGA,IAAI;IAExC,IAAMI,iBAAiB,GAAG,IAAIC,GAAG,EAAoB;IAErDN,MAAM,CAACO,MAAM,CAACxC,MAAM,CAACQ,UAAU,CAACF,SAAS,CAAC,CAACG,MAAM,CAAC,CAAC0B,OAAO,CAAC,eAAK;MAC/D,IAAMM,eAAe,GAAa,EAAE;MAEpCR,MAAM,CAACO,MAAM,CAACE,KAAK,CAACC,MAAM,CAAC,CACzBC,MAAM,CACN,eAAK;QACJ,YAAK,CAACC,WAAW,IACjBC,KAAK,CAACD,WAAW,CAACE,cAAc,KAAK,YAAY,IAChCD,KAAK,CAACE,IAAK,CAACN,KAAK,KAAKA,KAAK,CAAChC,IAAI;MAFjD,CAEiD,CAClD,CACAyB,OAAO,CAAC,eAAK;QACb,sBAAe,CAACc,IAAI,CAAkBH,KAAK,CAACE,IAAK,CAACN,KAAK,CAAC;MAAxD,CAAwD,CACxD;MAEFJ,iBAAiB,CAACY,GAAG,CAACR,KAAK,CAAChC,IAAI,EAAE+B,eAAe,CAAC;IACnD,CAAC,CAAC;IAEF,IAAMU,MAAM,GAAG,IAAIZ,GAAG,EAAoB;IAE1C,IAAIa,KAAK,GAAG,IAAI;IAChB,OAAO,IAAI,IAAIA,KAAK,GAAG,CAAC,EAAE;MACzB,IAAId,iBAAiB,CAACe,IAAI,KAAK,CAAC,EAAE;QACjC;;MAEDD,KAAK,EAAE;MACP,IAAIA,KAAK,KAAK,CAAC,EAAE;QAChB,MAAM,IAAIE,KAAK,CACd,mEAAmE,CACnE;;;QAGF,KAAwB,sCAAK,CAACC,IAAI,CAACjB,iBAAiB,CAACJ,IAAI,EAAE,CAAC,8CAAE;UAAzD,IAAMsB,SAAS;UACnB,IAAMC,OAAO,GAAGnB,iBAAiB,CAAC/B,GAAG,CAACiD,SAAS,CAAC;UAEhD,IAAIC,OAAO,CAACC,KAAK,CAAC,WAAC;YAAI,aAAM,CAAC7C,GAAG,CAAC8C,CAAC,CAAC;UAAb,CAAa,CAAC,EAAE;YACtCR,MAAM,CAACD,GAAG,CAACM,SAAS,EAAEC,OAAO,CAAC;;;;;;;;;;;;;;MAIhCG,KAAK,CAACL,IAAI,CAACJ,MAAM,CAACjB,IAAI,EAAE,CAAC,CAACC,OAAO,CAAC,WAAC;QAAI,wBAAiB,CAAC0B,MAAM,CAACF,CAAC,CAAC;MAA3B,CAA2B,CAAC;;IAGpE3D,MAAM,CAACQ,UAAU,CAACF,SAAS,CAAC,CAACwD,wBAAwB,GAAGX,MAAM;EAC/D,CAAC,CAAC;EAEF,OAAOnC,WAAW;AACnB,CAAC;AAED;;;;;;;;;AASA,IAAM+C,sBAAsB,GAAG;EAC9B,IAAI/D,MAAM,KAAKqB,SAAS,EAAE;IACzB,IAAM2C,OAAO,GACZ,2PAA2P;IAC5PrE,MAAM,CAACsE,KAAK,CAACD,OAAO,CAAC;IACrB,MAAM,IAAIV,KAAK,CAACU,OAAO,CAAC;;AAE1B,CAAC;AAED,IAAMtC,iBAAiB,GAEG,mBAAS;EAClC,IAAMwC,OAAO,GAAuB,EAAE;EAEtCjC,MAAM,CAACkC,OAAO,CAAC7D,SAAS,CAACG,MAAM,CAAC,CAAC0B,OAAO,CAAC,UAACJ,EAA4B;QAA5BqC,kBAA4B;MAA3BZ,iBAAS;MAAEa,uBAAe;IACpE,IAAMC,KAAK,GAAGC,gBAAgB,CAACF,eAAe,CAAC;IAC/CH,OAAO,CAACV,SAAS,CAAC,GAAGc,KAAK;IAE1BrE,iBAAiB,CAACiD,GAAG,CAACoB,KAAK,EAAEhE,SAAS,CAACI,IAAI,CAAC;EAC7C,CAAC,CAAC;EAEFuB,MAAM,CAACkC,OAAO,CAAC7D,SAAS,CAACkE,SAAS,IAAI,EAAE,CAAC,CAACrC,OAAO,CAChD,UAACJ,EAA0B;QAA1BqC,kBAA0B;MAAzBK,gBAAQ;MAAEC,sBAAc;IACzB,IAAMJ,KAAK,GAAGK,mBAAmB,CAACD,cAAc,CAAC;IACjDR,OAAO,CAACO,QAAQ,CAAC,GAAGH,KAAK;EAC1B,CAAC,CACD;EAED,OAAOJ,OAAO;AACf,CAAC;AAaD;;;;;AAKA,IAAMU,iBAAiB,GAAG,IAAIC,OAAO,EAA+B;AAEpE,SAASC,oBAAoB,CAC5BzE,gBAA+C,EAC/C0E,IAAgB;EAEhBH,iBAAiB,CAACI,GAAG,CAACD,IAAI,CAAC;EAE3B,OAAO,IAAI1E,gBAAgB,CAA2C0E,IAAI,CAAC;AAC5E;AAEA,IAAME,mBAAmB,GACxB,UAACZ,eAA6C;EAAK,iBAACa,CAAS,EAAEC,CAAM;IACpE,IAAMC,eAAe,GAAGf,eAAe,CAAC1B,MAAM,CAACuC,CAAC,CAAC;IAEjD,IAAIE,eAAe,KAAK/D,SAAS,EAAE;MAC1B,iCAAI;QAAEgE,yCAAU;QAAEC,iDAAe;QAAEC,6BAAI;QAAEC,iCAAO;MAGxD,IACC,CAAE,CAACA,OAAO,IAAIH,YAAU,IAAMG,OAAO,IAAI,CAACF,eAAgB,MACzDH,CAAC,KAAK,IAAI,IAAIA,CAAC,KAAK9D,SAAS,CAAC,EAC9B;QACD,MAAM,IAAIiC,KAAK,CAAC,WAASiC,MAAI,iBAAc,CAAC;;MAG7C,IACCrH,2BAA2B,CAACmG,eAAe,CAAC,IAC5C,CAAC/E,WAAW,CAAC+E,eAAe,CAAC,EAC5B;QACD,IAAMnC,IAAI,GAAG9C,2BAA2B,CAACiF,eAAe,CAAC;QACzD,IAAInC,IAAI,CAACuD,QAAQ,CAACP,CAAC,CAAC,IAAIC,CAAC,KAAK,EAAE,EAAE;UACjCxF,MAAM,CAACsE,KAAK,CAACzF,aAAa,CAACkH,aAAa,EAAE;YAAER,CAAC;YAAES,KAAK,EAAER;UAAC,CAAE,CAAC;UAC1D,MAAM,IAAI7B,KAAK,CAAC9E,aAAa,CAACkH,aAAa,CAAC;;;MAI9C,IAAIzH,mBAAmB,CAAC2H,MAAI,CAAC,EAAE;QAC9B,IAAMC,QAAM,GAAG7H,iBAAiB,CAAC8H,SAAS,CAACF,MAAI,CAAC;QAChD,IAAMG,gBAAc,GAAG/H,iBAAiB,CAACgI,qBAAqB,CAACJ,MAAI,CAAC;QAEpE,IAAIA,MAAI,KAAK,SAAS,EAAE;UACvB,IAAI,OAAOT,CAAC,KAAKU,QAAM,EAAE;YACxB;;UAED,IAAI,OAAOV,CAAC,KAAK,QAAQ,EAAE;YAC1B,IAAI;cACHc,IAAI,CAACC,KAAK,CAACf,CAAC,CAAC;cACb;aACA,CAAC,OAAOlB,KAAK,EAAE;cACf,MAAM,IAAIX,KAAK,CAAC,WAASiC,MAAI,oCAA+BJ,CAAG,CAAC;;;;QAKnE,IAAIK,OAAO,EAAE;UACZ,IAAIW,aAAa,GAAWN,QAAM;UAClC,IAAI,CAACR,YAAU,EAAE;YAChBc,aAAa,GAAMN,QAAM,wBAAqB;;UAG/C,IAAI,CAACjC,KAAK,CAAC4B,OAAO,CAACL,CAAC,CAAC,IAAI,CAACG,eAAe,EAAE;YAC1C,MAAM,IAAIhC,KAAK,CACd,WAASiC,MAAI,4BAAuBY,aAAa,WAAM,OAAOhB,CAAC,mBAAcA,CAAG,CAChF;;UAGF,IACC,CAACnG,iBAAiB,CAACmG,CAAC,CAAC,IAChBA,CAAE,CAACiB,IAAI,CAAC,WAAC;YACb,wBAAiB,CAACC,CAAC,CAAC,GAAGhB,YAAU,GAAG,OAAOgB,CAAC,KAAKR,QAAM;UAAvD,CAAuD,CACvD,EACA;YACD,IAAMS,SAAS,GAAQnB,CAAE,CACvBoB,GAAG,CAAC,WAAC;cAAI,OAACF,CAAC,KAAK,IAAI,GAAG,MAAM,GAAG,OAAOA,CAAC;YAA/B,CAAgC,CAAC,CAC1CG,IAAI,CAAC,GAAG,CAAC;YAEX,MAAM,IAAIlD,KAAK,CACd,yBAAuBiC,MAAI,iCAA4BY,aAAa,WAAMG,SAAS,oBAAenB,CAAG,CACrG;;UAGF,IAAIY,gBAAc,IAAI,CAAC/G,iBAAiB,CAACmG,CAAC,CAAC,EAAE;YAC5C,IAAMsB,gBAAgB,GAAQtB,CAAE,CAACoB,GAAG,CAAC,WAAC;cACrC,IAAI,CAACvH,iBAAiB,CAACqH,CAAC,CAAC,EAAE;gBAC1B,OAAON,gBAAc,CAACM,CAAC,CAAC;eACxB,MAAM,IAAIrH,iBAAiB,CAACqH,CAAC,CAAC,IAAI,CAAChB,YAAU,EAAE;gBAC/C,OAAO,IAAI;eACX,MAAM;gBACN,OAAO,KAAK;;YAEd,CAAC,CAAC;YAEF,IAAI,CAACoB,gBAAgB,CAAC/C,KAAK,CAAC,WAAC;cAAI,QAAC;YAAD,CAAC,CAAC,EAAE;cACpC,MAAM,IAAIJ,KAAK,CACd,yBAAuBiC,MAAI,iCAA4BK,MAAI,sDAAiDT,CAAG,CAC/G;;;SAGH,MAAM,IAAI,CAACE,YAAU,IAAIF,CAAC,KAAK9D,SAAS,EAAE;UAC1C;SACA,MAAM,IAAI,OAAO8D,CAAC,KAAKU,QAAM,IAAIV,CAAC,KAAK,IAAI,EAAE;UAC7C,MAAM,IAAI7B,KAAK,CACd,WAASiC,MAAI,2BAAsBM,QAAM,UAAK,OAAOV,CAAC,mBAAcA,CAAG,CACvE;SACD,MAAM,IACN,CAACnG,iBAAiB,CAACmG,CAAC,CAAC,IACrBY,gBAAc,IACd,CAACA,gBAAc,CAACZ,CAAC,CAAC,EACjB;UACD,MAAM,IAAI7B,KAAK,CACd,WAASiC,MAAI,2BAAsBK,MAAI,6BAAwBT,CAAG,CAClE;;OAEF,MAAM,IAAI/G,mBAAmB,CAACwH,MAAI,CAAC,EAAE;QACrC;QACA,IAAI,CAAC5G,iBAAiB,CAACmG,CAAC,CAAC,EAAE;UAC1B,IAAMuB,uBAAqB,GAC1B1G,MAAM,CAACQ,UAAU,CAACmG,IAAI,CAACnC,SAAS,CAACoB,MAAI,CAACgB,QAAQ,CAAC;UAChD,IAAMC,gBAAc,GAAG5B,mBAAmB,CAACyB,uBAAqB,CAAC;UAEjE,IAAIlB,OAAO,EAAE;YACZ,IAAIW,aAAa,GAAWP,MAAI,CAACgB,QAAQ;YACzC,IAAI,CAACvB,YAAU,EAAE;cAChBc,aAAa,GAAMP,MAAI,CAACgB,QAAQ,wBAAqB;;YAEtD,IAAI,CAAChD,KAAK,CAAC4B,OAAO,CAACL,CAAC,CAAC,EAAE;cACtB,MAAM,IAAI7B,KAAK,CACd,WAASiC,MAAI,4BAAuBY,aAAa,WAAM,OAAOhB,CAAC,mBAAcA,CAAG,CAChF;;YAGFA,CAAC,CAAChD,OAAO,CAAC,cAAI;cACb,IACEnD,iBAAiB,CAAC8H,IAAI,CAAC,IAAIzB,YAAU,IACrC,OAAOyB,IAAI,KAAK,QAAQ,IAAI,OAAOA,IAAI,KAAK,WAAY,EACxD;gBACD,MAAM,IAAIxD,KAAK,CACd,yBAAuBiC,MAAI,iCAC1BK,MAAI,CAACgB,QAAQ,WACR,OAAOE,IAAI,oBAAeA,IAAM,CACtC;;cAGF,IAAI,CAAC9H,iBAAiB,CAAC8H,IAAI,CAAC,EAAE;gBAC7B7E,MAAM,CAACC,IAAI,CAACwE,uBAAqB,CAAC/D,MAAM,CAAC,CAACR,OAAO,CAAC,gBAAM;kBACvD0E,gBAAc,CAACE,MAAM,EAAED,IAAI,CAACC,MAAM,CAAC,CAAC;gBACrC,CAAC,CAAC;;YAEJ,CAAC,CAAC;WACF,MAAM;YACN,IAAI,OAAO5B,CAAC,KAAK,QAAQ,EAAE;cAC1B,MAAM,IAAI7B,KAAK,CACd,WAASiC,MAAI,2BACZK,MAAI,CAACgB,QAAQ,UACT,OAAOzB,CAAC,mBAAcA,CAAG,CAC9B;;YAGFlD,MAAM,CAACC,IAAI,CAACwE,uBAAqB,CAAC/D,MAAM,CAAC,CAACR,OAAO,CAAC,gBAAM;cACvD0E,gBAAc,CAACE,MAAM,EAAE5B,CAAC,CAAC4B,MAAM,CAAC,CAAC;YAClC,CAAC,CAAC;;;;;EAKP,CAAC;AA1JkD,CA0JlD;AAEF,IAAMC,gBAAgB,GAAG,UACxB3C,eAA6C,EAC7Ca,CAAS,EACTC,CAAM;EAEA,wCAAmD;IAAjDK,oBAAO;IAAExC,cAAwC;EACzD;EACA,IACC,OAAOmC,CAAC,KAAK,QAAQ,KACpBK,OAAO,IACPxC,IAAI,KAAK,SAAS,IAClB5E,mBAAmB,CAAC4E,IAAI,CAAC,IACzB3E,gBAAgB,CAAC2E,IAAI,CAAC,CAAC,EACvB;IACD,IAAI;MACH,OAAOiD,IAAI,CAACC,KAAK,CAACf,CAAC,CAAC;KACpB,CAAC,WAAM;MACP;IAAA;;EAIF;EACA,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAInC,IAAI,KAAK,SAAS,EAAE;IAChD,OAAOiE,OAAO,CAAC9B,CAAC,CAAC;;EAGlB,OAAOA,CAAC;AACT,CAAC;AAED,IAAM+B,kBAAkB,GAAG,UAC1BnC,IAAkB,EAClBV,eAA6C,EAC7C8C,KAAuC;EAEvC,IAAMC,cAAc,GAAGnC,mBAAmB,CAACZ,eAAe,CAAC;EAC3DpC,MAAM,CAACkC,OAAO,CAACY,IAAI,CAAC,CAAC5C,OAAO,CAAC,UAACJ,EAAM;QAANqC,kBAAM;MAALc,SAAC;MAAEC,SAAC;IAClC,IAAMkC,WAAW,GAAGL,gBAAgB,CAAC3C,eAAe,EAAEa,CAAC,EAAEC,CAAC,CAAC;IAE3DiC,cAAc,CAAClC,CAAC,EAAEmC,WAAW,CAAC;IACxBF,KAAM,CAACjC,CAAC,CAAC,GAAGmC,WAAW;EAC9B,CAAC,CAAC;AACH,CAAC;AAED,IAAM9C,gBAAgB,GAAG,UACxBF,eAA4B;EAE5B,IAAMC,KAAK,GAAmC;IAC7C,eAAYS,IAAkB;MAC7B,IAAMuC,QAAQ,GAAGrK,OAAO,CACvB,IAAI,EACJ,UAACkK,KAAuC;QACvCD,kBAAkB,CAACnC,IAAI,EAAEV,eAAe,EAAE8C,KAAK,CAAC;QAEhD;QACA,IAAMI,uBAAuB,GAAG3C,iBAAiB,CAAC/D,GAAG,CAACkE,IAAI,CAAC;QAE3D,IAAMyC,qBAAqB,GAC1BD,uBAAuB,GACaxC,IAAK,GACf,EAAE;QAIrB,kCAAO;QAGf,IAAIzF,WAAW,CAAC+E,eAAe,CAAC,EAAE;UACjC,IAAMoD,eAAe,GAAGC,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAKrG,SAAS;UAEzD,IAAMsG,EAAE,GAAGF,eAAe,GACvBC,GAAG,GACHrD,eAAe,CAACuD,QAAQ,GACxBvK,KAAK,EAAE,GACPuC,IAAI,EAAE;UAEyBuH,KAAO,CAACQ,EAAE,GAAGA,EAAE;SACjD,MAAM,IAAIpI,qBAAqB,CAAC8E,eAAe,CAAC,EAAE;UAClD;UACkC8C,KAAO,CAACQ,EAAE,GAAGR,KAAK,CAACQ,EAAE,IAAItK,KAAK,EAAE;;QAGnE,IAAI,CAACkK,uBAAuB,EAAE;UAC7BM,6BAA6B,CAACV,KAAK,EAAE9C,eAAe,CAAC;;QAG9C,6CAAQ;UAAEyD,qDAAc;UAAEC,yCAAQ;QAE1C,IAAI1D,eAAe,CAACuD,QAAQ,EAAE;UAC7BT,KAAK,CAACa,QAAQ,GAAGA,QAAQ;UACzBb,KAAK,CAACW,cAAc,GAAGA,cAAc;UACrCX,KAAK,CAACY,QAAQ,GAAGA,QAAQ;;MAE3B,CAAC,CACD;MAED,OAAOT,QAAQ;IAChB;IAEOW,YAAM,GAAb,UAAcC,MAAS,EAAEC,EAAiC;MACzD,IAAM9H,gBAAgB,GAAG4B,MAAM,CAACmG,cAAc,CAACF,MAAM,IAAI,EAAE,CAAC,CAACG,WAAW;MACxE,IAAI,CAAC1H,uBAAuB,CAACN,gBAAgB,CAAC,EAAE;QAC/C,IAAMiI,GAAG,GAAG,wCAAwC;QACpD3I,MAAM,CAACsE,KAAK,CAACqE,GAAG,EAAE;UAAEJ,MAAM;QAAA,CAAE,CAAC;QAC7B,MAAM,IAAI5E,KAAK,CAACgF,GAAG,CAAC;;MAGrB,IAAIC,OAAO;MACX,IAAM7F,KAAK,GAAGzF,OAAO,CACpBiL,MAAM,EACN,eAAK;QACJC,EAAE,CAAkBhB,KAAK,CAAC;QAE1B,IAAMqB,QAAQ,GAAGpJ,2BAA2B,CAACiF,eAAe,CAAC;QAC7D;QACAmE,QAAQ,CAACrG,OAAO,CAAC,aAAG;UAAI,OAAEgF,KAAgB,CAACsB,GAAG,CAAC,GAAGP,MAAM,CAACO,GAAG,CAAC;QAArC,CAAsC,CAAC;QAE/D,IAAMrB,cAAc,GAAGnC,mBAAmB,CAACZ,eAAe,CAAC;QAC3DpC,MAAM,CAACkC,OAAO,CAACgD,KAAK,CAAC,CAAChF,OAAO,CAAC,UAACJ,EAAM;cAANqC,kBAAM;YAALc,SAAC;YAAEC,SAAC;UACnC,IAAMkC,WAAW,GAAGL,gBAAgB,CAAC3C,eAAe,EAAEa,CAAC,EAAEC,CAAC,CAAC;UAE3DiC,cAAc,CAAClC,CAAC,EAAEmC,WAAW,CAAC;QAC/B,CAAC,CAAC;MACH,CAAC,EACD,WAAC;QAAI,OAACkB,OAAO,GAAGG,CAAC;MAAZ,CAAa,CAClB;MAED,IAAMC,kBAAkB,GAAGxI,eAAe,CAACU,GAAG,CAACqH,MAAM,CAAC;MAEtD,IAAIK,OAAO,CAACK,MAAM,IAAID,kBAAkB,EAAE;QACzC,IAAIA,kBAAkB,EAAE;UACjB,+CAA+D;YAA9DE,uBAAe;YAAEC,sBAA6C;UACrE,IAAMC,aAAa,GAAGtJ,YAAY,CACjCqJ,cAAc,EACdD,eAAe,EACfN,OAAO,CACP;UACDpI,eAAe,CAAC+C,GAAG,CAACR,KAAK,EAAE,CAACqG,aAAa,EAAED,cAAc,CAAC,CAAC;UAC3DE,6BAA6B,CAACD,aAAa,EAAE1E,eAAe,CAAC;SAC7D,MAAM;UACNlE,eAAe,CAAC+C,GAAG,CAACR,KAAK,EAAE,CAAC6F,OAAO,EAAEL,MAAM,CAAC,CAAC;UAC7Cc,6BAA6B,CAACT,OAAO,EAAElE,eAAe,CAAC;;;MAIzD,OAAO3B,KAAK;IACb,CAAC;IAED;IACA;IACOuF,cAAQ,GAAf,UAAgBgB,IAAa;MAA7B;MACC,IAAIrF,KAAK,CAAC4B,OAAO,CAACyD,IAAI,CAAC,EAAE;QACxB,OAAOA,IAAI,CAAC1C,GAAG,CAAC,cAAI;UAAI,YAAI,CAAC2C,QAAQ,CAACnE,IAAI,CAAC;QAAnB,CAAmB,CAAC;;MAG7C,IAAMuC,QAAQ,GAAGxC,oBAAoB,CAACR,KAAK,EAAE2E,IAAI,CAAC;MAElD,IAAM7B,cAAc,GAAGnC,mBAAmB,CAACZ,eAAe,CAAC;MAE3DpC,MAAM,CAACkC,OAAO,CAACmD,QAAQ,CAAC,CAACnF,OAAO,CAAC,UAACJ,EAAM;YAANqC,kBAAM;UAALc,SAAC;UAAEC,SAAC;QACtCiC,cAAc,CAAClC,CAAC,EAAEC,CAAC,CAAC;MACrB,CAAC,CAAC;MAEF,OAAOmC,QAAQ;IAChB,CAAC;IACF,YAAC;EAAD,CAAC,EAAC;EAEFhD,KAAK,CAACtH,SAAS,CAAC,GAAG,IAAI;EAEvBiF,MAAM,CAACkH,cAAc,CAAC7E,KAAK,EAAE,MAAM,EAAE;IAAEqB,KAAK,EAAEtB,eAAe,CAAC3D;EAAI,CAAE,CAAC;EAErE,OAAO4D,KAAK;AACb,CAAC;AAED,IAAMuD,6BAA6B,GAAG,UACrCV,KAAQ,EACR9C,eAA4B;EAE5B,IAAM+E,SAAS,GAAGnH,MAAM,CAACC,IAAI,CAACiF,KAAK,CAAC;EAC5B,mCAAM;EAEdiC,SAAS,CAACjH,OAAO,CAAC,aAAG;IACpB,IAAIQ,MAAM,CAAC8F,GAAG,CAAC,IAAI9F,MAAM,CAAC8F,GAAG,CAAC,CAACY,UAAU,EAAE;MAC1C,MAAM,IAAI/F,KAAK,CAAImF,GAAG,mBAAgB,CAAC;;EAEzC,CAAC,CAAC;AACH,CAAC;AAED,IAAMO,6BAA6B,GAAG,UACrCT,OAAgB,EAChBlE,eAA4B;EAE5B,IAAMiF,UAAU,GAAGf,OAAO,CAAChC,GAAG,CAAC,WAAC;IAAI,QAACmC,CAAC,CAACa,IAAI,CAAC,CAAC,CAAC,EAAEb,CAAC,CAAC/C,KAAK,CAAC;EAApB,CAAoB,CAAC;EACjD,mCAAM;EAEd2D,UAAU,CAACnH,OAAO,CAAC,UAACJ,EAAU;QAAVqC,kBAAU;MAATqE,WAAG;MAAEe,WAAG;IAC5B,IAAI,CAACA,GAAG,IAAI,CAAC7G,MAAM,CAAC8F,GAAG,CAAC,EAAE;IAE1B,IAAI9F,MAAM,CAAC8F,GAAG,CAAC,CAACY,UAAU,EAAE;MAC3B,MAAM,IAAI/F,KAAK,CAAImF,GAAG,mBAAgB,CAAC;;EAEzC,CAAC,CAAC;AACH,CAAC;AAED,IAAM9D,mBAAmB,GAAG,UAC3BD,cAA8B;EAE9B,IAAMJ,KAAK,GAAgC;IAC1C,eAAYS,IAAkB;MAC7B,IAAMuC,QAAQ,GAAGrK,OAAO,CACvB,IAAI,EACJ,UAACkK,KAAuC;QACvCD,kBAAkB,CAACnC,IAAI,EAAEL,cAAc,EAAEyC,KAAK,CAAC;MAChD,CAAC,CACD;MAED,OAAOG,QAAQ;IAChB;IACD,YAAC;EAAD,CAAC,EAAC;EAEFhD,KAAK,CAACtH,SAAS,CAAC,GAAG,IAAI;EAEvBiF,MAAM,CAACkH,cAAc,CAAC7E,KAAK,EAAE,MAAM,EAAE;IAAEqB,KAAK,EAAEjB,cAAc,CAAChE;EAAI,CAAE,CAAC;EAEpEzB,qBAAqB,CAACqF,KAAK,CAAC;EAE5B,OAAOA,KAAK;AACb,CAAC;AAED,SAASmF,UAAU,CAAC7I,GAAQ;EAC3B,OAAO,OAAOA,GAAG,KAAK,QAAQ;AAC/B;AAEA,SAAS8I,sBAAsB,CAACC,YAA0B;EACjD,wCAAU;IAAEtJ,gDAAgB;IAAEuJ,sCAAW;EACzC,mCAAQ;EAChB,OAAO9E,oBAAoB,CAACzE,gBAAgB,wBAAOwJ,UAAU;IAAE7B,QAAQ;EAAA,GAAG;AAC3E;AAEA,SAAS8B,mBAAmB,CAAC7F,KAAiC;EAC7DtE,MAAM,CAAC4B,IAAI,CAAC0C,KAAK,CAAC;AACnB;AAEA,SAAS8F,8BAA8B,CACtCC,aAAyB,EACzBxG,SAAiB;EAEjB,IAAIL,MAAsE;EAE1E,QAAQ6G,aAAa;IACpB,KAAKzL,SAAS;MACb4E,MAAM,GAAGlC,gBAAgB,CAACuC,SAAS,CAAC;MACpC;IACD,KAAKzE,IAAI;MACRoE,MAAM,GAAGnC,WAAW,CAACwC,SAAS,CAAC;MAC/B;IACD,KAAK1E,IAAI;MACRqE,MAAM,GAAGpC,WAAW,CAACyC,SAAS,CAAC;MAC/B;IACD,KAAK3E,OAAO;MACXsE,MAAM,GAAGjC,cAAc,CAACsC,SAAS,CAAC;MAClC;IACD;MACC9E,eAAe,CAACsL,aAAa,CAAC;MAC9B;EAAM;EAGR,IAAIrJ,uBAAuB,CAACwC,MAAM,CAAC,EAAE;IACpC,OAAOA,MAAM;GACb,MAAM;IACN,IAAMmF,GAAG,GAAG,uDAAqD9E,SAAS,qBAAgBwG,aAAe;IACzGrK,MAAM,CAACsE,KAAK,CAACqE,GAAG,CAAC;IAEjB,MAAM,IAAIhF,KAAK,CAACgF,GAAG,CAAC;;AAEtB;AAEA;;;;;;;;;;;;AAYA,SAAe2B,kBAAkB,CAChCC,OAAgB,EAChBlI,OAAe;;;;;;;UAETmI,OAAO,GACZlJ,gBAAgB,CAACkJ,OAA8C;UAE1D9F,eAAe,GAAGrE,MAAM,CAACQ,UAAU,CAACjC,SAAS,CAAC,CAACkC,MAAM,CAAC0J,OAAO;UAEnE,qBAAMD,OAAO,CAACE,YAAY,CAAC,UAAMC,CAAC;YAAA;;;;;oBACF,qBAAMA,CAAC,CAACC,KAAK,CAC3CH,OAAO,EACPzM,qBAAqB,CAAC6M,kBAAkB,CAAClG,eAAe,EAAE,WAAC;sBAC1D,QAAC,CAACoE,GAAG,CAAC,IAAI,EAAE1I,sBAAsB,CAAC;oBAAnC,CAAmC,CACnC,EACD;sBAAEyK,IAAI,EAAE,CAAC;sBAAEC,KAAK,EAAE;oBAAC,CAAE,CACrB;;oBANK1I,2BAAyBqC,SAM9B,OANMsG,oBAAoB;0BAS1BA,oBAAoB,KAAKrJ,SAAS,IAClCqJ,oBAAoB,CAAC/E,KAAK,KAAKtE,SAAS,GADxC;oBAGMsJ,WAAW,GAAG1E,IAAI,CAACC,KAAK,CAACwE,oBAAoB,CAAC/E,KAAK,CAAC;0BAEtDgF,WAAW,KAAK3I,OAAO,GAAvB;oBACH,qBAAMqI,CAAC,CAACO,KAAK,CAAC,KAAK,CAAC;;oBAApBxG,SAAoB;;;;;oBAGrB,qBAAMiG,CAAC,CAACQ,IAAI,CACX/F,oBAAoB,CAACqF,OAAO,EAAE;sBAC7B1B,GAAG,EAAE1I,sBAAsB;sBAC3B4F,KAAK,EAAEM,IAAI,CAAC6E,SAAS,CAAC9I,OAAO;qBAC7B,CAAC,CACF;;oBALDoC,SAKC;;;;;;;WAEF,CAAC;;;UA1BFrC,SA0BE;;;;;;;AAGH,IAAIgJ,gBAA4C;AAEhD,SAASnJ,YAAY;EACpB,IAAMtB,SAAS,GAAoB;IAClCI,IAAI,EAAEnC,SAAS;IACf8D,aAAa,EAAE,EAAE;IACjB2I,KAAK,EAAE,EAAE;IACTxG,SAAS,EAAE,EAAE;IACb/D,MAAM,EAAE;MACP0J,OAAO,EAAE;QACRzJ,IAAI,EAAE,SAAS;QACfuK,UAAU,EAAE,UAAU;QACtBrD,QAAQ,EAAE,KAAK;QACfjF,MAAM,EAAE;UACPgF,EAAE,EAAE;YACHjH,IAAI,EAAE,IAAI;YACVsC,IAAI,EAAE,IAAI;YACVkI,UAAU,EAAE,IAAI;YAChB1F,OAAO,EAAE;WACT;UACDiD,GAAG,EAAE;YACJ/H,IAAI,EAAE,KAAK;YACXsC,IAAI,EAAE,QAAQ;YACdkI,UAAU,EAAE,IAAI;YAChB1F,OAAO,EAAE;WACT;UACDG,KAAK,EAAE;YACNjF,IAAI,EAAE,OAAO;YACbsC,IAAI,EAAE,QAAQ;YACdkI,UAAU,EAAE,IAAI;YAChB1F,OAAO,EAAE;;;;;GAKb;EAED,OAAOlF,SAAS;AACjB;AAEA,IAAK6K,cAMJ;AAND,WAAKA,cAAc;EAClBA,4CAA0B;EAC1BA,uCAAqB;EACrBA,qCAAmB;EACnBA,uCAAqB;EACrBA,uCAAqB;AACtB,CAAC,EANIA,cAAc,KAAdA,cAAc;AAQnB;EAAA;IAAA;IACC;IACQ,SAAI,GAAG3O,IAAI;IACX,QAAG,GAAGD,GAAG;IACT,UAAK,GAAGE,KAAK;IAEb,kBAAa,GAAwB,EAAE;IAavC,mBAAc,GACrB,IAAIyD,OAAO,EAAoC;IAGhD;IACQ,mBAAc,GAAmB;MACxC1D,IAAI,EAAE,IAAI,CAACA,IAAI;MACfD,GAAG,EAAE,IAAI,CAACA,GAAG;MACbE,KAAK,EAAE,IAAI,CAACA;KACZ;IAGD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA+BQ,qBAAgB,GAAG,IAAIM,wBAAwB,EAAE;IAEzD;;;;;;IAMQ,UAAK,GAAmBoO,cAAc,CAACC,UAAU;IAsCzD;;;;;;;IAOA,UAAK,GAAG;MAAA;;;UACP,sBAAO,IAAI,CAACC,gBAAgB,CAC1BrG,GAAG,CAAC;YAAA;;;;;;oBACJ,IAAI,CAACsG,KAAK,GAAGH,cAAc,CAACI,QAAQ;0BAChC,IAAI,CAACC,WAAW,KAAKnK,SAAS,GAA9B;oBACH1B,MAAM,CAAC8L,KAAK,CAAC,oBAAoB,CAAC;oBAClC,IAAI,CAACD,WAAW,GAAG,IAAIE,OAAO,CAAC,UAACC,GAAG,EAAEC,GAAG;sBACvCC,KAAI,CAACC,WAAW,GAAGH,GAAG;sBACtBE,KAAI,CAACE,UAAU,GAAGH,GAAG;oBACtB,CAAC,CAAC;;;oBAEF,qBAAM,IAAI,CAACJ,WAAW;;oBAAtBpH,SAAsB;oBACtB;;oBAGD,IAAI,CAAC8F,OAAO,GAAG,IAAIrM,OAAO,CACzBmC,MAAM,EACNc,iBAAiB,EACjBiJ,8BAA8B,EAC9BjF,oBAAoB,EACpB,IAAI,CAACkH,cAAc,EACnB,IAAI,CAACC,SAAS,CACd;oBAED,qBAAM,IAAI,CAAC/B,OAAO,CAACnF,IAAI,EAAE;;oBAAzBX,SAAyB;oBAEzBL,sBAAsB,EAAE;oBACxB,qBAAMkG,kBAAkB,CAAC,IAAI,CAACC,OAAO,EAAElK,MAAM,CAACgC,OAAO,CAAC;;oBAAtDoC,SAAsD;oBAE9C8H,2BAA2B,GAAK,IAAI,CAACC,aAAa,4BAAvB;yBAE/BD,2BAA2B,EAA3B;oBACHvM,MAAM,CAAC8L,KAAK,CACX,4BAA4B,EAC5BS,2BAA2B,CAC3B;oBAEDnK,SAAI;oBAAkB,qBAAM,IAAI,CAACqK,sBAAsB,EAAE;;oBAAzDrK,GAAKsK,cAAc,GAAGjI,SAAmC;oBAEzD,IAAI,CAACkI,IAAI,GAAG,IAAIvO,UAAU,CACzBiC,MAAM,EACNc,iBAAiB,EACjBC,WAAW,EACXC,WAAW,EACX,IAAI,CAACkJ,OAAO,EACZpF,oBAAoB,EACpB,IAAI,CAACyH,eAAe,EACpB,IAAI,CAACC,YAAY,EACjB,IAAI,CAACH,cAAc,EACnB,IAAI,CAACF,aAAa,EAClB,IAAI,CAACM,gBAAgB,EACrB,IAAI,CAACC,cAAc,EACnB,IAAI,CAACC,mBAAmB,CACxB;oBAEKC,8BAA8B,GACnC,IAAI,CAACC,gBAAgB,GAAG,IAAI,GAAG,EAAE;oBAClC9B,gBAAgB,GAAG,IAAI,CAACuB,IAAI,CAC1BQ,KAAK,CAAC;sBAAED,gBAAgB,EAAED;oBAA8B,CAAE,CAAC,CAC3DG,SAAS,CAAC;sBACVC,IAAI,EAAE,UAACjL,EAAc;4BAAZiB,cAAI;0BAAEiK,cAAI;wBAClB;wBACA;wBACA,IAAMC,SAAS,GAAGC,MAAM,GACrBrP,cAAc,CAACsP,8BAA8B,GAC7CtP,cAAc,CAACuP,8BAA8B;wBAEhD,IAAIrK,IAAI,KAAKkK,SAAS,EAAE;0BACvBrB,KAAI,CAACC,WAAW,EAAE;;wBAGnBjP,GAAG,CAACyQ,QAAQ,CAAC,WAAW,EAAE;0BACzBC,KAAK,EAAEvK,IAAI;0BACXiK,IAAI;yBACJ,CAAC;sBACH,CAAC;sBACDhJ,KAAK,EAAE,aAAG;wBACTtE,MAAM,CAAC4B,IAAI,CAAC,YAAY,EAAEiM,GAAG,CAAC;wBAC9B3B,KAAI,CAACE,UAAU,EAAE;sBAClB;qBACA,CAAC;;;oBAEHpM,MAAM,CAAC4B,IAAI,CACV,4GAA4G,EAC5G;sBACCkM,MAAM,EAAE,IAAI,CAACtB;qBACb,CACD;oBAED,IAAI,CAACL,WAAW,EAAE;;;oBAGnB,qBAAM,IAAI,CAACN,WAAW;;oBAAtBpH,SAAsB;oBACtB,IAAI,CAACkH,KAAK,GAAGH,cAAc,CAACuC,OAAO;;;;;WACnC,EAAE,iBAAiB,CAAC,CACpBC,KAAK,CAAC,IAAI,CAACC,kBAAkB,CAAC,mBAAmB,CAAC,CAAC;;;KACrD;IAED,UAAK,GAaD,UACHvN,gBAA+C,EAC/CwN,oBAGsB,EACtBC,kBAA+C;MAAA;;;UAE/C,sBAAO,IAAI,CAACzC,gBAAgB,CAC1BrG,GAAG,CAAC;YAAA;;;;;oBACJ,qBAAM,IAAI,CAAC8H,KAAK,EAAE;;oBAAlB/K,SAAkB;oBAElB;oBAEA,IAAI,CAACpB,uBAAuB,CAACN,gBAAgB,CAAC,EAAE;sBACzCiI,GAAG,GAAG,sCAAsC;sBAClD3I,MAAM,CAACsE,KAAK,CAACqE,GAAG,EAAE;wBAAEjI,gBAAgB;sBAAA,CAAE,CAAC;sBAEvC,MAAM,IAAIiD,KAAK,CAACgF,GAAG,CAAC;;oBAGrB,IAAI,OAAOuF,oBAAoB,KAAK,QAAQ,EAAE;sBAC7C,IAAIC,kBAAkB,KAAKzM,SAAS,EAAE;wBACrC1B,MAAM,CAAC4B,IAAI,CAAC,2CAA2C,CAAC;;;oBAIpD8C,eAAe,GAAGjE,kBAAkB,CAACC,gBAAgB,CAAC;oBACtD0N,SAAS,GAAG3O,2BAA2B,CAACiF,eAAe,CAAC;oBAI9D,IAAIoF,UAAU,CAACoE,oBAAoB,CAAC,EAAE;sBACrC,IAAIE,SAAS,CAACnF,MAAM,GAAG,CAAC,EAAE;wBACnBN,GAAG,GAAG9J,aAAa,CAACwP,gCAAgC;wBAC1DrO,MAAM,CAACsE,KAAK,CAACqE,GAAG,EAAE;0BAAEyF,SAAS;wBAAA,CAAE,CAAC;wBAEhC,MAAM,IAAIzK,KAAK,CAACgF,GAAG,CAAC;;sBAGrB2F,SAAS,GAAGvQ,qBAAqB,CAACwQ,oBAAoB,CACrD7J,eAAe,EACf0J,SAAS,CAAC,CAAC,CAAC,EACZF,oBAAoB,CACpB;qBACD,MAAM;sBACN;sBACA,IAAIvP,kBAAkB,CAAIuP,oBAAoB,EAAExJ,eAAe,CAAC,EAAE;wBACjE4J,SAAS,GAAGvQ,qBAAqB,CAACyQ,WAAW,CAC5C9J,eAAe,EACZwJ,oBAAoB,CACvB;uBACD,MAAM,IAAIpQ,eAAe,CAACoQ,oBAAoB,CAAC,EAAE;wBACjD;wBACAI,SAAS,GAAG5M,SAAS;uBACrB,MAAM;wBACN4M,SAAS,GAAGvQ,qBAAqB,CAAC6M,kBAAkB,CACnDlG,eAAe,EACVwJ,oBAAoB,CACzB;;;oBAIGO,UAAU,GAAG,IAAI,CAACC,iBAAiB,CACxChK,eAAe,EACfyJ,kBAAkB,CAClB;oBAED;oBAEAnO,MAAM,CAAC8L,KAAK,CAAC,cAAc,EAAE;sBAC5BpL,gBAAgB;sBAChB4N,SAAS,EAAEvQ,qBAAqB,CAAC4Q,aAAa,CAACL,SAAS,EAAE,KAAK,CAAC;sBAChEG,UAAU,wBACNA,UAAU;wBACbG,IAAI,EAAE5Q,yBAAyB,CAAC2Q,aAAa,CAC5CF,UAAU,IAAIA,UAAU,CAACG,IAAI,EAC7B,KAAK;sBACL;qBAEF,CAAC;oBAEa,qBAAM,IAAI,CAACrE,OAAO,CAACI,KAAK,CACtCjK,gBAAgB,EAChB4N,SAAS,EACTG,UAAU,CACV;;oBAJKjL,MAAM,GAAGpB,SAId;oBAEKyM,SAAS,GACd/E,UAAU,CAACoE,oBAAoB,CAAC,IAChCvP,kBAAkB,CAACuP,oBAAoB,EAAExJ,eAAe,CAAC;oBAE1D,sBAAOmK,SAAS,GAAGrL,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM;gBAAC;;;WACtC,EAAE,iBAAiB,CAAC,CACpBwK,KAAK,CAAC,IAAI,CAACC,kBAAkB,CAAC,mBAAmB,CAAC,CAAC;;;KACrD;IAED,SAAI,GAAG,UACNlL,KAAQ,EACR+L,SAAqC;MAAA;;;UAErC,sBAAO,IAAI,CAACpD,gBAAgB,CAC1BrG,GAAG,CAAC;YAAA;;;;;;oBACJ,qBAAM,IAAI,CAAC8H,KAAK,EAAE;;oBAAlB1I,SAAkB;oBAIZsK,YAAY,GAAGvO,eAAe,CAACI,GAAG,CAACmC,KAAK,CAAC;oBAEzCrC,gBAAgB,GACrBqC,KAAK,GAAkCA,KAAK,CAAC2F,WAAW,GAAGhH,SAAS;oBAErE,IAAI,CAACV,uBAAuB,CAACN,gBAAgB,CAAC,EAAE;sBACzCiI,GAAG,GAAG,4CAA4C;sBACxD3I,MAAM,CAACsE,KAAK,CAACqE,GAAG,EAAE;wBAAE5F,KAAK;sBAAA,CAAE,CAAC;sBAE5B,MAAM,IAAIY,KAAK,CAACgF,GAAG,CAAC;;oBAGfjE,eAAe,GAAGjE,kBAAkB,CAACC,gBAAgB,CAAC;oBAEtDsO,iBAAiB,GAAGjR,qBAAqB,CAAC6M,kBAAkB,CACjElG,eAAe,EACfoK,SAAU,CACV;oBAEoB,qBAAM,IAAI,CAACvE,OAAO,CAACE,YAAY,CAAC,UAAMC,CAAC;sBAAA;;;;8BAC3D,qBAAMA,CAAC,CAACQ,IAAI,CAACnI,KAAK,EAAEiM,iBAAiB,EAAEtN,SAAS,EAAEqN,YAAY,CAAC;;8BAA/D3M,SAA+D;8BAE/D,sBAAOsI,CAAC,CAACC,KAAK,CACbjK,gBAAgB,EAChB3C,qBAAqB,CAACyQ,WAAW,CAAC9J,eAAe,EAAE3B,KAAK,CAAC,CACzD;0BAAC;;;qBACF,CAAC;;oBAPIX,2BAAeqC,SAOnB,OAPKwK,UAAU;oBASjB,sBAAOA,UAAU;gBAAC;;;WAClB,EAAE,gBAAgB,CAAC,CACnBjB,KAAK,CAAC,IAAI,CAACC,kBAAkB,CAAC,kBAAkB,CAAC,CAAC;;;KACpD;IAED,uBAAkB,GAAG,UAACH,MAAuB;MACpC,sCAA0B;MAElC,IAAMoB,wBAAwB,GAAkB;QAC/C,YAAI,CAACtC,eAAe,KAAK7C,sBAAsB;MAA/C,CAA+C;MAEhD,IAAIoF,eAAe,IAAIA,eAAe,CAACvC,eAAe,EAAE;QACvD,OAAOuC,eAAe,CAACvC,eAAe;;MAEvC,IAAIsC,wBAAwB,EAAE,IAAIpB,MAAM,CAAClB,eAAe,EAAE;QACzD,OAAOkB,MAAM,CAAClB,eAAe;;MAG9B,OAAOV,KAAI,CAACU,eAAe,IAAI7C,sBAAsB;IACtD,CAAC;IAED,oBAAe,GAAG,UAAC+D,MAAuB;MACjC,sCAA0B;MAElC,IAAMsB,qBAAqB,GAAkB;QAC5C,YAAI,CAACvC,YAAY,KAAK1C,mBAAmB;MAAzC,CAAyC;MAE1C,IAAIgF,eAAe,IAAIA,eAAe,CAACtC,YAAY,EAAE;QACpD,OAAOsC,eAAe,CAACtC,YAAY;;MAEpC,IAAIuC,qBAAqB,EAAE,IAAItB,MAAM,CAACjB,YAAY,EAAE;QACnD,OAAOiB,MAAM,CAACjB,YAAY;;MAG3B,OAAOX,KAAI,CAACW,YAAY,IAAI1C,mBAAmB;IAChD,CAAC;IAED,WAAM,GAgBF,UACHkF,kBAAqD,EACrDnB,oBAGsB;MAAA;;;UAEtB,sBAAO,IAAI,CAACxC,gBAAgB,CAC1BrG,GAAG,CAAC;YAAA;;;;;oBACJ,qBAAM,IAAI,CAAC8H,KAAK,EAAE;;oBAAlBmC,SAAkB;oBAIlB,IAAI,CAACD,kBAAkB,EAAE;sBAClB1G,GAAG,GAAG,qCAAqC;sBACjD3I,MAAM,CAACsE,KAAK,CAACqE,GAAG,EAAE;wBAAE0G,kBAAkB;sBAAA,CAAE,CAAC;sBAEzC,MAAM,IAAI1L,KAAK,CAACgF,GAAG,CAAC;;yBAGjB3H,uBAAuB,CAAIqO,kBAAkB,CAAC,EAA9C;oBACG3O,gBAAgB,GAAG2O,kBAAkB;oBAE3C,IAAI,CAACnB,oBAAoB,EAAE;sBACpBvF,GAAG,GACR,mFAAmF;sBACpF3I,MAAM,CAACsE,KAAK,CAACqE,GAAG,EAAE;wBAAEuF,oBAAoB;sBAAA,CAAE,CAAC;sBAE3C,MAAM,IAAIvK,KAAK,CAACgF,GAAG,CAAC;;oBAGfjE,eAAe,GAAGjE,kBAAkB,CAACC,gBAAgB,CAAC;oBAE5D,IAAI,OAAOwN,oBAAoB,KAAK,QAAQ,EAAE;sBACvCE,SAAS,GAAG3O,2BAA2B,CAACiF,eAAe,CAAC;sBAE9D,IAAI0J,SAAS,CAACnF,MAAM,GAAG,CAAC,EAAE;wBACnBN,GAAG,GAAG9J,aAAa,CAAC0Q,iCAAiC;wBAC3DvP,MAAM,CAACsE,KAAK,CAACqE,GAAG,EAAE;0BAAEyF,SAAS;wBAAA,CAAE,CAAC;wBAEhC,MAAM,IAAIzK,KAAK,CAACgF,GAAG,CAAC;;sBAGrBmG,SAAS,GAAG/Q,qBAAqB,CAACwQ,oBAAoB,CACrD9N,kBAAkB,CAACC,gBAAgB,CAAC,EACpC0N,SAAS,CAAC,CAAC,CAAC,EACZF,oBAAoB,CACpB;qBACD,MAAM;sBACN,IAAIvP,kBAAkB,CAACuP,oBAAoB,EAAExJ,eAAe,CAAC,EAAE;wBAC9DoK,SAAS,GAAG/Q,qBAAqB,CAACyQ,WAAW,CAC5C9J,eAAe,EACZwJ,oBAAoB,CACvB;uBACD,MAAM;wBACNY,SAAS,GAAG/Q,qBAAqB,CAAC6M,kBAAkB,CACnDlG,eAAe;wBACf;;;;wBAIAwJ,oBAAiD,CACjD;;sBAGF,IACC,CAACY,SAAS,IACV,CAAC/Q,qBAAqB,CAACyR,gBAAgB,CAACV,SAAS,CAAC,EACjD;wBACKnG,GAAG,GACR,mEAAmE;wBACpE3I,MAAM,CAACsE,KAAK,CAACqE,GAAG,EAAE;0BAAEmG,SAAS;wBAAA,CAAE,CAAC;wBAEhC,MAAM,IAAInL,KAAK,CAACgF,GAAG,CAAC;;;oBAIJ,qBAAM,IAAI,CAAC4B,OAAO,CAACrG,MAAM,CAC1CxD,gBAAgB,EAChBoO,SAAS,CACT;;oBAHK1M,2BAAYkN,SAGjB,OAHMG,OAAO;oBAKd,sBAAOA,OAAO;;oBAER1M,KAAK,GAAGsM,kBAAkB;oBAC1B3O,gBAAgB,GAAG4B,MAAM,CAACmG,cAAc,CAAC1F,KAAK,IAAI,EAAE,CAAC,CACzD2F,WAA4C;oBAE9C,IAAI,CAAC1H,uBAAuB,CAACN,gBAAgB,CAAC,EAAE;sBACzCiI,GAAG,GAAG,4CAA4C;sBACxD3I,MAAM,CAACsE,KAAK,CAACqE,GAAG,EAAE;wBAAE5F,KAAK;sBAAA,CAAE,CAAC;sBAE5B,MAAM,IAAIY,KAAK,CAACgF,GAAG,CAAC;;oBAGfjE,eAAe,GAAGjE,kBAAkB,CAACC,gBAAgB,CAAC;oBAEtDgP,WAAW,GAAG3R,qBAAqB,CAACyQ,WAAW,CACpD9J,eAAe,EACf3B,KAAK,CACL;oBAED,IAAImL,oBAAoB,EAAE;sBACzB,IAAI,OAAOA,oBAAoB,KAAK,UAAU,EAAE;wBACzCvF,GAAG,GAAG,kBAAkB;wBAC9B3I,MAAM,CAACsE,KAAK,CAACqE,GAAG,EAAE;0BAAEuF,oBAAoB;wBAAA,CAAE,CAAC;wBAE3C,MAAM,IAAIvK,KAAK,CAACgF,GAAG,CAAC;;sBAGrBmG,SAAS,GAA+BZ,oBAAqB,CAC5DwB,WAAW,CACX;qBACD,MAAM;sBACNZ,SAAS,GAAGY,WAAW;;oBAGJ,qBAAM,IAAI,CAACnF,OAAO,CAACrG,MAAM,CAACnB,KAAK,EAAE+L,SAAS,CAAC;;oBAAzDrK,2BAAc6K,SAA2C,OAAxDK,qBAAS,EAARF,OAAO;oBAEf,sBAAOA,OAAO;gBAAC;;;WAEhB,EAAE,kBAAkB,CAAC,CACrBzB,KAAK,CAAC,IAAI,CAACC,kBAAkB,CAAC,oBAAoB,CAAC,CAAC;;;KACtD;IAED,YAAO,GAcH,UACHoB,kBAAsD,EACtDnB,oBAGsB;MAEtB,IAAII,SAA4B;MAEhC,IAAM5N,gBAAgB,GACrB2O,kBAAkB,IAAIrO,uBAAuB,CAAIqO,kBAAkB,CAAC,GACjEA,kBAAkB,GAClB3N,SAAS;MAEb,IAAI2N,kBAAkB,IAAI3O,gBAAgB,KAAKgB,SAAS,EAAE;QACzD,IAAMqB,KAAK,GAAMsM,kBAAkB;QACnC,IAAMO,kBAAgB,GACrB7M,KAAK,IAAaT,MAAM,CAACmG,cAAc,CAAC1F,KAAK,CAAE,CAAC2F,WAAW;QAE5D,IAAI1H,uBAAuB,CAAI4O,kBAAgB,CAAC,EAAE;UACjD,IAAI1B,oBAAoB,EAAE;YACzBlO,MAAM,CAAC4B,IAAI,CAAC,qDAAqD,EAAE;cAClEmB,KAAK;cACLmL,oBAAoB;aACpB,CAAC;;UAGH,OAAOhC,KAAI,CAAC2D,OAAO,CAACD,kBAAgB,EAAE7M,KAAK,CAACiF,EAAE,CAAC;SAC/C,MAAM;UACN,IAAMW,GAAG,GACR,8DAA8D;UAC/D3I,MAAM,CAACsE,KAAK,CAACqE,GAAG,EAAE;YAAE5F,KAAK;UAAA,CAAE,CAAC;UAE5B,MAAM,IAAIY,KAAK,CAACgF,GAAG,CAAC;;;MAItB;MACA,IACCuF,oBAAoB,IACpBxN,gBAAgB,IAChB/B,kBAAkB,CACjBuP,oBAAoB,EACpBzN,kBAAkB,CAACC,gBAAgB,CAAC,CACpC,EACA;QACD,IAAMiI,GAAG,GAAG9J,aAAa,CAACiR,wBAAwB;QAClD9P,MAAM,CAACsE,KAAK,CAACqE,GAAG,EAAE;UAAEoH,aAAa,EAAE7B;QAAoB,CAAE,CAAC;QAE1D,MAAM,IAAIvK,KAAK,CAACgF,GAAG,CAAC;;MAGrB,IAAIuF,oBAAoB,KAAKxM,SAAS,IAAIhB,gBAAgB,KAAKgB,SAAS,EAAE;QACzE,IAAMiH,GAAG,GAAG,oDAAoD;QAChE3I,MAAM,CAACsE,KAAK,CAACqE,GAAG,EAAEuF,oBAAoB,CAAC;QACvC,MAAM,IAAIvK,KAAK,CAACgF,GAAG,CAAC;;MAGrB,IAAIjI,gBAAgB,IAAI,CAACM,uBAAuB,CAACN,gBAAgB,CAAC,EAAE;QACnE,IAAMiI,GAAG,GAAG,sCAAsC;QAClD3I,MAAM,CAACsE,KAAK,CAACqE,GAAG,EAAE;UAAEjI,gBAAgB;QAAA,CAAE,CAAC;QAEvC,MAAM,IAAIiD,KAAK,CAACgF,GAAG,CAAC;;MAGrB,IAAI,OAAOuF,oBAAoB,KAAK,QAAQ,EAAE;QAC7C,IAAMxJ,eAAe,GAAGjE,kBAAkB,CAACC,gBAAgB,CAAC;QACtD,gEAAyD;UAAxDsP,gBAAwD;QAE/D1B,SAAS,GAAGvQ,qBAAqB,CAACwQ,oBAAoB,CACrD9N,kBAAkB,CAACC,gBAAgB,CAAC,EACpCsP,QAAQ,EACR9B,oBAAoB,CACpB;OACD,MAAM;QACN,IAAIpQ,eAAe,CAACoQ,oBAAoB,CAAC,EAAE;UAC1CI,SAAS,GAAG5M,SAAS;SACrB,MAAM;UACN4M,SAAS,GACR5N,gBAAgB,IAChB3C,qBAAqB,CAAC6M,kBAAkB,CACvCnK,kBAAkB,CAACC,gBAAgB,CAAC,EACpCwN,oBAAoB,CACpB;;;MAIJ,OAAO,IAAIvQ,UAAU,CAAyB,kBAAQ;QACrD,IAAIsS,MAAkC;QAEtC/D,KAAI,CAACR,gBAAgB,CACnBrG,GAAG,CAAC;UAAA;;;;;kBACJ,qBAAM,IAAI,CAAC8H,KAAK,EAAE;;kBAAlB/K,SAAkB;kBAElB;kBACA;kBACA6N,MAAM,GAAG,IAAI,CAAC1F,OAAO,CACnBsF,OAAO,CAACnP,gBAAgB,EAAE4N,SAAS,CAAC,CACpCrL,MAAM,CAAC,UAACb,EAAS;wBAAPW,gBAAK;oBAAO,wBAAiB,CAACA,KAAK,CAAC,KAAK3D,IAAI;kBAAjC,CAAiC,CAAC,CACxDgO,SAAS,CAAC;oBACVC,IAAI,EAAE,cAAI;sBACT,YAAI,CAAC3B,gBAAgB,CAACwE,MAAM,IAC5BhE,KAAI,CAACR,gBAAgB,CAACrG,GAAG,CAAC;wBAAA;;;;;gCAKrBhB,OAAO,GAAG8C,IAAI;sCAIdA,IAAI,CAACgJ,MAAM,KAAK,QAAQ,GAAxB;gCACGzL,eAAe,GAAGjE,kBAAkB,CAAC0G,IAAI,CAACpE,KAAK,CAAC;gCAChDqL,SAAS,GACd3O,2BAA2B,CAACiF,eAAe,CAAC;gCACvC0L,oBAAoB,GAAG1Q,2BAA2B,CACvDyH,IAAI,CAACkJ,OAAO,EACZjC,SAAS,CACT;gCACoB,qBAAM,IAAI,CAACzD,KAAK,CACpCxD,IAAI,CAACpE,KAAK,EACVqN,oBAAoB,CACpB;;gCAHKE,YAAY,GAAGlO,SAGpB;gCACDiC,OAAO,yBACHA,OAAO;kCACVgM,OAAO,EAAEC;gCAAiB,EAC1B;;;gCAGFC,QAAQ,CAAClD,IAAI,CAAChJ,OAAiC,CAAC;;;;;uBAChD,EAAE,mCAAmC,CAAC;oBA7BvC,CA6BuC;oBACxCC,KAAK,EAAE,aAAG;sBAAI,eAAQ,CAACA,KAAK,CAACuJ,GAAG,CAAC;oBAAnB,CAAmB;oBACjC2C,QAAQ,EAAE;sBAAM,eAAQ,CAACA,QAAQ,EAAE;oBAAnB;mBAChB,CAAC;;;;;SACH,EAAE,6CAA6C,CAAC,CAChDxC,KAAK,CAAC9B,KAAI,CAAC+B,kBAAkB,CAAC,qBAAqB,CAAC,CAAC,CACrDD,KAAK,CAAC,eAAK;UACXuC,QAAQ,CAACjM,KAAK,CAACA,KAAK,CAAC;QACtB,CAAC,CAAC;QAEH;QACA;QACA;QACA,OAAO4H,KAAI,CAACR,gBAAgB,CAAC+E,UAAU,CAAC;UAAA;;cACvC,IAAIR,MAAM,EAAE;gBACXA,MAAM,CAACS,WAAW,EAAE;;;;;SAErB,EAAE,6BAA6B,CAAC;MAClC,CAAC,CAAC;IACH,CAAC;IAED,iBAAY,GAMR,UACH3N,KAAoC,EACpC4N,QAA0D,EAC1DC,OAAgC;MAEhC,OAAO,IAAIjT,UAAU,CAAuB,kBAAQ;QACnD,IAAMkT,KAAK,GAAG,IAAIjO,GAAG,EAAa;QAClC,IAAMkO,YAAY,GAAG,IAAIlO,GAAG,EAAa;QACzC,IAAImO,cAAc,GAAa,EAAE;QACjC,IAAId,MAAkC;QACtC,IAAI3B,SAA4B;QAEhC;;;;;;;;;;QAUA,IAAM0C,uBAAuB,GAAG;UAC/B,IAAMC,QAAQ,GAAGC,gBAAgB,EAAE;UACnCC,YAAY,CAACF,QAAQ,CAAC;QACvB,CAAC;QAED;QACA;QACA,IAAMG,cAAc,GAAG,IAAI5R,wBAAwB,CAAC;UACnD6R,QAAQ,EAAEL,uBAAuB;UACjCnE,YAAY,EAAE0D,QAAQ,CAACjM,KAAK;UAC5BgN,WAAW,EAAE;SACb,CAAC;QAEM,+BAAI;QACZ,IAAMC,WAAW,GAAG3C,IAAI,GAAG;UAAEA,IAAI;QAAA,CAAE,GAAGlN,SAAS;QAE/C,IAAMgD,eAAe,GAAGjE,kBAAkB,CAACsC,KAAK,CAAC;QACjD,IAAMqL,SAAS,GAAG3O,2BAA2B,CAACiF,eAAe,CAAC;QAE9D,IAAIoF,UAAU,CAAC6G,QAAQ,CAAC,EAAE;UACzBrC,SAAS,GAAGvQ,qBAAqB,CAACwQ,oBAAoB,CACrD7J,eAAe,EACf0J,SAAS,CAAC,CAAC,CAAC,EACZuC,QAAQ,CACR;SACD,MAAM;UACN,IAAI7S,eAAe,CAAC6S,QAAQ,CAAC,EAAE;YAC9B;YACArC,SAAS,GAAG5M,SAAS;WACrB,MAAM;YACN4M,SAAS,GAAGvQ,qBAAqB,CAAC6M,kBAAkB,CACnDlG,eAAe,EACfiM,QAAQ,CACR;;;QAIG,oEACsD;UADpDa,0BAAU;UAAEC,4BACwC;QAC5D,IAAMC,YAAY,GAAG,CAAC,CAACF,UAAU;QAEjCtF,KAAI,CAACR,gBAAgB,CACnBrG,GAAG,CAAC;UAAA;;;;;;;kBAGF,qBAAM,IAAI,CAACsF,KAAK,CAAC5H,KAAK,EAAE4N,QAAQ,EAAEY,WAAW,CAAC;;kBAD/C;kBACCnP,SAA8C,CAAEI,OAAO,CAAC,cAAI;oBAC5D,IAAMmP,mBAAmB,GAAGlR,kBAAkB,CAACsC,KAAK,CAAC;oBACrD,IAAM6O,MAAM,GAAG7R,kBAAkB,CAAC4R,mBAAmB,EAAExK,IAAI,CAAC;oBAC5D0J,KAAK,CAACtN,GAAG,CAACqO,MAAM,EAAEzK,IAAI,CAAC;kBACxB,CAAC,CAAC;kBAEF;kBACA;kBACA;kBACA;kBACA8I,MAAM,GAAG,IAAI,CAACJ,OAAO,CAAC9M,KAAK,CAAC,CAACqK,SAAS,CACrC,UAAChL,EAA0B;wBAAxBiO,oBAAO;sBAAEtN,gBAAK;sBAAEoN,kBAAM;;oBACxB,IAAMwB,mBAAmB,GAAGlR,kBAAkB,CAACsC,KAAK,CAAC;oBACrD,IAAM6O,MAAM,GAAG7R,kBAAkB,CAAC4R,mBAAmB,EAAEtB,OAAO,CAAC;oBAC/D,IACCqB,YAAY,IACZ,CAAC7R,iBAAiB,CAACwQ,OAAO,EAAEoB,kBAAkB,EAAED,UAAU,CAAC,EAC1D;sBACD,IACCrB,MAAM,KAAK,QAAQ,KAClBU,KAAK,CAAC3P,GAAG,CAAC0Q,MAAM,CAAC,IAAId,YAAY,CAAC5P,GAAG,CAAC0Q,MAAM,CAAC,CAAC,EAC9C;wBACD;wBACA;wBACA;wBACA;wBACAb,cAAc,CAACzN,IAAI,CAACsO,MAAM,CAAC;uBAC3B,MAAM;wBACN;wBACA;;;oBAIF;oBACA;oBACA;oBACA;oBACA,IAAIzB,MAAM,KAAK,QAAQ,EAAE;sBACxBY,cAAc,CAACzN,IAAI,CAACsO,MAAM,CAAC;qBAC3B,MAAM;sBACNd,YAAY,CAACvN,GAAG,CAACqO,MAAM,EAAEvB,OAAO,CAAC;;oBAGlC,IAAMwB,QAAQ,eACb3F,KAAI,CAACS,IAAI,0CAAEmF,oBAAoB,CAAC/O,KAAK,oCAAK,KAAK;oBAEhD,IAAM+H,KAAK,GACVgG,YAAY,CAACpN,IAAI,GAAGqN,cAAc,CAAC9H,MAAM,IACzCiD,KAAI,CAAC6F,YAAY;oBAElB,IAAIjH,KAAK,IAAI+G,QAAQ,EAAE;sBACtBT,cAAc,CAACY,OAAO,EAAE;;oBAGzB;oBACAZ,cAAc,CAACjE,KAAK,EAAE;kBACvB,CAAC,CACD;kBAED;kBACA6D,uBAAuB,EAAE;;;;kBAEzBT,QAAQ,CAACjM,KAAK,CAAC2N,KAAG,CAAC;;;;;;;SAEpB,EAAE,gCAAgC,CAAC,CACnCjE,KAAK,CAAC9B,KAAI,CAAC+B,kBAAkB,CAAC,0BAA0B,CAAC,CAAC,CAC1DD,KAAK,CAAC,eAAK;UACXuC,QAAQ,CAACjM,KAAK,CAACA,KAAK,CAAC;QACtB,CAAC,CAAC;QAEH;;;;;;QAMA,IAAM4M,gBAAgB,GAAG;;UACxB,IAAMW,QAAQ,eAAG3F,KAAI,CAACS,IAAI,0CAAEmF,oBAAoB,CAAC/O,KAAK,oCAAK,KAAK;UAChE,IAAMmP,UAAU,YACZjO,KAAK,CAACL,IAAI,CAACiN,KAAK,CAAChO,MAAM,EAAE,CAAC,EAC1BoB,KAAK,CAACL,IAAI,CAACkN,YAAY,CAACjO,MAAM,EAAE,CAAC,CACpC;UAED,IAAI+N,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEhC,IAAI,EAAE;YAClBuD,SAAS,CAACD,UAAU,CAAC;;UAGtBrB,KAAK,CAAC5F,KAAK,EAAE;UACbiH,UAAU,CAAC1P,OAAO,CAAC,cAAI;YACtB,IAAMmP,mBAAmB,GAAGlR,kBAAkB,CAACsC,KAAK,CAAC;YACrD,IAAM6O,MAAM,GAAG7R,kBAAkB,CAAC4R,mBAAmB,EAAExK,IAAI,CAAC;YAC5D0J,KAAK,CAACtN,GAAG,CAACqO,MAAM,EAAEzK,IAAI,CAAC;UACxB,CAAC,CAAC;UAEF;UACA4J,cAAc,CAACvO,OAAO,CAAC,gBAAM;YAAI,YAAK,CAAC0B,MAAM,CAAC0N,MAAM,CAAC;UAApB,CAAoB,CAAC;UAEtD,OAAO;YACNf,KAAK,EAAE5M,KAAK,CAACL,IAAI,CAACiN,KAAK,CAAChO,MAAM,EAAE,CAAC;YACjCgP,QAAQ;WACR;QACF,CAAC;QAED;;;;;;;;QAQA,IAAMV,YAAY,GAAG,UAACF,QAA8B;UACnD;UACA;UACAV,QAAQ,CAAClD,IAAI,CAAC4D,QAAQ,CAAC;UAEvB;UACAH,YAAY,CAAC7F,KAAK,EAAE;UACpB8F,cAAc,GAAG,EAAE;QACpB,CAAC;QAED;;;;;;QAMA,IAAMoB,SAAS,GAAG,UAACC,WAAgB;UAClC,IAAM1N,eAAe,GAAGjE,kBAAkB,CAACsC,KAAK,CAAC;UACjD,IAAM0L,UAAU,GAAGvC,KAAI,CAACwC,iBAAiB,CAAChK,eAAe,EAAEkM,OAAO,CAAC;UAEnE,IAAMyB,cAAc,GAAGrU,yBAAyB,CAAC2Q,aAAa,CAC7DF,UAAU,CAACG,IAAI,CACf;UAED,IAAIyD,cAAc,CAACpJ,MAAM,EAAE;YAC1B,IAAMqJ,SAAS,GAAG/S,mBAAmB,CAAC8S,cAAc,CAAC;YACrDD,WAAW,CAACxD,IAAI,CAAC0D,SAAS,CAAC;;QAE7B,CAAC;QAED;;;;;;;;QAQA,IAAMC,WAAW,GAAG,UAACnQ,EAAW;cAAToQ,oBAAO;;UACrB,yBAAK;YAAElF,mBAAI;UACnB,IACCM,KAAK,KAAKzP,cAAc,CAACsU,wBAAwB,IACjD,WAAI,aAAJnF,IAAI,uBAAJA,IAAI,CAAEvK,KAAK,0CAAEhC,IAAI,MAAKgC,KAAK,CAAChC,IAAI,EAC/B;YACDiQ,uBAAuB,EAAE;YACzB9T,GAAG,CAACwV,MAAM,CAAC,WAAW,EAAEH,WAAW,CAAC;;QAEtC,CAAC;QACDrV,GAAG,CAACyV,MAAM,CAAC,WAAW,EAAEJ,WAAW,CAAC;QAEpC,OAAOrG,KAAI,CAACR,gBAAgB,CAAC+E,UAAU,CAAC;UAAA;;cACvC,IAAIR,MAAM,EAAE;gBACXA,MAAM,CAACS,WAAW,EAAE;;;;;SAErB,EAAE,gCAAgC,CAAC;MACrC,CAAC,CAAC;IACH,CAAC;IAED,cAAS,GAAG,UAAC5C,MAA4B;MAA5B;QAAAA,WAA4B;MAAA;MACxC5B,KAAI,CAACa,cAAc,CAAClQ,IAAI,GAAGqP,KAAI,CAACrP,IAAI;MACpCqP,KAAI,CAACa,cAAc,CAACnQ,GAAG,GAAGsP,KAAI,CAACtP,GAAG;MAClCsP,KAAI,CAACa,cAAc,CAACjQ,KAAK,GAAGoP,KAAI,CAACpP,KAAK;MAGrC,sCAA0B;QAC1B8V,wDAAgD;QAChDC,8CAAsC;QACtCC,wCAAgC;QAChCC,gDAAwC;QACxCC,wCAAgC;QAChCC,gDAAwC;QACxCC,8CAAsC;QACtCC,0CAAkC;QAClCC,4CAAoC;QACpCC,0NAAoB;MAGrBnH,KAAI,CAACM,aAAa,yBACd6G,iBAAiB,GACjBnH,KAAI,CAACM,aAAa,CACrB;MAEDN,KAAI,CAACU,eAAe,GAAGV,KAAI,CAACoH,kBAAkB,CAACxF,MAAM,CAAC;MACtD5B,KAAI,CAACW,YAAY,GAAGX,KAAI,CAACqH,eAAe,CAACzF,MAAM,CAAC;MAEhD,IAAM0F,oBAAoB,GACxBrE,eAAe,IAAIA,eAAe,CAACqE,oBAAoB,IACxDZ,0BAA0B,IAC1BpU,oBAAoB,CAACiV,OAAO;MAE7B,QAAQD,oBAAoB;QAC3B,KAAKhV,oBAAoB,CAACkV,UAAU;UACnCxH,KAAI,CAACY,gBAAgB,GAAGjP,iBAAiB,CAACqO,KAAI,CAACa,cAAc,CAAC;UAC9D;QACD,KAAKvO,oBAAoB,CAACiV,OAAO;UAChCvH,KAAI,CAACY,gBAAgB,GAAGlP,mBAAmB;UAC3C;QACD;UACCsO,KAAI,CAACY,gBAAgB,GAAGlP,mBAAmB;UAC3C;MAAM;MAGR;MACAsO,KAAI,CAACM,aAAa,CAACmH,aAAa,GAC9BxE,eAAe,IAAIA,eAAe,CAACwE,aAAa,IAAKR,mBAAmB;MAE1EjH,KAAI,CAAC0H,eAAe,GAClBzE,eAAe,IAAIA,eAAe,CAACyE,eAAe,IACnDV,qBAAqB,IACrBhH,KAAI,CAAC0H,eAAe;MAErB1H,KAAI,CAAC2H,gBAAgB,GACnB1E,eAAe,IAAIA,eAAe,CAAC0E,gBAAgB,IACpDd,sBAAsB,IACtB7G,KAAI,CAAC2H,gBAAgB,IACrB,KAAK;MAEN;MACA3H,KAAI,CAACM,aAAa,CAACqH,gBAAgB,GAAG3H,KAAI,CAAC2H,gBAAgB;MAE3D3H,KAAI,CAAC6F,YAAY,GACf5C,eAAe,IAAIA,eAAe,CAAC4C,YAAY,IAChDiB,kBAAkB,IAClB9G,KAAI,CAAC6F,YAAY,IACjB,IAAI;MAEL;MACA7F,KAAI,CAACM,aAAa,CAACuF,YAAY,GAAG7F,KAAI,CAAC6F,YAAY;MAEnD7F,KAAI,CAACgB,gBAAgB,GACnBiC,eAAe,IAAIA,eAAe,CAACjC,gBAAgB,IACpD+F,sBAAsB,IACtB/G,KAAI,CAACgB,gBAAgB,IACrB,EAAE,GAAG,EAAE,CAAC,CAAC;MAEVhB,KAAI,CAACG,cAAc,GACjB8C,eAAe,IAAIA,eAAe,CAAC9C,cAAc,IAClD+G,oBAAoB,IACpBlH,KAAI,CAACG,cAAc,IACnB3K,SAAS;MAEVwK,KAAI,CAACI,SAAS,GAAGJ,KAAI,CAAC4H,iBAAiB,EAAG;IAC3C,CAAC;EA4OF;EA1qCCC,iCAAa,GAAb;IACC,OAAO,WAAW;EACnB,CAAC;EAED;;;;;;;EAOAA,sCAAkB,GAAlB,UAAmBC,SAAiB;IAApC;IACC;;;;;;IAMA,IAAMC,OAAO,GAAG,UAACpG,GAAU;MAC1B,IAAIA,GAAG,CAACxJ,OAAO,CAAC6P,UAAU,CAAC,+BAA+B,CAAC,EAAE;QAC5D,MAAM,IAAIvQ,KAAK,CACd,CACC,4CAA2CqQ,SAAS,gCAA2B9H,KAAI,CAACP,KAAK,QAAI,EAC7F,iFAA6E,EAC7E,kEAAkE,EAClE,iEAAiE,CACjE,CAAC9E,IAAI,CAAC,IAAI,CAAC,CACZ;OACD,MAAM;QACN,MAAMgH,GAAG;;IAEX,CAAC;IAED,OAAOoG,OAAO;EACf,CAAC;EA85BD;;;;;;;;EAQMF,yBAAK,GAAX;;;;;YACC3P,sBAAsB,EAAE;YACxB,IAAI,CAACuH,KAAK,GAAGH,cAAc,CAAC2I,QAAQ;YACpC,qBAAM,IAAI,CAACzI,gBAAgB,CAAC0I,KAAK,EAAE;;YAAnChS,SAAmC;kBAC/B,IAAI,CAACmI,OAAO,KAAK7I,SAAS,GAA1B;YACH;YACA,IAAI,CAAC6I,OAAO,GAAG,IAAIrM,OAAO,CACzBmC,MAAM,EACNc,iBAAiB,EACjBiJ,8BAA8B,EAC9BjF,oBAAoB,EACpB,IAAI,CAACkH,cAAc,EACnB,IAAI,CAACC,SAAS,CACd;YACD,qBAAM,IAAI,CAAC/B,OAAO,CAACnF,IAAI,EAAE;;YAAzBhD,SAAyB;;;YAG1B,IAAIgJ,gBAAgB,IAAI,CAACA,gBAAgB,CAACiJ,MAAM,EAAE;cACjDjJ,gBAAgB,CAACsF,WAAW,EAAE;;iBAG3B,IAAI,CAAC/D,IAAI,EAAT;YACH,qBAAM,IAAI,CAACA,IAAI,CAAC2H,IAAI,EAAE;;YAAtBlS,SAAsB;;;YAGvB,qBAAM,IAAI,CAACmI,OAAQ,CAACU,KAAK,EAAE;;YAA3B7I,SAA2B;YAE3B,IAAI,CAACyJ,WAAW,GAAGnK,SAAS,CAAC,CAAC;YAC9B,IAAI,CAAC6I,OAAO,GAAG7I,SAAS;YACxB,IAAI,CAACiL,IAAI,GAAGjL,SAAS;YACrB,IAAI,CAACgL,cAAc,GAAG,IAAInM,OAAO,EAAoC;YAErE,qBAAM,IAAI,CAACmL,gBAAgB,CAAC6I,IAAI,EAAE;;YAAlCnS,SAAkC;YAClC,IAAI,CAACuJ,KAAK,GAAGH,cAAc,CAACC,UAAU;;;;;GACtC;EAED;;;;;;EAMMsI,wBAAI,GAAV;;;;;YACC,IAAI,CAACpI,KAAK,GAAGH,cAAc,CAACgJ,QAAQ;YAEpC,qBAAM,IAAI,CAAC9I,gBAAgB,CAAC0I,KAAK,EAAE;;YAAnChS,SAAmC;YAEnC,IAAIgJ,gBAAgB,IAAI,CAACA,gBAAgB,CAACiJ,MAAM,EAAE;cACjDjJ,gBAAgB,CAACsF,WAAW,EAAE;;iBAG3B,IAAI,CAAC/D,IAAI,EAAT;YACH,qBAAM,IAAI,CAACA,IAAI,CAAC2H,IAAI,EAAE;;YAAtBlS,SAAsB;;;YAGvB,IAAI,CAACyJ,WAAW,GAAGnK,SAAS,CAAC,CAAC;YAC9B,IAAI,CAACiL,IAAI,GAAGjL,SAAS;YACrB,qBAAM,IAAI,CAACgK,gBAAgB,CAAC6I,IAAI,EAAE;;YAAlCnS,SAAkC;YAClC,IAAI,CAACuJ,KAAK,GAAGH,cAAc,CAACC,UAAU;;;;;GACtC;EAED;;;;;;;EAOQsI,qCAAiB,GAAzB,UACCrP,eAA4B,EAC5ByJ,kBAA8C;IAE9C,IAAIsG,aAA+B;IAC7B,iCAAgD;MAA9C3J,gBAAK;MAAED,cAAI;MAAE+D,cAAiC;IAEtD,IAAI9D,KAAK,KAAKpJ,SAAS,IAAImJ,IAAI,KAAKnJ,SAAS,IAAIkN,IAAI,KAAKlN,SAAS,EAAE;MACpE,OAAOA,SAAS;;IAGjB,IAAImJ,IAAI,KAAKnJ,SAAS,IAAIoJ,KAAK,KAAKpJ,SAAS,EAAE;MAC9C,MAAM,IAAIiC,KAAK,CAAC,0CAA0C,CAAC;;IAG5D,IAAIkH,IAAI,KAAKnJ,SAAS,EAAE;MACvB,IAAI,OAAOmJ,IAAI,KAAK,QAAQ,EAAE;QAC7B,MAAM,IAAIlH,KAAK,CAAC,yBAAyB,CAAC;;MAG3C,IAAIkH,IAAI,GAAG,CAAC,EAAE;QACb,MAAM,IAAIlH,KAAK,CAAC,wBAAwB,CAAC;;;IAI3C,IAAImH,KAAK,KAAKpJ,SAAS,EAAE;MACxB,IAAI,OAAOoJ,KAAK,KAAK,QAAQ,EAAE;QAC9B,MAAM,IAAInH,KAAK,CAAC,0BAA0B,CAAC;;MAG5C,IAAImH,KAAK,GAAG,CAAC,EAAE;QACd,MAAM,IAAInH,KAAK,CAAC,yBAAyB,CAAC;;;IAI5C,IAAIiL,IAAI,EAAE;MACT6F,aAAa,GAAGzW,yBAAyB,CAAC4M,kBAAkB,CAC3DlG,eAAe,EACfyJ,kBAAkB,CAACS,IAAI,CACvB;;IAGF,OAAO;MACN9D,KAAK;MACLD,IAAI;MACJ+D,IAAI,EAAE6F;KACN;EACF,CAAC;EAED;;;;EAIcV,0CAAsB,GAApC;;;;;;;YAGC,IAAI,CAAC,IAAI,CAACH,eAAe,IAAI,CAAC,IAAI,CAACA,eAAe,CAAC3K,MAAM,EAAE;cAC1D,sBAAO,IAAI1I,OAAO,EAAoC;;YAGhC,qBAAMwL,OAAO,CAAC2I,GAAG,CACvC,IAAI,CAACd,eAAe,CAAChN,GAAG,CACvB,UACC+N,cAA8B;cAAA;;;;;sBAEkB,qBAAMA,cAAc;;sBAA9DvS,KAA0CqC,SAAoB,EAA5D/D,gBAAgB,wBAAEkU,iBAAiB;sBACrClQ,eAAe,GAAGjE,kBAAkB,CAACC,gBAAgB,CAAC;sBAI1C,qBAAM,IAAI,CAACmU,aAAa,CAACD,iBAAiB,CAAC;;sBAAvD9F,SAAS,GAAGrK,SAA2C;sBAC7D,IAAI3G,eAAe,CAACgR,SAAS,CAAC,EAAE;wBAC/B,sBAAO,CAACpK,eAAe,EAAE,IAAI,CAAC;;sBAGzB4J,SAAS,GAAG,IAAI,CAACwG,mBAAmB,CACzCpQ,eAAe,EACfoK,SAAS,CACT;sBAED,sBAAO,CAACpK,eAAe,EAAE4J,SAAS,CAAC;kBAAC;;;aACpC,CACD,CACD;;YAvBK5B,cAAc,GAAGtK,SAuBtB;YAED,sBAAO,IAAI,CAAC2S,kBAAkB,CAACrI,cAAc,CAAC;QAAC;;;GAC/C;EAEOqH,uCAAmB,GAA3B,UACCrP,eAA4B,EAC5BoK,SAAkD;IAElD,IAAI;MACH,OAAO/Q,qBAAqB,CAAC6M,kBAAkB,CAC9ClG,eAAe,EACfoK,SAAS,CACT;KACD,CAAC,OAAOxK,KAAK,EAAE;MACftE,MAAM,CAACsE,KAAK,CAAC,+BAA+B,CAAC;MAC7C,MAAMA,KAAK;;EAEb,CAAC;EAEayP,iCAAa,GAA3B,UACCa,iBAAiB;;;;;;;YAGE,qBAAMA,iBAAiB,EAAE;;YAArC9F,SAAS,GAAG1M,SAAyB;YAC3C,sBAAO0M,SAAS;;;YAEhB,IAAIkG,OAAK,YAAYC,SAAS,EAAE;cAC/B,sBAAOL,iBAAiB;;YAEzB,MAAMI,OAAK;;;;;;GAEZ;;EAEOjB,sCAAkB,GAA1B,UACCvP,OAA6C;IAE7C,OAAOA,OAAO,CAAC0Q,MAAM,CAAC,UAACtO,GAAG,EAAExE,EAA4B;UAA5BqC,kBAA4B;QAA3BC,uBAAe;QAAE4J,iBAAS;MACtD,IAAI1H,GAAG,CAAC1F,GAAG,CAACwD,eAAe,CAAC,EAAE;QACrB,iCAAI;QACZ1E,MAAM,CAAC4B,IAAI,CACV,wGAC2CuT,MAAI,4BAAyB,CACxE;QACD,OAAOvO,GAAG;;MAGX,IAAI0H,SAAS,EAAE;QACd1H,GAAG,CAACrD,GAAG,CAACmB,eAAe,EAAE4J,SAAS,CAAC;;MAGpC,OAAO1H,GAAG;IACX,CAAC,EAAE,IAAIrG,OAAO,EAAoC,CAAC;EACpD,CAAC;EAED;;;;EAIQwT,qCAAiB,GAAzB;IACC,IAAI;MACH,IAAMzH,SAAS,GAAG8I,cAAc,CAACC,OAAO,CAAC,oBAAoB,CAAC;MAE9D,IAAI/I,SAAS,EAAE;QACN,gFAA2B;QAEnC,IAAMgJ,UAAU,GAAG/I,2BAA2B,CAACgJ,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QACtD,yCAAmC;UAAlCC,iBAAkC;QAEzC,OAAUlJ,SAAS,SAAIkJ,SAAW;;KAEnC,CAAC,WAAM;IAER,OAAO9T,SAAS;EACjB,CAAC;EACF,gBAAC;AAAD,CAAC,EAlvCD;AAovCA,IAAMiG,QAAQ,GAAG,IAAIoM,SAAS,EAAE;AAChChX,OAAO,CAAC0Y,QAAQ,CAAC9N,QAAQ,CAAC;AAE1B,SAASoM,SAAS,IAAI2B,cAAc,EAAElU,UAAU,EAAEmG,QAAQ,IAAIoM,SAAS","names":["API","Auth","Cache","Amplify","ConsoleLogger","Logger","Hub","JS","BackgroundProcessManager","immerable","produce","setAutoFreeze","enablePatches","v4","uuid4","Observable","defaultAuthStrategy","multiAuthStrategy","isPredicatesAll","ModelPredicateCreator","ModelSortPredicateCreator","ExclusiveStorage","Storage","ControlMessage","SyncEngine","GraphQLScalarType","isGraphQLScalarType","isSchemaModelWithAttributes","AuthModeStrategyType","isNonModelFieldType","isModelFieldType","isIdentifierObject","DATASTORE","errorMessages","establishRelationAndKeys","exhaustiveCheck","isModelConstructor","monotonicUlidFactory","STORAGE","SYNC","USER","isNullOrUndefined","registerNonModelClass","sortCompareFunction","DeferredCallbackResolver","extractPrimaryKeyFieldNames","extractPrimaryKeysAndValues","isIdManaged","isIdOptionallyManaged","validatePredicate","mergePatches","getIdentifierValue","logger","ulid","Date","now","SETTING_SCHEMA_VERSION","schema","modelNamespaceMap","WeakMap","modelPatchesMap","getModelDefinition","modelConstructor","namespace","get","namespaces","models","name","isValidModelConstructor","obj","has","namespaceResolver","syncClasses","userClasses","dataStoreClasses","storageClasses","initSchema","userSchema","undefined","console","warn","log","internalUserNamespace","createTypeClasses","dataStoreNamespace","getNamespace","storageNamespace","syncNamespace","_a","version","Object","keys","forEach","relations","relationships","modelAssociations","Map","values","connectedModels","model","fields","filter","association","field","connectionType","type","push","set","result","count","size","Error","from","modelName","parents","every","x","Array","delete","modelTopologicalOrdering","checkSchemaInitialized","message","error","classes","entries","_b","modelDefinition","clazz","createModelClass","nonModels","typeName","typeDefinition","createNonModelClass","instancesMetadata","WeakSet","modelInstanceCreator","init","add","validateModelFields","k","v","fieldDefinition","isRequired_1","isArrayNullable","name_1","isArray","includes","idEmptyString","value","type_1","jsType_1","getJSType","validateScalar_1","getValidationFunction","JSON","parse","errorTypeText","some","e","elemTypes","map","join","validationStatus","subNonModelDefinition_1","user","nonModel","modelValidator_1","item","subKey","castInstanceType","Boolean","initializeInstance","draft","modelValidator","parsedValue","instance","isInternallyInitialized","modelInstanceMetadata","isInternalModel","_id","id","syncable","checkReadOnlyPropertyOnCreate","_lastChangedAt","_deleted","_version","Model","source","fn","getPrototypeOf","constructor","msg","patches","keyNames","key","p","hasExistingPatches","length","existingPatches","existingSource","mergedPatches","checkReadOnlyPropertyOnUpdate","json","fromJSON","defineProperty","modelKeys","isReadOnly","patchArray","path","val","isQueryOne","defaultConflictHandler","conflictData","remoteModel","localModel","defaultErrorHandler","getModelConstructorByModelName","namespaceName","checkSchemaVersion","storage","Setting","runExclusive","s","query","createFromExisting","page","limit","schemaVersionSetting","storedValue","clear","save","stringify","syncSubscription","enums","pluralName","isRequired","DataStoreState","NotRunning","runningProcesses","state","Starting","initialized","debug","Promise","res","rej","_this","initResolve","initReject","storageAdapter","sessionId","aws_appsync_graphqlEndpoint","amplifyConfig","processSyncExpressions","syncPredicates","sync","conflictHandler","errorHandler","authModeStrategy","amplifyContext","connectivityMonitor","fullSyncIntervalInMilliseconds","fullSyncInterval","start","subscribe","next","data","readyType","isNode","SYNC_ENGINE_SYNC_QUERIES_READY","SYNC_ENGINE_STORAGE_SUBSCRIBED","dispatch","event","err","config","Running","catch","handleAddProcError","identifierOrCriteria","paginationProducer","keyFields","queryByPkWithCompositeKeyPresent","predicate","createForSingleField","createForPk","pagination","processPagination","getPredicates","sort","returnOne","condition","patchesTuple","producedCondition","savedModel","conflictHandlerIsDefault","configDataStore","errorHandlerIsDefault","modelOrConstructor","_d","deleteByPkWithCompositeKeyPresent","isValidPredicate","deleted","pkPredicate","_c","modelConstructor_1","observe","observeWithObjectLiteral","objectLiteral","keyField","handle","isOpen","opType","primaryKeysAndValues","element","freshElement","observer","complete","addCleaner","unsubscribe","criteria","options","items","itemsChanged","deletedItemIds","generateAndEmitSnapshot","snapshot","generateSnapshot","emitSnapshot","limitTimerRace","callback","maxInterval","sortOptions","predicates","predicateGroupType","hasPredicate","itemModelDefinition","idOrPk","isSynced","getModelSyncedStatus","syncPageSize","resolve","err_1","itemsArray","sortItems","itemsToSort","sortPredicates","compareFn","hubCallback","payload","SYNC_ENGINE_MODEL_SYNCED","remove","listen","configAuthModeStrategyType","configConflictHandler","configErrorHandler","configMaxRecordsToSync","configSyncPageSize","configFullSyncInterval","configSyncExpressions","configAuthProviders","configStorageAdapter","configFromAmplify","setConflictHandler","setErrorHandler","authModeStrategyType","DEFAULT","MULTI_AUTH","authProviders","syncExpressions","maxRecordsToSync","retrieveSessionId","DataStore","operation","handler","startsWith","Clearing","close","closed","stop","open","Stopping","sortPredicate","all","syncExpression","conditionProducer","unwrapPromise","createFromCondition","weakMapFromEntries","error_1","TypeError","reduce","name_2","sessionStorage","getItem","appSyncUrl","split","appSyncId","register","DataStoreClass"],"sources":["C:\\Users\\weida\\Desktop\\playground_CC\\node_modules\\@aws-amplify\\datastore\\src\\datastore\\datastore.ts"],"sourcesContent":["import API from '@aws-amplify/api';\nimport { Auth } from '@aws-amplify/auth';\nimport Cache from '@aws-amplify/cache';\nimport {\n\tAmplify,\n\tConsoleLogger as Logger,\n\tHub,\n\tJS,\n\tBackgroundProcessManager,\n} from '@aws-amplify/core';\nimport {\n\tDraft,\n\timmerable,\n\tproduce,\n\tsetAutoFreeze,\n\tenablePatches,\n\tPatch,\n} from 'immer';\nimport { v4 as uuid4 } from 'uuid';\nimport Observable, { ZenObservable } from 'zen-observable-ts';\nimport { defaultAuthStrategy, multiAuthStrategy } from '../authModeStrategies';\nimport {\n\tisPredicatesAll,\n\tModelPredicateCreator,\n\tModelSortPredicateCreator,\n\tPredicateAll,\n} from '../predicates';\nimport { Adapter } from '../storage/adapter';\nimport { ExclusiveStorage as Storage } from '../storage/storage';\nimport { ControlMessage, SyncEngine } from '../sync';\nimport {\n\tAuthModeStrategy,\n\tConflictHandler,\n\tDataStoreConfig,\n\tGraphQLScalarType,\n\tInternalSchema,\n\tisGraphQLScalarType,\n\tisSchemaModelWithAttributes,\n\tModelFieldType,\n\tModelInit,\n\tModelInstanceMetadata,\n\tModelPredicate,\n\tSortPredicate,\n\tMutableModel,\n\tNamespaceResolver,\n\tNonModelTypeConstructor,\n\tProducerPaginationInput,\n\tPaginationInput,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tProducerModelPredicate,\n\tSchema,\n\tSchemaModel,\n\tSchemaNamespace,\n\tSchemaNonModel,\n\tSubscriptionMessage,\n\tDataStoreSnapshot,\n\tSyncConflict,\n\tSyncError,\n\tTypeConstructorMap,\n\tErrorHandler,\n\tSyncExpression,\n\tAuthModeStrategyType,\n\tisNonModelFieldType,\n\tisModelFieldType,\n\tObserveQueryOptions,\n\tManagedIdentifier,\n\tPersistentModelMetaData,\n\tIdentifierFieldOrIdentifierObject,\n\tisIdentifierObject,\n\tAmplifyContext,\n} from '../types';\n// tslint:disable:no-duplicate-imports\nimport type { __modelMeta__ } from '../types';\n\nimport {\n\tDATASTORE,\n\terrorMessages,\n\testablishRelationAndKeys,\n\texhaustiveCheck,\n\tisModelConstructor,\n\tmonotonicUlidFactory,\n\tNAMESPACES,\n\tSTORAGE,\n\tSYNC,\n\tUSER,\n\tisNullOrUndefined,\n\tregisterNonModelClass,\n\tsortCompareFunction,\n\tDeferredCallbackResolver,\n\textractPrimaryKeyFieldNames,\n\textractPrimaryKeysAndValues,\n\tisIdManaged,\n\tisIdOptionallyManaged,\n\tvalidatePredicate,\n\tmergePatches,\n} from '../util';\nimport { getIdentifierValue } from '../sync/utils';\nimport DataStoreConnectivity from '../sync/datastoreConnectivity';\n\nsetAutoFreeze(true);\nenablePatches();\n\nconst logger = new Logger('DataStore');\n\nconst ulid = monotonicUlidFactory(Date.now());\nconst { isNode } = JS.browserOrNode();\n\ntype SettingMetaData = {\n\tidentifier: ManagedIdentifier<Setting, 'id'>;\n\treadOnlyFields: never;\n};\ndeclare class Setting {\n\tpublic readonly [__modelMeta__]: SettingMetaData;\n\tconstructor(init: ModelInit<Setting, SettingMetaData>);\n\tstatic copyOf(\n\t\tsrc: Setting,\n\t\tmutator: (draft: MutableModel<Setting, SettingMetaData>) => void | Setting\n\t): Setting;\n\tpublic readonly id: string;\n\tpublic readonly key: string;\n\tpublic readonly value: string;\n}\n\nconst SETTING_SCHEMA_VERSION = 'schemaVersion';\n\nlet schema: InternalSchema;\nconst modelNamespaceMap = new WeakMap<\n\tPersistentModelConstructor<any>,\n\tstring\n>();\n// stores data for crafting the correct update mutation input for a model\n// Patch[] - array of changed fields and metadata\n// PersistentModel - the source model, used for diffing object-type fields\nconst modelPatchesMap = new WeakMap<\n\tPersistentModel,\n\t[Patch[], PersistentModel]\n>();\n\nconst getModelDefinition = (\n\tmodelConstructor: PersistentModelConstructor<any>\n) => {\n\tconst namespace = modelNamespaceMap.get(modelConstructor);\n\n\treturn schema.namespaces[namespace].models[modelConstructor.name];\n};\n\nconst isValidModelConstructor = <T extends PersistentModel>(\n\tobj: any\n): obj is PersistentModelConstructor<T> => {\n\treturn isModelConstructor(obj) && modelNamespaceMap.has(obj);\n};\n\nconst namespaceResolver: NamespaceResolver = modelConstructor =>\n\tmodelNamespaceMap.get(modelConstructor);\n\n// exporting syncClasses for testing outbox.test.ts\nexport let syncClasses: TypeConstructorMap;\nlet userClasses: TypeConstructorMap;\nlet dataStoreClasses: TypeConstructorMap;\nlet storageClasses: TypeConstructorMap;\n\nconst initSchema = (userSchema: Schema) => {\n\tif (schema !== undefined) {\n\t\tconsole.warn('The schema has already been initialized');\n\n\t\treturn userClasses;\n\t}\n\n\tlogger.log('validating schema', { schema: userSchema });\n\n\tconst internalUserNamespace: SchemaNamespace = {\n\t\tname: USER,\n\t\t...userSchema,\n\t};\n\n\tlogger.log('DataStore', 'Init models');\n\tuserClasses = createTypeClasses(internalUserNamespace);\n\tlogger.log('DataStore', 'Models initialized');\n\n\tconst dataStoreNamespace = getNamespace();\n\tconst storageNamespace = Storage.getNamespace();\n\tconst syncNamespace = SyncEngine.getNamespace();\n\n\tdataStoreClasses = createTypeClasses(dataStoreNamespace);\n\tstorageClasses = createTypeClasses(storageNamespace);\n\tsyncClasses = createTypeClasses(syncNamespace);\n\n\tschema = {\n\t\tnamespaces: {\n\t\t\t[dataStoreNamespace.name]: dataStoreNamespace,\n\t\t\t[internalUserNamespace.name]: internalUserNamespace,\n\t\t\t[storageNamespace.name]: storageNamespace,\n\t\t\t[syncNamespace.name]: syncNamespace,\n\t\t},\n\t\tversion: userSchema.version,\n\t};\n\n\tObject.keys(schema.namespaces).forEach(namespace => {\n\t\tconst [relations, keys] = establishRelationAndKeys(\n\t\t\tschema.namespaces[namespace]\n\t\t);\n\n\t\tschema.namespaces[namespace].relationships = relations;\n\t\tschema.namespaces[namespace].keys = keys;\n\n\t\tconst modelAssociations = new Map<string, string[]>();\n\n\t\tObject.values(schema.namespaces[namespace].models).forEach(model => {\n\t\t\tconst connectedModels: string[] = [];\n\n\t\t\tObject.values(model.fields)\n\t\t\t\t.filter(\n\t\t\t\t\tfield =>\n\t\t\t\t\t\tfield.association &&\n\t\t\t\t\t\tfield.association.connectionType === 'BELONGS_TO' &&\n\t\t\t\t\t\t(<ModelFieldType>field.type).model !== model.name\n\t\t\t\t)\n\t\t\t\t.forEach(field =>\n\t\t\t\t\tconnectedModels.push((<ModelFieldType>field.type).model)\n\t\t\t\t);\n\n\t\t\tmodelAssociations.set(model.name, connectedModels);\n\t\t});\n\n\t\tconst result = new Map<string, string[]>();\n\n\t\tlet count = 1000;\n\t\twhile (true && count > 0) {\n\t\t\tif (modelAssociations.size === 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount--;\n\t\t\tif (count === 0) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Models are not topologically sortable. Please verify your schema.'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfor (const modelName of Array.from(modelAssociations.keys())) {\n\t\t\t\tconst parents = modelAssociations.get(modelName);\n\n\t\t\t\tif (parents.every(x => result.has(x))) {\n\t\t\t\t\tresult.set(modelName, parents);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArray.from(result.keys()).forEach(x => modelAssociations.delete(x));\n\t\t}\n\n\t\tschema.namespaces[namespace].modelTopologicalOrdering = result;\n\t});\n\n\treturn userClasses;\n};\n\n/**\n * Throws an exception if the schema has *not* been initialized\n * by `initSchema()`.\n *\n * **To be called before trying to access schema.**\n *\n * Currently this only needs to be called in `start()` and `clear()` because\n * all other functions will call start first.\n */\nconst checkSchemaInitialized = () => {\n\tif (schema === undefined) {\n\t\tconst message =\n\t\t\t'Schema is not initialized. DataStore will not function as expected. This could happen if you have multiple versions of DataStore installed. Please see https://docs.amplify.aws/lib/troubleshooting/upgrading/q/platform/js/#check-for-duplicate-versions';\n\t\tlogger.error(message);\n\t\tthrow new Error(message);\n\t}\n};\n\nconst createTypeClasses: (\n\tnamespace: SchemaNamespace\n) => TypeConstructorMap = namespace => {\n\tconst classes: TypeConstructorMap = {};\n\n\tObject.entries(namespace.models).forEach(([modelName, modelDefinition]) => {\n\t\tconst clazz = createModelClass(modelDefinition);\n\t\tclasses[modelName] = clazz;\n\n\t\tmodelNamespaceMap.set(clazz, namespace.name);\n\t});\n\n\tObject.entries(namespace.nonModels || {}).forEach(\n\t\t([typeName, typeDefinition]) => {\n\t\t\tconst clazz = createNonModelClass(typeDefinition);\n\t\t\tclasses[typeName] = clazz;\n\t\t}\n\t);\n\n\treturn classes;\n};\n\n/**\n * Constructs a model and records it with its metadata in a weakset. Allows for\n * the separate storage of core model fields and Amplify/DataStore metadata\n * fields that the customer app does not want exposed.\n *\n * @param modelConstructor The model constructor.\n * @param init Init data that would normally be passed to the constructor.\n * @returns The initialized model.\n */\nexport declare type ModelInstanceCreator = typeof modelInstanceCreator;\n\n/**\n * Collection of instantiated models to allow storage of metadata apart from\n * the model visible to the consuming app -- in case the app doesn't have\n * metadata fields (_version, _deleted, etc.) exposed on the model itself.\n */\nconst instancesMetadata = new WeakSet<ModelInit<unknown, unknown>>();\n\nfunction modelInstanceCreator<T extends PersistentModel>(\n\tmodelConstructor: PersistentModelConstructor<T>,\n\tinit: Partial<T>\n): T {\n\tinstancesMetadata.add(init);\n\n\treturn new modelConstructor(<ModelInit<T, PersistentModelMetaData<T>>>init);\n}\n\nconst validateModelFields =\n\t(modelDefinition: SchemaModel | SchemaNonModel) => (k: string, v: any) => {\n\t\tconst fieldDefinition = modelDefinition.fields[k];\n\n\t\tif (fieldDefinition !== undefined) {\n\t\t\tconst { type, isRequired, isArrayNullable, name, isArray } =\n\t\t\t\tfieldDefinition;\n\n\t\t\tif (\n\t\t\t\t((!isArray && isRequired) || (isArray && !isArrayNullable)) &&\n\t\t\t\t(v === null || v === undefined)\n\t\t\t) {\n\t\t\t\tthrow new Error(`Field ${name} is required`);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tisSchemaModelWithAttributes(modelDefinition) &&\n\t\t\t\t!isIdManaged(modelDefinition)\n\t\t\t) {\n\t\t\t\tconst keys = extractPrimaryKeyFieldNames(modelDefinition);\n\t\t\t\tif (keys.includes(k) && v === '') {\n\t\t\t\t\tlogger.error(errorMessages.idEmptyString, { k, value: v });\n\t\t\t\t\tthrow new Error(errorMessages.idEmptyString);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isGraphQLScalarType(type)) {\n\t\t\t\tconst jsType = GraphQLScalarType.getJSType(type);\n\t\t\t\tconst validateScalar = GraphQLScalarType.getValidationFunction(type);\n\n\t\t\t\tif (type === 'AWSJSON') {\n\t\t\t\t\tif (typeof v === jsType) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof v === 'string') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tJSON.parse(v);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tthrow new Error(`Field ${name} is an invalid JSON object. ${v}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isArray) {\n\t\t\t\t\tlet errorTypeText: string = jsType;\n\t\t\t\t\tif (!isRequired) {\n\t\t\t\t\t\terrorTypeText = `${jsType} | null | undefined`;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!Array.isArray(v) && !isArrayNullable) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Field ${name} should be of type [${errorTypeText}], ${typeof v} received. ${v}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t!isNullOrUndefined(v) &&\n\t\t\t\t\t\t(<[]>v).some(e =>\n\t\t\t\t\t\t\tisNullOrUndefined(e) ? isRequired : typeof e !== jsType\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst elemTypes = (<[]>v)\n\t\t\t\t\t\t\t.map(e => (e === null ? 'null' : typeof e))\n\t\t\t\t\t\t\t.join(',');\n\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`All elements in the ${name} array should be of type ${errorTypeText}, [${elemTypes}] received. ${v}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (validateScalar && !isNullOrUndefined(v)) {\n\t\t\t\t\t\tconst validationStatus = (<[]>v).map(e => {\n\t\t\t\t\t\t\tif (!isNullOrUndefined(e)) {\n\t\t\t\t\t\t\t\treturn validateScalar(e);\n\t\t\t\t\t\t\t} else if (isNullOrUndefined(e) && !isRequired) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (!validationStatus.every(s => s)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`All elements in the ${name} array should be of type ${type}, validation failed for one or more elements. ${v}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (!isRequired && v === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (typeof v !== jsType && v !== null) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Field ${name} should be of type ${jsType}, ${typeof v} received. ${v}`\n\t\t\t\t\t);\n\t\t\t\t} else if (\n\t\t\t\t\t!isNullOrUndefined(v) &&\n\t\t\t\t\tvalidateScalar &&\n\t\t\t\t\t!validateScalar(v)\n\t\t\t\t) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Field ${name} should be of type ${type}, validation failed. ${v}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (isNonModelFieldType(type)) {\n\t\t\t\t// do not check non model fields if undefined or null\n\t\t\t\tif (!isNullOrUndefined(v)) {\n\t\t\t\t\tconst subNonModelDefinition =\n\t\t\t\t\t\tschema.namespaces.user.nonModels[type.nonModel];\n\t\t\t\t\tconst modelValidator = validateModelFields(subNonModelDefinition);\n\n\t\t\t\t\tif (isArray) {\n\t\t\t\t\t\tlet errorTypeText: string = type.nonModel;\n\t\t\t\t\t\tif (!isRequired) {\n\t\t\t\t\t\t\terrorTypeText = `${type.nonModel} | null | undefined`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!Array.isArray(v)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Field ${name} should be of type [${errorTypeText}], ${typeof v} received. ${v}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tv.forEach(item => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t(isNullOrUndefined(item) && isRequired) ||\n\t\t\t\t\t\t\t\t(typeof item !== 'object' && typeof item !== 'undefined')\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t`All elements in the ${name} array should be of type ${\n\t\t\t\t\t\t\t\t\t\ttype.nonModel\n\t\t\t\t\t\t\t\t\t}, [${typeof item}] received. ${item}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!isNullOrUndefined(item)) {\n\t\t\t\t\t\t\t\tObject.keys(subNonModelDefinition.fields).forEach(subKey => {\n\t\t\t\t\t\t\t\t\tmodelValidator(subKey, item[subKey]);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (typeof v !== 'object') {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Field ${name} should be of type ${\n\t\t\t\t\t\t\t\t\ttype.nonModel\n\t\t\t\t\t\t\t\t}, ${typeof v} recieved. ${v}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tObject.keys(subNonModelDefinition.fields).forEach(subKey => {\n\t\t\t\t\t\t\tmodelValidator(subKey, v[subKey]);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\nconst castInstanceType = (\n\tmodelDefinition: SchemaModel | SchemaNonModel,\n\tk: string,\n\tv: any\n) => {\n\tconst { isArray, type } = modelDefinition.fields[k] || {};\n\t// attempt to parse stringified JSON\n\tif (\n\t\ttypeof v === 'string' &&\n\t\t(isArray ||\n\t\t\ttype === 'AWSJSON' ||\n\t\t\tisNonModelFieldType(type) ||\n\t\t\tisModelFieldType(type))\n\t) {\n\t\ttry {\n\t\t\treturn JSON.parse(v);\n\t\t} catch {\n\t\t\t// if JSON is invalid, don't throw and let modelValidator handle it\n\t\t}\n\t}\n\n\t// cast from numeric representation of boolean to JS boolean\n\tif (typeof v === 'number' && type === 'Boolean') {\n\t\treturn Boolean(v);\n\t}\n\n\treturn v;\n};\n\nconst initializeInstance = <T extends PersistentModel>(\n\tinit: ModelInit<T>,\n\tmodelDefinition: SchemaModel | SchemaNonModel,\n\tdraft: Draft<T & ModelInstanceMetadata>\n) => {\n\tconst modelValidator = validateModelFields(modelDefinition);\n\tObject.entries(init).forEach(([k, v]) => {\n\t\tconst parsedValue = castInstanceType(modelDefinition, k, v);\n\n\t\tmodelValidator(k, parsedValue);\n\t\t(<any>draft)[k] = parsedValue;\n\t});\n};\n\nconst createModelClass = <T extends PersistentModel>(\n\tmodelDefinition: SchemaModel\n) => {\n\tconst clazz = <PersistentModelConstructor<T>>(<unknown>class Model {\n\t\tconstructor(init: ModelInit<T>) {\n\t\t\tconst instance = produce(\n\t\t\t\tthis,\n\t\t\t\t(draft: Draft<T & ModelInstanceMetadata>) => {\n\t\t\t\t\tinitializeInstance(init, modelDefinition, draft);\n\n\t\t\t\t\t// model is initialized inside a DataStore component (e.g. by Sync Engine, Storage Engine, etc.)\n\t\t\t\t\tconst isInternallyInitialized = instancesMetadata.has(init);\n\n\t\t\t\t\tconst modelInstanceMetadata: ModelInstanceMetadata =\n\t\t\t\t\t\tisInternallyInitialized\n\t\t\t\t\t\t\t? <ModelInstanceMetadata>(<unknown>init)\n\t\t\t\t\t\t\t: <ModelInstanceMetadata>{};\n\n\t\t\t\t\ttype ModelWithIDIdentifier = { id: string };\n\n\t\t\t\t\tconst { id: _id } =\n\t\t\t\t\t\tmodelInstanceMetadata as unknown as ModelWithIDIdentifier;\n\n\t\t\t\t\tif (isIdManaged(modelDefinition)) {\n\t\t\t\t\t\tconst isInternalModel = _id !== null && _id !== undefined;\n\n\t\t\t\t\t\tconst id = isInternalModel\n\t\t\t\t\t\t\t? _id\n\t\t\t\t\t\t\t: modelDefinition.syncable\n\t\t\t\t\t\t\t? uuid4()\n\t\t\t\t\t\t\t: ulid();\n\n\t\t\t\t\t\t(<ModelWithIDIdentifier>(<unknown>draft)).id = id;\n\t\t\t\t\t} else if (isIdOptionallyManaged(modelDefinition)) {\n\t\t\t\t\t\t// only auto-populate if the id was not provided\n\t\t\t\t\t\t(<ModelWithIDIdentifier>(<unknown>draft)).id = draft.id || uuid4();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!isInternallyInitialized) {\n\t\t\t\t\t\tcheckReadOnlyPropertyOnCreate(draft, modelDefinition);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { _version, _lastChangedAt, _deleted } = modelInstanceMetadata;\n\n\t\t\t\t\tif (modelDefinition.syncable) {\n\t\t\t\t\t\tdraft._version = _version;\n\t\t\t\t\t\tdraft._lastChangedAt = _lastChangedAt;\n\t\t\t\t\t\tdraft._deleted = _deleted;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t\treturn instance;\n\t\t}\n\n\t\tstatic copyOf(source: T, fn: (draft: MutableModel<T>) => T) {\n\t\t\tconst modelConstructor = Object.getPrototypeOf(source || {}).constructor;\n\t\t\tif (!isValidModelConstructor(modelConstructor)) {\n\t\t\t\tconst msg = 'The source object is not a valid model';\n\t\t\t\tlogger.error(msg, { source });\n\t\t\t\tthrow new Error(msg);\n\t\t\t}\n\n\t\t\tlet patches;\n\t\t\tconst model = produce(\n\t\t\t\tsource,\n\t\t\t\tdraft => {\n\t\t\t\t\tfn(<MutableModel<T>>draft);\n\n\t\t\t\t\tconst keyNames = extractPrimaryKeyFieldNames(modelDefinition);\n\t\t\t\t\t// Keys are immutable\n\t\t\t\t\tkeyNames.forEach(key => ((draft as Object)[key] = source[key]));\n\n\t\t\t\t\tconst modelValidator = validateModelFields(modelDefinition);\n\t\t\t\t\tObject.entries(draft).forEach(([k, v]) => {\n\t\t\t\t\t\tconst parsedValue = castInstanceType(modelDefinition, k, v);\n\n\t\t\t\t\t\tmodelValidator(k, parsedValue);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tp => (patches = p)\n\t\t\t);\n\n\t\t\tconst hasExistingPatches = modelPatchesMap.has(source);\n\n\t\t\tif (patches.length || hasExistingPatches) {\n\t\t\t\tif (hasExistingPatches) {\n\t\t\t\t\tconst [existingPatches, existingSource] = modelPatchesMap.get(source);\n\t\t\t\t\tconst mergedPatches = mergePatches(\n\t\t\t\t\t\texistingSource,\n\t\t\t\t\t\texistingPatches,\n\t\t\t\t\t\tpatches\n\t\t\t\t\t);\n\t\t\t\t\tmodelPatchesMap.set(model, [mergedPatches, existingSource]);\n\t\t\t\t\tcheckReadOnlyPropertyOnUpdate(mergedPatches, modelDefinition);\n\t\t\t\t} else {\n\t\t\t\t\tmodelPatchesMap.set(model, [patches, source]);\n\t\t\t\t\tcheckReadOnlyPropertyOnUpdate(patches, modelDefinition);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn model;\n\t\t}\n\n\t\t// \"private\" method (that's hidden via `Setting`) for `withSSRContext` to use\n\t\t// to gain access to `modelInstanceCreator` and `clazz` for persisting IDs from server to client.\n\t\tstatic fromJSON(json: T | T[]) {\n\t\t\tif (Array.isArray(json)) {\n\t\t\t\treturn json.map(init => this.fromJSON(init));\n\t\t\t}\n\n\t\t\tconst instance = modelInstanceCreator(clazz, json);\n\n\t\t\tconst modelValidator = validateModelFields(modelDefinition);\n\n\t\t\tObject.entries(instance).forEach(([k, v]) => {\n\t\t\t\tmodelValidator(k, v);\n\t\t\t});\n\n\t\t\treturn instance;\n\t\t}\n\t});\n\n\tclazz[immerable] = true;\n\n\tObject.defineProperty(clazz, 'name', { value: modelDefinition.name });\n\n\treturn clazz;\n};\n\nconst checkReadOnlyPropertyOnCreate = <T extends PersistentModel>(\n\tdraft: T,\n\tmodelDefinition: SchemaModel\n) => {\n\tconst modelKeys = Object.keys(draft);\n\tconst { fields } = modelDefinition;\n\n\tmodelKeys.forEach(key => {\n\t\tif (fields[key] && fields[key].isReadOnly) {\n\t\t\tthrow new Error(`${key} is read-only.`);\n\t\t}\n\t});\n};\n\nconst checkReadOnlyPropertyOnUpdate = (\n\tpatches: Patch[],\n\tmodelDefinition: SchemaModel\n) => {\n\tconst patchArray = patches.map(p => [p.path[0], p.value]);\n\tconst { fields } = modelDefinition;\n\n\tpatchArray.forEach(([key, val]) => {\n\t\tif (!val || !fields[key]) return;\n\n\t\tif (fields[key].isReadOnly) {\n\t\t\tthrow new Error(`${key} is read-only.`);\n\t\t}\n\t});\n};\n\nconst createNonModelClass = <T extends PersistentModel>(\n\ttypeDefinition: SchemaNonModel\n) => {\n\tconst clazz = <NonModelTypeConstructor<T>>(<unknown>class Model {\n\t\tconstructor(init: ModelInit<T>) {\n\t\t\tconst instance = produce(\n\t\t\t\tthis,\n\t\t\t\t(draft: Draft<T & ModelInstanceMetadata>) => {\n\t\t\t\t\tinitializeInstance(init, typeDefinition, draft);\n\t\t\t\t}\n\t\t\t);\n\n\t\t\treturn instance;\n\t\t}\n\t});\n\n\tclazz[immerable] = true;\n\n\tObject.defineProperty(clazz, 'name', { value: typeDefinition.name });\n\n\tregisterNonModelClass(clazz);\n\n\treturn clazz;\n};\n\nfunction isQueryOne(obj: any): obj is string {\n\treturn typeof obj === 'string';\n}\n\nfunction defaultConflictHandler(conflictData: SyncConflict): PersistentModel {\n\tconst { localModel, modelConstructor, remoteModel } = conflictData;\n\tconst { _version } = remoteModel;\n\treturn modelInstanceCreator(modelConstructor, { ...localModel, _version });\n}\n\nfunction defaultErrorHandler(error: SyncError<PersistentModel>): void {\n\tlogger.warn(error);\n}\n\nfunction getModelConstructorByModelName(\n\tnamespaceName: NAMESPACES,\n\tmodelName: string\n): PersistentModelConstructor<any> {\n\tlet result: PersistentModelConstructor<any> | NonModelTypeConstructor<any>;\n\n\tswitch (namespaceName) {\n\t\tcase DATASTORE:\n\t\t\tresult = dataStoreClasses[modelName];\n\t\t\tbreak;\n\t\tcase USER:\n\t\t\tresult = userClasses[modelName];\n\t\t\tbreak;\n\t\tcase SYNC:\n\t\t\tresult = syncClasses[modelName];\n\t\t\tbreak;\n\t\tcase STORAGE:\n\t\t\tresult = storageClasses[modelName];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texhaustiveCheck(namespaceName);\n\t\t\tbreak;\n\t}\n\n\tif (isValidModelConstructor(result)) {\n\t\treturn result;\n\t} else {\n\t\tconst msg = `Model name is not valid for namespace. modelName: ${modelName}, namespace: ${namespaceName}`;\n\t\tlogger.error(msg);\n\n\t\tthrow new Error(msg);\n\t}\n}\n\n/**\n * Queries the DataStore metadata tables to see if they are the expected\n * version. If not, clobbers the whole DB. If so, leaves them alone.\n * Otherwise, simply writes the schema version.\n *\n * SIDE EFFECT:\n * 1. Creates a transaction\n * 1. Updates data.\n *\n * @param storage Storage adapter containing the metadata.\n * @param version The expected schema version.\n */\nasync function checkSchemaVersion(\n\tstorage: Storage,\n\tversion: string\n): Promise<void> {\n\tconst Setting =\n\t\tdataStoreClasses.Setting as PersistentModelConstructor<Setting>;\n\n\tconst modelDefinition = schema.namespaces[DATASTORE].models.Setting;\n\n\tawait storage.runExclusive(async s => {\n\t\tconst [schemaVersionSetting] = await s.query(\n\t\t\tSetting,\n\t\t\tModelPredicateCreator.createFromExisting(modelDefinition, c =>\n\t\t\t\tc.key('eq', SETTING_SCHEMA_VERSION)\n\t\t\t),\n\t\t\t{ page: 0, limit: 1 }\n\t\t);\n\n\t\tif (\n\t\t\tschemaVersionSetting !== undefined &&\n\t\t\tschemaVersionSetting.value !== undefined\n\t\t) {\n\t\t\tconst storedValue = JSON.parse(schemaVersionSetting.value);\n\n\t\t\tif (storedValue !== version) {\n\t\t\t\tawait s.clear(false);\n\t\t\t}\n\t\t} else {\n\t\t\tawait s.save(\n\t\t\t\tmodelInstanceCreator(Setting, {\n\t\t\t\t\tkey: SETTING_SCHEMA_VERSION,\n\t\t\t\t\tvalue: JSON.stringify(version),\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t});\n}\n\nlet syncSubscription: ZenObservable.Subscription;\n\nfunction getNamespace(): SchemaNamespace {\n\tconst namespace: SchemaNamespace = {\n\t\tname: DATASTORE,\n\t\trelationships: {},\n\t\tenums: {},\n\t\tnonModels: {},\n\t\tmodels: {\n\t\t\tSetting: {\n\t\t\t\tname: 'Setting',\n\t\t\t\tpluralName: 'Settings',\n\t\t\t\tsyncable: false,\n\t\t\t\tfields: {\n\t\t\t\t\tid: {\n\t\t\t\t\t\tname: 'id',\n\t\t\t\t\t\ttype: 'ID',\n\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t},\n\t\t\t\t\tkey: {\n\t\t\t\t\t\tname: 'key',\n\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t},\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tname: 'value',\n\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t};\n\n\treturn namespace;\n}\n\nenum DataStoreState {\n\tNotRunning = 'Not Running',\n\tStarting = 'Starting',\n\tRunning = 'Running',\n\tStopping = 'Stopping',\n\tClearing = 'Clearing',\n}\n\nclass DataStore {\n\t// reference to configured category instances. Used for preserving SSR context\n\tprivate Auth = Auth;\n\tprivate API = API;\n\tprivate Cache = Cache;\n\n\tprivate amplifyConfig: Record<string, any> = {};\n\tprivate authModeStrategy: AuthModeStrategy;\n\tprivate conflictHandler: ConflictHandler;\n\tprivate errorHandler: (error: SyncError<PersistentModel>) => void;\n\tprivate fullSyncInterval: number;\n\tprivate initialized?: Promise<void>;\n\tprivate initReject: Function;\n\tprivate initResolve: Function;\n\tprivate maxRecordsToSync: number;\n\tprivate storage?: Storage;\n\tprivate sync?: SyncEngine;\n\tprivate syncPageSize: number;\n\tprivate syncExpressions: SyncExpression[];\n\tprivate syncPredicates: WeakMap<SchemaModel, ModelPredicate<any>> =\n\t\tnew WeakMap<SchemaModel, ModelPredicate<any>>();\n\tprivate sessionId: string;\n\tprivate storageAdapter: Adapter;\n\t// object that gets passed to descendent classes. Allows us to pass these down by reference\n\tprivate amplifyContext: AmplifyContext = {\n\t\tAuth: this.Auth,\n\t\tAPI: this.API,\n\t\tCache: this.Cache,\n\t};\n\tprivate connectivityMonitor?: DataStoreConnectivity;\n\n\t/**\n\t * **IMPORTANT!**\n\t *\n\t * Accumulator for background things that can **and MUST** be called when\n\t * DataStore stops.\n\t *\n\t * These jobs **MUST** be *idempotent promises* that resolve ONLY\n\t * once the intended jobs are completely finished and/or otherwise destroyed\n\t * and cleaned up with ZERO outstanding:\n\t *\n\t * 1. side effects (e.g., state changes)\n\t * 1. callbacks\n\t * 1. subscriptions\n\t * 1. calls to storage\n\t * 1. *etc.*\n\t *\n\t * Methods that create pending promises, subscriptions, callbacks, or any\n\t * type of side effect **MUST** be registered with the manager. And, a new\n\t * manager must be created after each `exit()`.\n\t *\n\t * Failure to comply will put DataStore into a highly unpredictable state\n\t * when it needs to stop or clear -- which occurs when restarting with new\n\t * sync expressions, during testing, and potentially during app code\n\t * recovery handling, etc..\n\t *\n\t * It is up to the discretion of each disposer whether to wait for job\n\t * completion or to cancel operations and issue failures *as long as the\n\t * disposer returns in a reasonable amount of time.*\n\t *\n\t * (Reasonable = *seconds*, not minutes.)\n\t */\n\tprivate runningProcesses = new BackgroundProcessManager();\n\n\t/**\n\t * Indicates what state DataStore is in.\n\t *\n\t * Not [yet?] used for actual state management; but for messaging\n\t * when errors occur, to help troubleshoot.\n\t */\n\tprivate state: DataStoreState = DataStoreState.NotRunning;\n\n\tgetModuleName() {\n\t\treturn 'DataStore';\n\t}\n\n\t/**\n\t * Builds a function to capture `BackgroundManagerNotOpenError`'s to produce friendlier,\n\t * more instructive errors for customers.\n\t *\n\t * @param operation The name of the operation (usually a Datastore method) the customer\n\t * tried to call.\n\t */\n\thandleAddProcError(operation: string) {\n\t\t/**\n\t\t * If the tested error is a `BackgroundManagerNotOpenError`, it will be captured\n\t\t * and replaced with a friendlier message that instructs the App Developer.\n\t\t *\n\t\t * @param err An error to test.\n\t\t */\n\t\tconst handler = (err: Error) => {\n\t\t\tif (err.message.startsWith('BackgroundManagerNotOpenError')) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t[\n\t\t\t\t\t\t`DataStoreStateError: Tried to execute \\`${operation}\\` while DataStore was \"${this.state}\".`,\n\t\t\t\t\t\t`This can only be done while DataStore is \"Started\" or \"Stopped\". To remedy:`,\n\t\t\t\t\t\t'Ensure all calls to `stop()` and `clear()` have completed first.',\n\t\t\t\t\t\t'If this is not possible, retry the operation until it succeeds.',\n\t\t\t\t\t].join('\\n')\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t};\n\n\t\treturn handler;\n\t}\n\n\t/**\n\t * If not already done:\n\t * 1. Attaches and initializes storage.\n\t * 1. Loads the schema and records metadata.\n\t * 1. If `this.amplifyConfig.aws_appsync_graphqlEndpoint` contains a URL,\n\t * attaches a sync engine, starts it, and subscribes.\n\t */\n\tstart = async (): Promise<void> => {\n\t\treturn this.runningProcesses\n\t\t\t.add(async () => {\n\t\t\t\tthis.state = DataStoreState.Starting;\n\t\t\t\tif (this.initialized === undefined) {\n\t\t\t\t\tlogger.debug('Starting DataStore');\n\t\t\t\t\tthis.initialized = new Promise((res, rej) => {\n\t\t\t\t\t\tthis.initResolve = res;\n\t\t\t\t\t\tthis.initReject = rej;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tawait this.initialized;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.storage = new Storage(\n\t\t\t\t\tschema,\n\t\t\t\t\tnamespaceResolver,\n\t\t\t\t\tgetModelConstructorByModelName,\n\t\t\t\t\tmodelInstanceCreator,\n\t\t\t\t\tthis.storageAdapter,\n\t\t\t\t\tthis.sessionId\n\t\t\t\t);\n\n\t\t\t\tawait this.storage.init();\n\n\t\t\t\tcheckSchemaInitialized();\n\t\t\t\tawait checkSchemaVersion(this.storage, schema.version);\n\n\t\t\t\tconst { aws_appsync_graphqlEndpoint } = this.amplifyConfig;\n\n\t\t\t\tif (aws_appsync_graphqlEndpoint) {\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t'GraphQL endpoint available',\n\t\t\t\t\t\taws_appsync_graphqlEndpoint\n\t\t\t\t\t);\n\n\t\t\t\t\tthis.syncPredicates = await this.processSyncExpressions();\n\n\t\t\t\t\tthis.sync = new SyncEngine(\n\t\t\t\t\t\tschema,\n\t\t\t\t\t\tnamespaceResolver,\n\t\t\t\t\t\tsyncClasses,\n\t\t\t\t\t\tuserClasses,\n\t\t\t\t\t\tthis.storage,\n\t\t\t\t\t\tmodelInstanceCreator,\n\t\t\t\t\t\tthis.conflictHandler,\n\t\t\t\t\t\tthis.errorHandler,\n\t\t\t\t\t\tthis.syncPredicates,\n\t\t\t\t\t\tthis.amplifyConfig,\n\t\t\t\t\t\tthis.authModeStrategy,\n\t\t\t\t\t\tthis.amplifyContext,\n\t\t\t\t\t\tthis.connectivityMonitor\n\t\t\t\t\t);\n\n\t\t\t\t\tconst fullSyncIntervalInMilliseconds =\n\t\t\t\t\t\tthis.fullSyncInterval * 1000 * 60; // fullSyncInterval from param is in minutes\n\t\t\t\t\tsyncSubscription = this.sync\n\t\t\t\t\t\t.start({ fullSyncInterval: fullSyncIntervalInMilliseconds })\n\t\t\t\t\t\t.subscribe({\n\t\t\t\t\t\t\tnext: ({ type, data }) => {\n\t\t\t\t\t\t\t\t// In Node, we need to wait for queries to be synced to prevent returning empty arrays.\n\t\t\t\t\t\t\t\t// In the Browser, we can begin returning data once subscriptions are in place.\n\t\t\t\t\t\t\t\tconst readyType = isNode\n\t\t\t\t\t\t\t\t\t? ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY\n\t\t\t\t\t\t\t\t\t: ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED;\n\n\t\t\t\t\t\t\t\tif (type === readyType) {\n\t\t\t\t\t\t\t\t\tthis.initResolve();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tHub.dispatch('datastore', {\n\t\t\t\t\t\t\t\t\tevent: type,\n\t\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terror: err => {\n\t\t\t\t\t\t\t\tlogger.warn('Sync error', err);\n\t\t\t\t\t\t\t\tthis.initReject();\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\"Data won't be synchronized. No GraphQL endpoint configured. Did you forget `Amplify.configure(awsconfig)`?\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconfig: this.amplifyConfig,\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tthis.initResolve();\n\t\t\t\t}\n\n\t\t\t\tawait this.initialized;\n\t\t\t\tthis.state = DataStoreState.Running;\n\t\t\t}, 'datastore start')\n\t\t\t.catch(this.handleAddProcError('DataStore.start()'));\n\t};\n\n\tquery: {\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tidentifier: IdentifierFieldOrIdentifierObject<\n\t\t\t\tT,\n\t\t\t\tPersistentModelMetaData<T>\n\t\t\t>\n\t\t): Promise<T | undefined>;\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tcriteria?: ProducerModelPredicate<T> | typeof PredicateAll,\n\t\t\tpaginationProducer?: ProducerPaginationInput<T>\n\t\t): Promise<T[]>;\n\t} = async <T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tidentifierOrCriteria?:\n\t\t\t| IdentifierFieldOrIdentifierObject<T, PersistentModelMetaData<T>>\n\t\t\t| ProducerModelPredicate<T>\n\t\t\t| typeof PredicateAll,\n\t\tpaginationProducer?: ProducerPaginationInput<T>\n\t): Promise<T | T[] | undefined> => {\n\t\treturn this.runningProcesses\n\t\t\t.add(async () => {\n\t\t\t\tawait this.start();\n\n\t\t\t\t//#region Input validation\n\n\t\t\t\tif (!isValidModelConstructor(modelConstructor)) {\n\t\t\t\t\tconst msg = 'Constructor is not for a valid model';\n\t\t\t\t\tlogger.error(msg, { modelConstructor });\n\n\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t}\n\n\t\t\t\tif (typeof identifierOrCriteria === 'string') {\n\t\t\t\t\tif (paginationProducer !== undefined) {\n\t\t\t\t\t\tlogger.warn('Pagination is ignored when querying by id');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst modelDefinition = getModelDefinition(modelConstructor);\n\t\t\t\tconst keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n\n\t\t\t\tlet predicate: ModelPredicate<T>;\n\n\t\t\t\tif (isQueryOne(identifierOrCriteria)) {\n\t\t\t\t\tif (keyFields.length > 1) {\n\t\t\t\t\t\tconst msg = errorMessages.queryByPkWithCompositeKeyPresent;\n\t\t\t\t\t\tlogger.error(msg, { keyFields });\n\n\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t}\n\n\t\t\t\t\tpredicate = ModelPredicateCreator.createForSingleField<T>(\n\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\tkeyFields[0],\n\t\t\t\t\t\tidentifierOrCriteria\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// Object is being queried using object literal syntax\n\t\t\t\t\tif (isIdentifierObject(<T>identifierOrCriteria, modelDefinition)) {\n\t\t\t\t\t\tpredicate = ModelPredicateCreator.createForPk<T>(\n\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t<T>identifierOrCriteria\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (isPredicatesAll(identifierOrCriteria)) {\n\t\t\t\t\t\t// Predicates.ALL means \"all records\", so no predicate (undefined)\n\t\t\t\t\t\tpredicate = undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpredicate = ModelPredicateCreator.createFromExisting(\n\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t<any>identifierOrCriteria\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst pagination = this.processPagination(\n\t\t\t\t\tmodelDefinition,\n\t\t\t\t\tpaginationProducer\n\t\t\t\t);\n\n\t\t\t\t//#endregion\n\n\t\t\t\tlogger.debug('params ready', {\n\t\t\t\t\tmodelConstructor,\n\t\t\t\t\tpredicate: ModelPredicateCreator.getPredicates(predicate, false),\n\t\t\t\t\tpagination: {\n\t\t\t\t\t\t...pagination,\n\t\t\t\t\t\tsort: ModelSortPredicateCreator.getPredicates(\n\t\t\t\t\t\t\tpagination && pagination.sort,\n\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tconst result = await this.storage.query(\n\t\t\t\t\tmodelConstructor,\n\t\t\t\t\tpredicate,\n\t\t\t\t\tpagination\n\t\t\t\t);\n\n\t\t\t\tconst returnOne =\n\t\t\t\t\tisQueryOne(identifierOrCriteria) ||\n\t\t\t\t\tisIdentifierObject(identifierOrCriteria, modelDefinition);\n\n\t\t\t\treturn returnOne ? result[0] : result;\n\t\t\t}, 'datastore query')\n\t\t\t.catch(this.handleAddProcError('DataStore.query()'));\n\t};\n\n\tsave = async <T extends PersistentModel>(\n\t\tmodel: T,\n\t\tcondition?: ProducerModelPredicate<T>\n\t): Promise<T> => {\n\t\treturn this.runningProcesses\n\t\t\t.add(async () => {\n\t\t\t\tawait this.start();\n\n\t\t\t\t// Immer patches for constructing a correct update mutation input\n\t\t\t\t// Allows us to only include changed fields for updates\n\t\t\t\tconst patchesTuple = modelPatchesMap.get(model);\n\n\t\t\t\tconst modelConstructor: PersistentModelConstructor<T> | undefined =\n\t\t\t\t\tmodel ? <PersistentModelConstructor<T>>model.constructor : undefined;\n\n\t\t\t\tif (!isValidModelConstructor(modelConstructor)) {\n\t\t\t\t\tconst msg = 'Object is not an instance of a valid model';\n\t\t\t\t\tlogger.error(msg, { model });\n\n\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t}\n\n\t\t\t\tconst modelDefinition = getModelDefinition(modelConstructor);\n\n\t\t\t\tconst producedCondition = ModelPredicateCreator.createFromExisting(\n\t\t\t\t\tmodelDefinition,\n\t\t\t\t\tcondition!\n\t\t\t\t);\n\n\t\t\t\tconst [savedModel] = await this.storage.runExclusive(async s => {\n\t\t\t\t\tawait s.save(model, producedCondition, undefined, patchesTuple);\n\n\t\t\t\t\treturn s.query<T>(\n\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\tModelPredicateCreator.createForPk(modelDefinition, model)\n\t\t\t\t\t);\n\t\t\t\t});\n\n\t\t\t\treturn savedModel;\n\t\t\t}, 'datastore save')\n\t\t\t.catch(this.handleAddProcError('DataStore.save()'));\n\t};\n\n\tsetConflictHandler = (config: DataStoreConfig): ConflictHandler => {\n\t\tconst { DataStore: configDataStore } = config;\n\n\t\tconst conflictHandlerIsDefault: () => boolean = () =>\n\t\t\tthis.conflictHandler === defaultConflictHandler;\n\n\t\tif (configDataStore && configDataStore.conflictHandler) {\n\t\t\treturn configDataStore.conflictHandler;\n\t\t}\n\t\tif (conflictHandlerIsDefault() && config.conflictHandler) {\n\t\t\treturn config.conflictHandler;\n\t\t}\n\n\t\treturn this.conflictHandler || defaultConflictHandler;\n\t};\n\n\tsetErrorHandler = (config: DataStoreConfig): ErrorHandler => {\n\t\tconst { DataStore: configDataStore } = config;\n\n\t\tconst errorHandlerIsDefault: () => boolean = () =>\n\t\t\tthis.errorHandler === defaultErrorHandler;\n\n\t\tif (configDataStore && configDataStore.errorHandler) {\n\t\t\treturn configDataStore.errorHandler;\n\t\t}\n\t\tif (errorHandlerIsDefault() && config.errorHandler) {\n\t\t\treturn config.errorHandler;\n\t\t}\n\n\t\treturn this.errorHandler || defaultErrorHandler;\n\t};\n\n\tdelete: {\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tidentifier: IdentifierFieldOrIdentifierObject<\n\t\t\t\tT,\n\t\t\t\tPersistentModelMetaData<T>\n\t\t\t>\n\t\t): Promise<T[]>;\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tcondition: ProducerModelPredicate<T> | typeof PredicateAll\n\t\t): Promise<T[]>;\n\t\t<T extends PersistentModel>(\n\t\t\tmodel: T,\n\t\t\tcondition?: ProducerModelPredicate<T>\n\t\t): Promise<T>;\n\t} = async <T extends PersistentModel>(\n\t\tmodelOrConstructor: T | PersistentModelConstructor<T>,\n\t\tidentifierOrCriteria?:\n\t\t\t| IdentifierFieldOrIdentifierObject<T, PersistentModelMetaData<T>>\n\t\t\t| ProducerModelPredicate<T>\n\t\t\t| typeof PredicateAll\n\t): Promise<T | T[]> => {\n\t\treturn this.runningProcesses\n\t\t\t.add(async () => {\n\t\t\t\tawait this.start();\n\n\t\t\t\tlet condition: ModelPredicate<T>;\n\n\t\t\t\tif (!modelOrConstructor) {\n\t\t\t\t\tconst msg = 'Model or Model Constructor required';\n\t\t\t\t\tlogger.error(msg, { modelOrConstructor });\n\n\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t}\n\n\t\t\t\tif (isValidModelConstructor<T>(modelOrConstructor)) {\n\t\t\t\t\tconst modelConstructor = modelOrConstructor;\n\n\t\t\t\t\tif (!identifierOrCriteria) {\n\t\t\t\t\t\tconst msg =\n\t\t\t\t\t\t\t'Id to delete or criteria required. Do you want to delete all? Pass Predicates.ALL';\n\t\t\t\t\t\tlogger.error(msg, { identifierOrCriteria });\n\n\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst modelDefinition = getModelDefinition(modelConstructor);\n\n\t\t\t\t\tif (typeof identifierOrCriteria === 'string') {\n\t\t\t\t\t\tconst keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n\n\t\t\t\t\t\tif (keyFields.length > 1) {\n\t\t\t\t\t\t\tconst msg = errorMessages.deleteByPkWithCompositeKeyPresent;\n\t\t\t\t\t\t\tlogger.error(msg, { keyFields });\n\n\t\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcondition = ModelPredicateCreator.createForSingleField<T>(\n\t\t\t\t\t\t\tgetModelDefinition(modelConstructor),\n\t\t\t\t\t\t\tkeyFields[0],\n\t\t\t\t\t\t\tidentifierOrCriteria\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (isIdentifierObject(identifierOrCriteria, modelDefinition)) {\n\t\t\t\t\t\t\tcondition = ModelPredicateCreator.createForPk<T>(\n\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t<T>identifierOrCriteria\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcondition = ModelPredicateCreator.createFromExisting(\n\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * idOrCriteria is always a ProducerModelPredicate<T>, never a symbol.\n\t\t\t\t\t\t\t\t * The symbol is used only for typing purposes. e.g. see Predicates.ALL\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tidentifierOrCriteria as ProducerModelPredicate<T>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!condition ||\n\t\t\t\t\t\t\t!ModelPredicateCreator.isValidPredicate(condition)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst msg =\n\t\t\t\t\t\t\t\t'Criteria required. Do you want to delete all? Pass Predicates.ALL';\n\t\t\t\t\t\t\tlogger.error(msg, { condition });\n\n\t\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst [deleted] = await this.storage.delete(\n\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\tcondition\n\t\t\t\t\t);\n\n\t\t\t\t\treturn deleted;\n\t\t\t\t} else {\n\t\t\t\t\tconst model = modelOrConstructor;\n\t\t\t\t\tconst modelConstructor = Object.getPrototypeOf(model || {})\n\t\t\t\t\t\t.constructor as PersistentModelConstructor<T>;\n\n\t\t\t\t\tif (!isValidModelConstructor(modelConstructor)) {\n\t\t\t\t\t\tconst msg = 'Object is not an instance of a valid model';\n\t\t\t\t\t\tlogger.error(msg, { model });\n\n\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst modelDefinition = getModelDefinition(modelConstructor);\n\n\t\t\t\t\tconst pkPredicate = ModelPredicateCreator.createForPk<T>(\n\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\tmodel\n\t\t\t\t\t);\n\n\t\t\t\t\tif (identifierOrCriteria) {\n\t\t\t\t\t\tif (typeof identifierOrCriteria !== 'function') {\n\t\t\t\t\t\t\tconst msg = 'Invalid criteria';\n\t\t\t\t\t\t\tlogger.error(msg, { identifierOrCriteria });\n\n\t\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcondition = (<ProducerModelPredicate<T>>identifierOrCriteria)(\n\t\t\t\t\t\t\tpkPredicate\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcondition = pkPredicate;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst [[deleted]] = await this.storage.delete(model, condition);\n\n\t\t\t\t\treturn deleted;\n\t\t\t\t}\n\t\t\t}, 'datastore delete')\n\t\t\t.catch(this.handleAddProcError('DataStore.delete()'));\n\t};\n\n\tobserve: {\n\t\t(): Observable<SubscriptionMessage<PersistentModel>>;\n\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tidentifier: string\n\t\t): Observable<SubscriptionMessage<T>>;\n\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tcriteria?: ProducerModelPredicate<T> | typeof PredicateAll\n\t\t): Observable<SubscriptionMessage<T>>;\n\n\t\t<T extends PersistentModel>(model: T): Observable<SubscriptionMessage<T>>;\n\t} = <T extends PersistentModel>(\n\t\tmodelOrConstructor?: T | PersistentModelConstructor<T>,\n\t\tidentifierOrCriteria?:\n\t\t\t| string\n\t\t\t| ProducerModelPredicate<T>\n\t\t\t| typeof PredicateAll\n\t): Observable<SubscriptionMessage<T>> => {\n\t\tlet predicate: ModelPredicate<T>;\n\n\t\tconst modelConstructor: PersistentModelConstructor<T> | undefined =\n\t\t\tmodelOrConstructor && isValidModelConstructor<T>(modelOrConstructor)\n\t\t\t\t? modelOrConstructor\n\t\t\t\t: undefined;\n\n\t\tif (modelOrConstructor && modelConstructor === undefined) {\n\t\t\tconst model = <T>modelOrConstructor;\n\t\t\tconst modelConstructor =\n\t\t\t\tmodel && (<Object>Object.getPrototypeOf(model)).constructor;\n\n\t\t\tif (isValidModelConstructor<T>(modelConstructor)) {\n\t\t\t\tif (identifierOrCriteria) {\n\t\t\t\t\tlogger.warn('idOrCriteria is ignored when using a model instance', {\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tidentifierOrCriteria,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn this.observe(modelConstructor, model.id);\n\t\t\t} else {\n\t\t\t\tconst msg =\n\t\t\t\t\t'The model is not an instance of a PersistentModelConstructor';\n\t\t\t\tlogger.error(msg, { model });\n\n\t\t\t\tthrow new Error(msg);\n\t\t\t}\n\t\t}\n\n\t\t// observe should not accept object literal syntax\n\t\tif (\n\t\t\tidentifierOrCriteria &&\n\t\t\tmodelConstructor &&\n\t\t\tisIdentifierObject(\n\t\t\t\tidentifierOrCriteria,\n\t\t\t\tgetModelDefinition(modelConstructor)\n\t\t\t)\n\t\t) {\n\t\t\tconst msg = errorMessages.observeWithObjectLiteral;\n\t\t\tlogger.error(msg, { objectLiteral: identifierOrCriteria });\n\n\t\t\tthrow new Error(msg);\n\t\t}\n\n\t\tif (identifierOrCriteria !== undefined && modelConstructor === undefined) {\n\t\t\tconst msg = 'Cannot provide criteria without a modelConstructor';\n\t\t\tlogger.error(msg, identifierOrCriteria);\n\t\t\tthrow new Error(msg);\n\t\t}\n\n\t\tif (modelConstructor && !isValidModelConstructor(modelConstructor)) {\n\t\t\tconst msg = 'Constructor is not for a valid model';\n\t\t\tlogger.error(msg, { modelConstructor });\n\n\t\t\tthrow new Error(msg);\n\t\t}\n\n\t\tif (typeof identifierOrCriteria === 'string') {\n\t\t\tconst modelDefinition = getModelDefinition(modelConstructor);\n\t\t\tconst [keyField] = extractPrimaryKeyFieldNames(modelDefinition);\n\n\t\t\tpredicate = ModelPredicateCreator.createForSingleField<T>(\n\t\t\t\tgetModelDefinition(modelConstructor),\n\t\t\t\tkeyField,\n\t\t\t\tidentifierOrCriteria\n\t\t\t);\n\t\t} else {\n\t\t\tif (isPredicatesAll(identifierOrCriteria)) {\n\t\t\t\tpredicate = undefined;\n\t\t\t} else {\n\t\t\t\tpredicate =\n\t\t\t\t\tmodelConstructor &&\n\t\t\t\t\tModelPredicateCreator.createFromExisting<T>(\n\t\t\t\t\t\tgetModelDefinition(modelConstructor),\n\t\t\t\t\t\tidentifierOrCriteria\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn new Observable<SubscriptionMessage<T>>(observer => {\n\t\t\tlet handle: ZenObservable.Subscription;\n\n\t\t\tthis.runningProcesses\n\t\t\t\t.add(async () => {\n\t\t\t\t\tawait this.start();\n\n\t\t\t\t\t// Filter the events returned by Storage according to namespace,\n\t\t\t\t\t// append original element data, and subscribe to the observable\n\t\t\t\t\thandle = this.storage\n\t\t\t\t\t\t.observe(modelConstructor, predicate)\n\t\t\t\t\t\t.filter(({ model }) => namespaceResolver(model) === USER)\n\t\t\t\t\t\t.subscribe({\n\t\t\t\t\t\t\tnext: item =>\n\t\t\t\t\t\t\t\tthis.runningProcesses.isOpen &&\n\t\t\t\t\t\t\t\tthis.runningProcesses.add(async () => {\n\t\t\t\t\t\t\t\t\t// the `element` doesn't necessarily contain all item details or\n\t\t\t\t\t\t\t\t\t// have related records attached consistently with that of a query()\n\t\t\t\t\t\t\t\t\t// result item. for consistency, we attach them here.\n\n\t\t\t\t\t\t\t\t\tlet message = item;\n\n\t\t\t\t\t\t\t\t\t// as long as we're not dealing with a DELETE, we need to fetch a fresh\n\t\t\t\t\t\t\t\t\t// item from storage to ensure it's fully populated.\n\t\t\t\t\t\t\t\t\tif (item.opType !== 'DELETE') {\n\t\t\t\t\t\t\t\t\t\tconst modelDefinition = getModelDefinition(item.model);\n\t\t\t\t\t\t\t\t\t\tconst keyFields =\n\t\t\t\t\t\t\t\t\t\t\textractPrimaryKeyFieldNames(modelDefinition);\n\t\t\t\t\t\t\t\t\t\tconst primaryKeysAndValues = extractPrimaryKeysAndValues(\n\t\t\t\t\t\t\t\t\t\t\titem.element,\n\t\t\t\t\t\t\t\t\t\t\tkeyFields\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tconst freshElement = await this.query(\n\t\t\t\t\t\t\t\t\t\t\titem.model,\n\t\t\t\t\t\t\t\t\t\t\tprimaryKeysAndValues\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tmessage = {\n\t\t\t\t\t\t\t\t\t\t\t...message,\n\t\t\t\t\t\t\t\t\t\t\telement: freshElement as T,\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tobserver.next(message as SubscriptionMessage<T>);\n\t\t\t\t\t\t\t\t}, 'datastore observe message handler'),\n\t\t\t\t\t\t\terror: err => observer.error(err),\n\t\t\t\t\t\t\tcomplete: () => observer.complete(),\n\t\t\t\t\t\t});\n\t\t\t\t}, 'datastore observe observable initialization')\n\t\t\t\t.catch(this.handleAddProcError('DataStore.observe()'))\n\t\t\t\t.catch(error => {\n\t\t\t\t\tobserver.error(error);\n\t\t\t\t});\n\n\t\t\t// better than no cleaner, but if the subscriber is handling the\n\t\t\t// complete() message async and not registering with the context,\n\t\t\t// this will still be problematic.\n\t\t\treturn this.runningProcesses.addCleaner(async () => {\n\t\t\t\tif (handle) {\n\t\t\t\t\thandle.unsubscribe();\n\t\t\t\t}\n\t\t\t}, 'DataStore.observe() cleanup');\n\t\t});\n\t};\n\n\tobserveQuery: {\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tcriteria?: ProducerModelPredicate<T> | typeof PredicateAll,\n\t\t\tpaginationProducer?: ObserveQueryOptions<T>\n\t\t): Observable<DataStoreSnapshot<T>>;\n\t} = <T extends PersistentModel>(\n\t\tmodel: PersistentModelConstructor<T>,\n\t\tcriteria?: ProducerModelPredicate<T> | typeof PredicateAll,\n\t\toptions?: ObserveQueryOptions<T>\n\t): Observable<DataStoreSnapshot<T>> => {\n\t\treturn new Observable<DataStoreSnapshot<T>>(observer => {\n\t\t\tconst items = new Map<string, T>();\n\t\t\tconst itemsChanged = new Map<string, T>();\n\t\t\tlet deletedItemIds: string[] = [];\n\t\t\tlet handle: ZenObservable.Subscription;\n\t\t\tlet predicate: ModelPredicate<T>;\n\n\t\t\t/**\n\t\t\t * As the name suggests, this geneates a snapshot in the form of\n\t\t\t * \t`{items: T[], isSynced: boolean}`\n\t\t\t * and sends it to the observer.\n\t\t\t *\n\t\t\t * SIDE EFFECT: The underlying generation and emission methods may touch:\n\t\t\t * `items`, `itemsChanged`, and `deletedItemIds`.\n\t\t\t *\n\t\t\t * Refer to `generateSnapshot` and `emitSnapshot` for more details.\n\t\t\t */\n\t\t\tconst generateAndEmitSnapshot = (): void => {\n\t\t\t\tconst snapshot = generateSnapshot();\n\t\t\t\temitSnapshot(snapshot);\n\t\t\t};\n\n\t\t\t// a mechanism to return data after X amount of seconds OR after the\n\t\t\t// \"limit\" (itemsChanged >= this.syncPageSize) has been reached, whichever comes first\n\t\t\tconst limitTimerRace = new DeferredCallbackResolver({\n\t\t\t\tcallback: generateAndEmitSnapshot,\n\t\t\t\terrorHandler: observer.error,\n\t\t\t\tmaxInterval: 2000,\n\t\t\t});\n\n\t\t\tconst { sort } = options || {};\n\t\t\tconst sortOptions = sort ? { sort } : undefined;\n\n\t\t\tconst modelDefinition = getModelDefinition(model);\n\t\t\tconst keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n\n\t\t\tif (isQueryOne(criteria)) {\n\t\t\t\tpredicate = ModelPredicateCreator.createForSingleField<T>(\n\t\t\t\t\tmodelDefinition,\n\t\t\t\t\tkeyFields[0],\n\t\t\t\t\tcriteria\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tif (isPredicatesAll(criteria)) {\n\t\t\t\t\t// Predicates.ALL means \"all records\", so no predicate (undefined)\n\t\t\t\t\tpredicate = undefined;\n\t\t\t\t} else {\n\t\t\t\t\tpredicate = ModelPredicateCreator.createFromExisting(\n\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\tcriteria\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst { predicates, type: predicateGroupType } =\n\t\t\t\tModelPredicateCreator.getPredicates(predicate, false) || {};\n\t\t\tconst hasPredicate = !!predicates;\n\n\t\t\tthis.runningProcesses\n\t\t\t\t.add(async () => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// first, query and return any locally-available records\n\t\t\t\t\t\t(await this.query(model, criteria, sortOptions)).forEach(item => {\n\t\t\t\t\t\t\tconst itemModelDefinition = getModelDefinition(model);\n\t\t\t\t\t\t\tconst idOrPk = getIdentifierValue(itemModelDefinition, item);\n\t\t\t\t\t\t\titems.set(idOrPk, item);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Observe the model and send a stream of updates (debounced).\n\t\t\t\t\t\t// We need to post-filter results instead of passing criteria through\n\t\t\t\t\t\t// to have visibility into items that move from in-set to out-of-set.\n\t\t\t\t\t\t// We need to explicitly remove those items from the existing snapshot.\n\t\t\t\t\t\thandle = this.observe(model).subscribe(\n\t\t\t\t\t\t\t({ element, model, opType }) => {\n\t\t\t\t\t\t\t\tconst itemModelDefinition = getModelDefinition(model);\n\t\t\t\t\t\t\t\tconst idOrPk = getIdentifierValue(itemModelDefinition, element);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\thasPredicate &&\n\t\t\t\t\t\t\t\t\t!validatePredicate(element, predicateGroupType, predicates)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\topType === 'UPDATE' &&\n\t\t\t\t\t\t\t\t\t\t(items.has(idOrPk) || itemsChanged.has(idOrPk))\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t// tracking as a \"deleted item\" will include the item in\n\t\t\t\t\t\t\t\t\t\t// page limit calculations and ensure it is removed from the\n\t\t\t\t\t\t\t\t\t\t// final items collection, regardless of which collection(s)\n\t\t\t\t\t\t\t\t\t\t// it is currently in. (I mean, it could be in both, right!?)\n\t\t\t\t\t\t\t\t\t\tdeletedItemIds.push(idOrPk);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t// ignore updates for irrelevant/filtered items.\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Flag items which have been recently deleted\n\t\t\t\t\t\t\t\t// NOTE: Merging of separate operations to the same model instance is handled upstream\n\t\t\t\t\t\t\t\t// in the `mergePage` method within src/sync/merger.ts. The final state of a model instance\n\t\t\t\t\t\t\t\t// depends on the LATEST record (for a given id).\n\t\t\t\t\t\t\t\tif (opType === 'DELETE') {\n\t\t\t\t\t\t\t\t\tdeletedItemIds.push(idOrPk);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\titemsChanged.set(idOrPk, element);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst isSynced =\n\t\t\t\t\t\t\t\t\tthis.sync?.getModelSyncedStatus(model) ?? false;\n\n\t\t\t\t\t\t\t\tconst limit =\n\t\t\t\t\t\t\t\t\titemsChanged.size - deletedItemIds.length >=\n\t\t\t\t\t\t\t\t\tthis.syncPageSize;\n\n\t\t\t\t\t\t\t\tif (limit || isSynced) {\n\t\t\t\t\t\t\t\t\tlimitTimerRace.resolve();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// kicks off every subsequent race as results sync down\n\t\t\t\t\t\t\t\tlimitTimerRace.start();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// returns a set of initial/locally-available results\n\t\t\t\t\t\tgenerateAndEmitSnapshot();\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tobserver.error(err);\n\t\t\t\t\t}\n\t\t\t\t}, 'datastore observequery startup')\n\t\t\t\t.catch(this.handleAddProcError('DataStore.observeQuery()'))\n\t\t\t\t.catch(error => {\n\t\t\t\t\tobserver.error(error);\n\t\t\t\t});\n\n\t\t\t/**\n\t\t\t * Combines the `items`, `itemsChanged`, and `deletedItemIds` collections into\n\t\t\t * a snapshot in the form of `{ items: T[], isSynced: boolean}`.\n\t\t\t *\n\t\t\t * SIDE EFFECT: The shared `items` collection is recreated.\n\t\t\t */\n\t\t\tconst generateSnapshot = (): DataStoreSnapshot<T> => {\n\t\t\t\tconst isSynced = this.sync?.getModelSyncedStatus(model) ?? false;\n\t\t\t\tconst itemsArray = [\n\t\t\t\t\t...Array.from(items.values()),\n\t\t\t\t\t...Array.from(itemsChanged.values()),\n\t\t\t\t];\n\n\t\t\t\tif (options?.sort) {\n\t\t\t\t\tsortItems(itemsArray);\n\t\t\t\t}\n\n\t\t\t\titems.clear();\n\t\t\t\titemsArray.forEach(item => {\n\t\t\t\t\tconst itemModelDefinition = getModelDefinition(model);\n\t\t\t\t\tconst idOrPk = getIdentifierValue(itemModelDefinition, item);\n\t\t\t\t\titems.set(idOrPk, item);\n\t\t\t\t});\n\n\t\t\t\t// remove deleted items from the final result set\n\t\t\t\tdeletedItemIds.forEach(idOrPk => items.delete(idOrPk));\n\n\t\t\t\treturn {\n\t\t\t\t\titems: Array.from(items.values()),\n\t\t\t\t\tisSynced,\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Emits the list of items to the observer.\n\t\t\t *\n\t\t\t * SIDE EFFECT: `itemsChanged` and `deletedItemIds` are cleared to prepare\n\t\t\t * for the next snapshot.\n\t\t\t *\n\t\t\t * @param snapshot The generated items data to emit.\n\t\t\t */\n\t\t\tconst emitSnapshot = (snapshot: DataStoreSnapshot<T>): void => {\n\t\t\t\t// send the generated snapshot to the primary subscription.\n\t\t\t\t// NOTE: This observer's handler *could* be async ...\n\t\t\t\tobserver.next(snapshot);\n\n\t\t\t\t// reset the changed items sets\n\t\t\t\titemsChanged.clear();\n\t\t\t\tdeletedItemIds = [];\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Sorts an `Array` of `T` according to the sort instructions given in the\n\t\t\t * original  `observeQuery()` call.\n\t\t\t *\n\t\t\t * @param itemsToSort A array of model type.\n\t\t\t */\n\t\t\tconst sortItems = (itemsToSort: T[]): void => {\n\t\t\t\tconst modelDefinition = getModelDefinition(model);\n\t\t\t\tconst pagination = this.processPagination(modelDefinition, options);\n\n\t\t\t\tconst sortPredicates = ModelSortPredicateCreator.getPredicates(\n\t\t\t\t\tpagination.sort\n\t\t\t\t);\n\n\t\t\t\tif (sortPredicates.length) {\n\t\t\t\t\tconst compareFn = sortCompareFunction(sortPredicates);\n\t\t\t\t\titemsToSort.sort(compareFn);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Force one last snapshot when the model is fully synced.\n\t\t\t *\n\t\t\t * This reduces latency for that last snapshot, which will otherwise\n\t\t\t * wait for the configured timeout.\n\t\t\t *\n\t\t\t * @param payload The payload from the Hub event.\n\t\t\t */\n\t\t\tconst hubCallback = ({ payload }): void => {\n\t\t\t\tconst { event, data } = payload;\n\t\t\t\tif (\n\t\t\t\t\tevent === ControlMessage.SYNC_ENGINE_MODEL_SYNCED &&\n\t\t\t\t\tdata?.model?.name === model.name\n\t\t\t\t) {\n\t\t\t\t\tgenerateAndEmitSnapshot();\n\t\t\t\t\tHub.remove('datastore', hubCallback);\n\t\t\t\t}\n\t\t\t};\n\t\t\tHub.listen('datastore', hubCallback);\n\n\t\t\treturn this.runningProcesses.addCleaner(async () => {\n\t\t\t\tif (handle) {\n\t\t\t\t\thandle.unsubscribe();\n\t\t\t\t}\n\t\t\t}, 'datastore observequery cleaner');\n\t\t});\n\t};\n\n\tconfigure = (config: DataStoreConfig = {}) => {\n\t\tthis.amplifyContext.Auth = this.Auth;\n\t\tthis.amplifyContext.API = this.API;\n\t\tthis.amplifyContext.Cache = this.Cache;\n\n\t\tconst {\n\t\t\tDataStore: configDataStore,\n\t\t\tauthModeStrategyType: configAuthModeStrategyType,\n\t\t\tconflictHandler: configConflictHandler,\n\t\t\terrorHandler: configErrorHandler,\n\t\t\tmaxRecordsToSync: configMaxRecordsToSync,\n\t\t\tsyncPageSize: configSyncPageSize,\n\t\t\tfullSyncInterval: configFullSyncInterval,\n\t\t\tsyncExpressions: configSyncExpressions,\n\t\t\tauthProviders: configAuthProviders,\n\t\t\tstorageAdapter: configStorageAdapter,\n\t\t\t...configFromAmplify\n\t\t} = config;\n\n\t\tthis.amplifyConfig = {\n\t\t\t...configFromAmplify,\n\t\t\t...this.amplifyConfig,\n\t\t};\n\n\t\tthis.conflictHandler = this.setConflictHandler(config);\n\t\tthis.errorHandler = this.setErrorHandler(config);\n\n\t\tconst authModeStrategyType =\n\t\t\t(configDataStore && configDataStore.authModeStrategyType) ||\n\t\t\tconfigAuthModeStrategyType ||\n\t\t\tAuthModeStrategyType.DEFAULT;\n\n\t\tswitch (authModeStrategyType) {\n\t\t\tcase AuthModeStrategyType.MULTI_AUTH:\n\t\t\t\tthis.authModeStrategy = multiAuthStrategy(this.amplifyContext);\n\t\t\t\tbreak;\n\t\t\tcase AuthModeStrategyType.DEFAULT:\n\t\t\t\tthis.authModeStrategy = defaultAuthStrategy;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.authModeStrategy = defaultAuthStrategy;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// store on config object, so that Sync, Subscription, and Mutation processors can have access\n\t\tthis.amplifyConfig.authProviders =\n\t\t\t(configDataStore && configDataStore.authProviders) || configAuthProviders;\n\n\t\tthis.syncExpressions =\n\t\t\t(configDataStore && configDataStore.syncExpressions) ||\n\t\t\tconfigSyncExpressions ||\n\t\t\tthis.syncExpressions;\n\n\t\tthis.maxRecordsToSync =\n\t\t\t(configDataStore && configDataStore.maxRecordsToSync) ||\n\t\t\tconfigMaxRecordsToSync ||\n\t\t\tthis.maxRecordsToSync ||\n\t\t\t10000;\n\n\t\t// store on config object, so that Sync, Subscription, and Mutation processors can have access\n\t\tthis.amplifyConfig.maxRecordsToSync = this.maxRecordsToSync;\n\n\t\tthis.syncPageSize =\n\t\t\t(configDataStore && configDataStore.syncPageSize) ||\n\t\t\tconfigSyncPageSize ||\n\t\t\tthis.syncPageSize ||\n\t\t\t1000;\n\n\t\t// store on config object, so that Sync, Subscription, and Mutation processors can have access\n\t\tthis.amplifyConfig.syncPageSize = this.syncPageSize;\n\n\t\tthis.fullSyncInterval =\n\t\t\t(configDataStore && configDataStore.fullSyncInterval) ||\n\t\t\tconfigFullSyncInterval ||\n\t\t\tthis.fullSyncInterval ||\n\t\t\t24 * 60; // 1 day\n\n\t\tthis.storageAdapter =\n\t\t\t(configDataStore && configDataStore.storageAdapter) ||\n\t\t\tconfigStorageAdapter ||\n\t\t\tthis.storageAdapter ||\n\t\t\tundefined;\n\n\t\tthis.sessionId = this.retrieveSessionId()!;\n\t};\n\n\t/**\n\t * Clears all data from storage and removes all data, schema info, other\n\t * initialization details, and then stops DataStore.\n\t *\n\t * That said, reinitialization is required after clearing. This can be done\n\t * by explicitiliy calling `start()` or any method that implicitly starts\n\t * DataStore, such as `query()`, `save()`, or `delete()`.\n\t */\n\tasync clear() {\n\t\tcheckSchemaInitialized();\n\t\tthis.state = DataStoreState.Clearing;\n\t\tawait this.runningProcesses.close();\n\t\tif (this.storage === undefined) {\n\t\t\t// connect to storage so that it can be cleared without fully starting DataStore\n\t\t\tthis.storage = new Storage(\n\t\t\t\tschema,\n\t\t\t\tnamespaceResolver,\n\t\t\t\tgetModelConstructorByModelName,\n\t\t\t\tmodelInstanceCreator,\n\t\t\t\tthis.storageAdapter,\n\t\t\t\tthis.sessionId\n\t\t\t);\n\t\t\tawait this.storage.init();\n\t\t}\n\n\t\tif (syncSubscription && !syncSubscription.closed) {\n\t\t\tsyncSubscription.unsubscribe();\n\t\t}\n\n\t\tif (this.sync) {\n\t\t\tawait this.sync.stop();\n\t\t}\n\n\t\tawait this.storage!.clear();\n\n\t\tthis.initialized = undefined; // Should re-initialize when start() is called.\n\t\tthis.storage = undefined;\n\t\tthis.sync = undefined;\n\t\tthis.syncPredicates = new WeakMap<SchemaModel, ModelPredicate<any>>();\n\n\t\tawait this.runningProcesses.open();\n\t\tthis.state = DataStoreState.NotRunning;\n\t}\n\n\t/**\n\t * Stops all DataStore sync activities.\n\t *\n\t * TODO: \"Waits for graceful termination of\n\t * running queries and terminates subscriptions.\"\n\t */\n\tasync stop(this: InstanceType<typeof DataStore>) {\n\t\tthis.state = DataStoreState.Stopping;\n\n\t\tawait this.runningProcesses.close();\n\n\t\tif (syncSubscription && !syncSubscription.closed) {\n\t\t\tsyncSubscription.unsubscribe();\n\t\t}\n\n\t\tif (this.sync) {\n\t\t\tawait this.sync.stop();\n\t\t}\n\n\t\tthis.initialized = undefined; // Should re-initialize when start() is called.\n\t\tthis.sync = undefined;\n\t\tawait this.runningProcesses.open();\n\t\tthis.state = DataStoreState.NotRunning;\n\t}\n\n\t/**\n\t * Validates given pagination input from a query and creates a pagination\n\t * argument for use against the storage layer.\n\t *\n\t * @param modelDefinition\n\t * @param paginationProducer\n\t */\n\tprivate processPagination<T extends PersistentModel>(\n\t\tmodelDefinition: SchemaModel,\n\t\tpaginationProducer: ProducerPaginationInput<T>\n\t): PaginationInput<T> | undefined {\n\t\tlet sortPredicate: SortPredicate<T>;\n\t\tconst { limit, page, sort } = paginationProducer || {};\n\n\t\tif (limit === undefined && page === undefined && sort === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (page !== undefined && limit === undefined) {\n\t\t\tthrow new Error('Limit is required when requesting a page');\n\t\t}\n\n\t\tif (page !== undefined) {\n\t\t\tif (typeof page !== 'number') {\n\t\t\t\tthrow new Error('Page should be a number');\n\t\t\t}\n\n\t\t\tif (page < 0) {\n\t\t\t\tthrow new Error(\"Page can't be negative\");\n\t\t\t}\n\t\t}\n\n\t\tif (limit !== undefined) {\n\t\t\tif (typeof limit !== 'number') {\n\t\t\t\tthrow new Error('Limit should be a number');\n\t\t\t}\n\n\t\t\tif (limit < 0) {\n\t\t\t\tthrow new Error(\"Limit can't be negative\");\n\t\t\t}\n\t\t}\n\n\t\tif (sort) {\n\t\t\tsortPredicate = ModelSortPredicateCreator.createFromExisting(\n\t\t\t\tmodelDefinition,\n\t\t\t\tpaginationProducer.sort\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tlimit,\n\t\t\tpage,\n\t\t\tsort: sortPredicate,\n\t\t};\n\t}\n\n\t/**\n\t * Examines the configured `syncExpressions` and produces a WeakMap of\n\t * SchemaModel -> predicate to use during sync.\n\t */\n\tprivate async processSyncExpressions(): Promise<\n\t\tWeakMap<SchemaModel, ModelPredicate<any>>\n\t> {\n\t\tif (!this.syncExpressions || !this.syncExpressions.length) {\n\t\t\treturn new WeakMap<SchemaModel, ModelPredicate<any>>();\n\t\t}\n\n\t\tconst syncPredicates = await Promise.all(\n\t\t\tthis.syncExpressions.map(\n\t\t\t\tasync (\n\t\t\t\t\tsyncExpression: SyncExpression\n\t\t\t\t): Promise<[SchemaModel, ModelPredicate<any>]> => {\n\t\t\t\t\tconst { modelConstructor, conditionProducer } = await syncExpression;\n\t\t\t\t\tconst modelDefinition = getModelDefinition(modelConstructor);\n\n\t\t\t\t\t// conditionProducer is either a predicate, e.g. (c) => c.field('eq', 1)\n\t\t\t\t\t// OR a function/promise that returns a predicate\n\t\t\t\t\tconst condition = await this.unwrapPromise(conditionProducer);\n\t\t\t\t\tif (isPredicatesAll(condition)) {\n\t\t\t\t\t\treturn [modelDefinition, null];\n\t\t\t\t\t}\n\n\t\t\t\t\tconst predicate = this.createFromCondition(\n\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\tcondition\n\t\t\t\t\t);\n\n\t\t\t\t\treturn [modelDefinition, predicate];\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\n\t\treturn this.weakMapFromEntries(syncPredicates);\n\t}\n\n\tprivate createFromCondition(\n\t\tmodelDefinition: SchemaModel,\n\t\tcondition: ProducerModelPredicate<PersistentModel>\n\t) {\n\t\ttry {\n\t\t\treturn ModelPredicateCreator.createFromExisting(\n\t\t\t\tmodelDefinition,\n\t\t\t\tcondition\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error creating Sync Predicate');\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate async unwrapPromise<T extends PersistentModel>(\n\t\tconditionProducer\n\t): Promise<ProducerModelPredicate<T>> {\n\t\ttry {\n\t\t\tconst condition = await conditionProducer();\n\t\t\treturn condition;\n\t\t} catch (error) {\n\t\t\tif (error instanceof TypeError) {\n\t\t\t\treturn conditionProducer;\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate weakMapFromEntries(\n\t\tentries: [SchemaModel, ModelPredicate<any>][]\n\t): WeakMap<SchemaModel, ModelPredicate<any>> {\n\t\treturn entries.reduce((map, [modelDefinition, predicate]) => {\n\t\t\tif (map.has(modelDefinition)) {\n\t\t\t\tconst { name } = modelDefinition;\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`You can only utilize one Sync Expression per model.\n          Subsequent sync expressions for the ${name} model will be ignored.`\n\t\t\t\t);\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\tif (predicate) {\n\t\t\t\tmap.set(modelDefinition, predicate);\n\t\t\t}\n\n\t\t\treturn map;\n\t\t}, new WeakMap<SchemaModel, ModelPredicate<any>>());\n\t}\n\n\t/**\n\t * A session ID to allow CMS to open databases against multiple apps.\n\t * This session ID is only expected be set by AWS Amplify Studio.\n\t */\n\tprivate retrieveSessionId(): string | undefined {\n\t\ttry {\n\t\t\tconst sessionId = sessionStorage.getItem('datastoreSessionId');\n\n\t\t\tif (sessionId) {\n\t\t\t\tconst { aws_appsync_graphqlEndpoint } = this.amplifyConfig;\n\n\t\t\t\tconst appSyncUrl = aws_appsync_graphqlEndpoint.split('/')[2];\n\t\t\t\tconst [appSyncId] = appSyncUrl.split('.');\n\n\t\t\t\treturn `${sessionId}-${appSyncId}`;\n\t\t\t}\n\t\t} catch {}\n\n\t\treturn undefined;\n\t}\n}\n\nconst instance = new DataStore();\nAmplify.register(instance);\n\nexport { DataStore as DataStoreClass, initSchema, instance as DataStore };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}