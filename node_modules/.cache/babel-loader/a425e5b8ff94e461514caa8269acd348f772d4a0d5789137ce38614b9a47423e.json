{"ast":null,"code":"import { useId as e } from \"@radix-ui/react-id\";\nimport { useFocusGuards as n } from \"@radix-ui/react-focus-guards\";\nimport { useCallbackRef as t } from \"@radix-ui/react-use-callback-ref\";\nimport { useDirection as r } from \"@radix-ui/react-use-direction\";\nimport * as o from \"@radix-ui/react-roving-focus\";\nimport { createRovingFocusGroupScope as u } from \"@radix-ui/react-roving-focus\";\nimport { Portal as c } from \"@radix-ui/react-portal\";\nimport * as a from \"@radix-ui/react-popper\";\nimport { createPopperScope as i } from \"@radix-ui/react-popper\";\nimport { Primitive as s } from \"@radix-ui/react-primitive\";\nimport { Presence as l } from \"@radix-ui/react-presence\";\nimport { FocusScope as d } from \"@radix-ui/react-focus-scope\";\nimport { DismissableLayer as p } from \"@radix-ui/react-dismissable-layer\";\nimport { createContextScope as f } from \"@radix-ui/react-context\";\nimport { useComposedRefs as m, composeRefs as v } from \"@radix-ui/react-compose-refs\";\nimport { createCollection as g } from \"@radix-ui/react-collection\";\nimport { composeEventHandlers as M } from \"@radix-ui/primitive\";\nimport { hideOthers as h } from \"aria-hidden\";\nimport { RemoveScroll as C } from \"react-remove-scroll\";\nimport * as E from \"react\";\nimport w from \"@babel/runtime/helpers/esm/extends\";\nconst x = [\"Enter\", \" \"],\n  b = [\"ArrowUp\", \"PageDown\", \"End\"],\n  R = [\"ArrowDown\", \"PageUp\", \"Home\", ...b],\n  _ = {\n    ltr: [...x, \"ArrowRight\"],\n    rtl: [...x, \"ArrowLeft\"]\n  },\n  y = {\n    ltr: [\"ArrowLeft\"],\n    rtl: [\"ArrowRight\"]\n  },\n  [I, k, P] = g(\"Menu\"),\n  [D, S] = f(\"Menu\", [P, i, u]);\nexport { S as createMenuScope };\nconst O = i(),\n  T = u(),\n  [L, A] = D(\"Menu\");\nexport const Menu = e => {\n  const {\n      __scopeMenu: n,\n      open: o = !1,\n      children: u,\n      onOpenChange: c,\n      modal: i = !0\n    } = e,\n    s = O(n),\n    [l, d] = E.useState(null),\n    p = E.useRef(!1),\n    f = t(c),\n    m = r(l, e.dir);\n  return E.useEffect(() => {\n    const e = () => {\n        p.current = !0, document.addEventListener(\"pointerdown\", n, {\n          capture: !0,\n          once: !0\n        }), document.addEventListener(\"pointermove\", n, {\n          capture: !0,\n          once: !0\n        });\n      },\n      n = () => p.current = !1;\n    return document.addEventListener(\"keydown\", e, {\n      capture: !0\n    }), () => {\n      document.removeEventListener(\"keydown\", e, {\n        capture: !0\n      }), document.removeEventListener(\"pointerdown\", n, {\n        capture: !0\n      }), document.removeEventListener(\"pointermove\", n, {\n        capture: !0\n      });\n    };\n  }, []), /*#__PURE__*/E.createElement(a.Root, s, /*#__PURE__*/E.createElement(L, {\n    scope: n,\n    isSubmenu: !1,\n    isUsingKeyboardRef: p,\n    dir: m,\n    open: o,\n    onOpenChange: f,\n    content: l,\n    onContentChange: d,\n    onRootClose: E.useCallback(() => f(!1), [f]),\n    modal: i\n  }, u));\n}; /*#__PURE__*/\nexport const MenuSub = n => {\n  const {\n      __scopeMenu: r,\n      children: o,\n      open: u = !1,\n      onOpenChange: c\n    } = n,\n    i = A(\"MenuSub\", r),\n    s = O(r),\n    [l, d] = E.useState(null),\n    [p, f] = E.useState(null),\n    m = t(c);\n  return E.useEffect(() => (!1 === i.open && m(!1), () => m(!1)), [i.open, m]), /*#__PURE__*/E.createElement(a.Root, s, /*#__PURE__*/E.createElement(L, {\n    scope: r,\n    isSubmenu: !0,\n    isUsingKeyboardRef: i.isUsingKeyboardRef,\n    dir: i.dir,\n    open: u,\n    onOpenChange: m,\n    content: p,\n    onContentChange: f,\n    onRootClose: i.onRootClose,\n    contentId: e(),\n    trigger: l,\n    onTriggerChange: d,\n    triggerId: e(),\n    modal: !1\n  }, o));\n}; /*#__PURE__*/\nexport const MenuAnchor = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n      __scopeMenu: t,\n      ...r\n    } = e,\n    o = O(t); /*#__PURE__*/\n  return E.createElement(a.Anchor, w({}, o, r, {\n    ref: n\n  }));\n}); /*#__PURE__*/\nconst [F, K] = D(\"MenuContent\");\nexport const MenuContent = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n      forceMount: t,\n      ...r\n    } = e,\n    o = A(\"MenuContent\", e.__scopeMenu); /*#__PURE__*/\n  return E.createElement(I.Provider, {\n    scope: e.__scopeMenu\n  }, /*#__PURE__*/E.createElement(l, {\n    present: t || o.open\n  }, /*#__PURE__*/E.createElement(I.Slot, {\n    scope: e.__scopeMenu\n  }, o.isSubmenu ? /*#__PURE__*/E.createElement(X, w({}, r, {\n    ref: n\n  })) : /*#__PURE__*/E.createElement(G, w({}, r, {\n    ref: n\n  })))));\n});\nconst G = /*#__PURE__*/E.forwardRef((e, n) => A(\"MenuContent\", e.__scopeMenu).modal ? /*#__PURE__*/E.createElement(U, w({}, e, {\n    ref: n\n  })) : /*#__PURE__*/E.createElement(V, w({}, e, {\n    ref: n\n  }))),\n  U = /*#__PURE__*/E.forwardRef((e, n) => {\n    const t = A(\"MenuContent\", e.__scopeMenu),\n      r = E.useRef(null),\n      o = m(n, r);\n    return E.useEffect(() => {\n      const e = r.current;\n      if (e) return h(e);\n    }, []), /*#__PURE__*/E.createElement(B, w({}, e, {\n      ref: o,\n      trapFocus: t.open,\n      disableOutsidePointerEvents: t.open,\n      disableOutsideScroll: !0,\n      onFocusOutside: M(e.onFocusOutside, e => e.preventDefault(), {\n        checkForDefaultPrevented: !1\n      }),\n      onDismiss: () => t.onOpenChange(!1)\n    }));\n  }),\n  V = /*#__PURE__*/E.forwardRef((e, n) => {\n    const t = A(\"MenuContent\", e.__scopeMenu); /*#__PURE__*/\n    return E.createElement(B, w({}, e, {\n      ref: n,\n      trapFocus: !1,\n      disableOutsidePointerEvents: !1,\n      disableOutsideScroll: !1,\n      onDismiss: () => t.onOpenChange(!1)\n    }));\n  }),\n  X = /*#__PURE__*/E.forwardRef((e, n) => {\n    const t = A(\"MenuContent\", e.__scopeMenu),\n      r = E.useRef(null),\n      o = m(n, r);\n    return t.isSubmenu ? /*#__PURE__*/E.createElement(B, w({\n      id: t.contentId,\n      \"aria-labelledby\": t.triggerId\n    }, e, {\n      ref: o,\n      align: \"start\",\n      side: \"rtl\" === t.dir ? \"left\" : \"right\",\n      portalled: !0,\n      disableOutsidePointerEvents: !1,\n      disableOutsideScroll: !1,\n      trapFocus: !1,\n      onOpenAutoFocus: e => {\n        var n;\n        t.isUsingKeyboardRef.current && (null === (n = r.current) || void 0 === n || n.focus()), e.preventDefault();\n      },\n      onCloseAutoFocus: e => e.preventDefault(),\n      onFocusOutside: M(e.onFocusOutside, e => {\n        e.target !== t.trigger && t.onOpenChange(!1);\n      }),\n      onEscapeKeyDown: M(e.onEscapeKeyDown, t.onRootClose),\n      onKeyDown: M(e.onKeyDown, e => {\n        const n = e.currentTarget.contains(e.target),\n          r = y[t.dir].includes(e.key);\n        var o;\n        n && r && (t.onOpenChange(!1), null === (o = t.trigger) || void 0 === o || o.focus(), e.preventDefault());\n      })\n    })) : null;\n  }),\n  B = /*#__PURE__*/E.forwardRef((e, t) => {\n    const {\n        __scopeMenu: r,\n        loop: u = !1,\n        trapFocus: i,\n        onOpenAutoFocus: s,\n        onCloseAutoFocus: l,\n        disableOutsidePointerEvents: f,\n        onEscapeKeyDown: v,\n        onPointerDownOutside: g,\n        onFocusOutside: h,\n        onInteractOutside: x,\n        onDismiss: _,\n        disableOutsideScroll: y,\n        allowPinchZoom: I,\n        portalled: P,\n        ...D\n      } = e,\n      S = A(\"MenuContent\", r),\n      L = O(r),\n      K = T(r),\n      G = k(r),\n      [U, V] = E.useState(null),\n      X = E.useRef(null),\n      B = m(t, X, S.onContentChange),\n      Y = E.useRef(0),\n      Z = E.useRef(\"\"),\n      z = E.useRef(0),\n      H = E.useRef(null),\n      W = E.useRef(\"right\"),\n      q = E.useRef(0),\n      N = P ? c : E.Fragment,\n      Q = y ? C : E.Fragment,\n      $ = y ? {\n        allowPinchZoom: I\n      } : void 0,\n      ee = e => {\n        var n, t;\n        const r = Z.current + e,\n          o = G().filter(e => !e.disabled),\n          u = document.activeElement,\n          c = null === (n = o.find(e => e.ref.current === u)) || void 0 === n ? void 0 : n.textValue,\n          a = function (e, n, t) {\n            const r = n.length > 1 && Array.from(n).every(e => e === n[0]) ? n[0] : n,\n              o = t ? e.indexOf(t) : -1;\n            let u = (c = e, a = Math.max(o, 0), c.map((e, n) => c[(a + n) % c.length]));\n            var c, a;\n            1 === r.length && (u = u.filter(e => e !== t));\n            const i = u.find(e => e.toLowerCase().startsWith(r.toLowerCase()));\n            return i !== t ? i : void 0;\n          }(o.map(e => e.textValue), r, c),\n          i = null === (t = o.find(e => e.textValue === a)) || void 0 === t ? void 0 : t.ref.current;\n        !function e(n) {\n          Z.current = n, window.clearTimeout(Y.current), \"\" !== n && (Y.current = window.setTimeout(() => e(\"\"), 1e3));\n        }(r), i && setTimeout(() => i.focus());\n      };\n    E.useEffect(() => () => window.clearTimeout(Y.current), []), n();\n    const ne = E.useCallback(e => {\n      var n, t;\n      return W.current === (null === (n = H.current) || void 0 === n ? void 0 : n.side) && function (e, n) {\n        if (!n) return !1;\n        return function (e, n) {\n          const {\n            x: t,\n            y: r\n          } = e;\n          let o = !1;\n          for (let e = 0, u = n.length - 1; e < n.length; u = e++) {\n            const c = n[e].x,\n              a = n[e].y,\n              i = n[u].x,\n              s = n[u].y;\n            a > r != s > r && t < (i - c) * (r - a) / (s - a) + c && (o = !o);\n          }\n          return o;\n        }({\n          x: e.clientX,\n          y: e.clientY\n        }, n);\n      }(e, null === (t = H.current) || void 0 === t ? void 0 : t.area);\n    }, []); /*#__PURE__*/\n    return E.createElement(N, null, /*#__PURE__*/E.createElement(Q, $, /*#__PURE__*/E.createElement(F, {\n      scope: r,\n      searchRef: Z,\n      onItemEnter: E.useCallback(e => {\n        ne(e) && e.preventDefault();\n      }, [ne]),\n      onItemLeave: E.useCallback(e => {\n        var n;\n        ne(e) || (null === (n = X.current) || void 0 === n || n.focus(), V(null));\n      }, [ne]),\n      onTriggerLeave: E.useCallback(e => {\n        ne(e) && e.preventDefault();\n      }, [ne]),\n      pointerGraceTimerRef: z,\n      onPointerGraceIntentChange: E.useCallback(e => {\n        H.current = e;\n      }, [])\n    }, /*#__PURE__*/E.createElement(d, {\n      asChild: !0,\n      trapped: i,\n      onMountAutoFocus: M(s, e => {\n        var n;\n        e.preventDefault(), null === (n = X.current) || void 0 === n || n.focus();\n      }),\n      onUnmountAutoFocus: l\n    }, /*#__PURE__*/E.createElement(p, {\n      asChild: !0,\n      disableOutsidePointerEvents: f,\n      onEscapeKeyDown: v,\n      onPointerDownOutside: g,\n      onFocusOutside: h,\n      onInteractOutside: x,\n      onDismiss: _\n    }, /*#__PURE__*/E.createElement(o.Root, w({\n      asChild: !0\n    }, K, {\n      dir: S.dir,\n      orientation: \"vertical\",\n      loop: u,\n      currentTabStopId: U,\n      onCurrentTabStopIdChange: V,\n      onEntryFocus: e => {\n        S.isUsingKeyboardRef.current || e.preventDefault();\n      }\n    }), /*#__PURE__*/E.createElement(a.Content, w({\n      role: \"menu\",\n      \"aria-orientation\": \"vertical\",\n      \"data-state\": j(S.open),\n      dir: S.dir\n    }, L, D, {\n      ref: B,\n      style: {\n        outline: \"none\",\n        ...D.style\n      },\n      onKeyDown: M(D.onKeyDown, e => {\n        const n = e.target,\n          t = e.currentTarget.contains(n),\n          r = e.ctrlKey || e.altKey || e.metaKey,\n          o = 1 === e.key.length;\n        t && (\"Tab\" === e.key && e.preventDefault(), !r && o && ee(e.key));\n        const u = X.current;\n        if (e.target !== u) return;\n        if (!R.includes(e.key)) return;\n        e.preventDefault();\n        const c = G().filter(e => !e.disabled).map(e => e.ref.current);\n        b.includes(e.key) && c.reverse(), function (e) {\n          const n = document.activeElement;\n          for (const t of e) {\n            if (t === n) return;\n            if (t.focus(), document.activeElement !== n) return;\n          }\n        }(c);\n      }),\n      onBlur: M(e.onBlur, e => {\n        e.currentTarget.contains(e.target) || (window.clearTimeout(Y.current), Z.current = \"\");\n      }),\n      onPointerMove: M(e.onPointerMove, J(e => {\n        const n = e.target,\n          t = q.current !== e.clientX;\n        if (e.currentTarget.contains(n) && t) {\n          const n = e.clientX > q.current ? \"right\" : \"left\";\n          W.current = n, q.current = e.clientX;\n        }\n      }))\n    }))))))));\n  });\nexport const MenuGroup = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n    __scopeMenu: t,\n    ...r\n  } = e; /*#__PURE__*/\n  return E.createElement(s.div, w({\n    role: \"group\"\n  }, r, {\n    ref: n\n  }));\n}); /*#__PURE__*/\nexport const MenuLabel = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n    __scopeMenu: t,\n    ...r\n  } = e; /*#__PURE__*/\n  return E.createElement(s.div, w({}, r, {\n    ref: n\n  }));\n}); /*#__PURE__*/\nexport const MenuItem = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n      disabled: t = !1,\n      onSelect: r,\n      ...o\n    } = e,\n    u = E.useRef(null),\n    c = A(\"MenuItem\", e.__scopeMenu),\n    a = K(\"MenuItem\", e.__scopeMenu),\n    i = m(n, u),\n    s = E.useRef(!1); /*#__PURE__*/\n  return E.createElement(Y, w({}, o, {\n    ref: i,\n    disabled: t,\n    onClick: M(e.onClick, () => {\n      const e = u.current;\n      if (!t && e) {\n        const n = new Event(\"menu.itemSelect\", {\n          bubbles: !0,\n          cancelable: !0\n        });\n        e.addEventListener(\"menu.itemSelect\", e => null == r ? void 0 : r(e), {\n          once: !0\n        }), e.dispatchEvent(n), n.defaultPrevented ? s.current = !1 : c.onRootClose();\n      }\n    }),\n    onPointerDown: n => {\n      var t;\n      null === (t = e.onPointerDown) || void 0 === t || t.call(e, n), s.current = !0;\n    },\n    onPointerUp: M(e.onPointerUp, e => {\n      var n;\n      s.current || null === (n = e.currentTarget) || void 0 === n || n.click();\n    }),\n    onKeyDown: M(e.onKeyDown, e => {\n      const n = \"\" !== a.searchRef.current;\n      t || n && \" \" === e.key || x.includes(e.key) && (e.currentTarget.click(), e.preventDefault());\n    })\n  }));\n}); /*#__PURE__*/\nexport const MenuSubTrigger = /*#__PURE__*/E.forwardRef((e, n) => {\n  const t = A(\"MenuSubTrigger\", e.__scopeMenu),\n    r = K(\"MenuSubTrigger\", e.__scopeMenu),\n    o = E.useRef(null),\n    {\n      pointerGraceTimerRef: u,\n      onPointerGraceIntentChange: c\n    } = r,\n    a = {\n      __scopeMenu: e.__scopeMenu\n    },\n    i = E.useCallback(() => {\n      o.current && window.clearTimeout(o.current), o.current = null;\n    }, []);\n  return E.useEffect(() => i, [i]), E.useEffect(() => {\n    const e = u.current;\n    return () => {\n      window.clearTimeout(e), c(null);\n    };\n  }, [u, c]), t.isSubmenu ? /*#__PURE__*/E.createElement(MenuAnchor, w({\n    asChild: !0\n  }, a), /*#__PURE__*/E.createElement(Y, w({\n    id: t.triggerId,\n    \"aria-haspopup\": \"menu\",\n    \"aria-expanded\": t.open,\n    \"aria-controls\": t.contentId,\n    \"data-state\": j(t.open)\n  }, e, {\n    ref: v(n, t.onTriggerChange),\n    onClick: n => {\n      var r;\n      null === (r = e.onClick) || void 0 === r || r.call(e, n), e.disabled || n.defaultPrevented || (n.currentTarget.focus(), t.open || t.onOpenChange(!0));\n    },\n    onPointerMove: M(e.onPointerMove, J(n => {\n      r.onItemEnter(n), n.defaultPrevented || e.disabled || t.open || o.current || (r.onPointerGraceIntentChange(null), o.current = window.setTimeout(() => {\n        t.onOpenChange(!0), i();\n      }, 100));\n    })),\n    onPointerLeave: M(e.onPointerLeave, J(e => {\n      var n;\n      i();\n      const o = null === (n = t.content) || void 0 === n ? void 0 : n.getBoundingClientRect();\n      if (o) {\n        var c;\n        const n = null === (c = t.content) || void 0 === c ? void 0 : c.dataset.side,\n          a = \"right\" === n,\n          i = a ? -5 : 5,\n          s = o[a ? \"left\" : \"right\"],\n          l = o[a ? \"right\" : \"left\"];\n        r.onPointerGraceIntentChange({\n          area: [{\n            x: e.clientX + i,\n            y: e.clientY\n          }, {\n            x: s,\n            y: o.top\n          }, {\n            x: l,\n            y: o.top\n          }, {\n            x: l,\n            y: o.bottom\n          }, {\n            x: s,\n            y: o.bottom\n          }],\n          side: n\n        }), window.clearTimeout(u.current), u.current = window.setTimeout(() => r.onPointerGraceIntentChange(null), 300);\n      } else {\n        if (r.onTriggerLeave(e), e.defaultPrevented) return;\n        r.onPointerGraceIntentChange(null);\n      }\n    })),\n    onKeyDown: M(e.onKeyDown, n => {\n      const o = \"\" !== r.searchRef.current;\n      var u;\n      e.disabled || o && \" \" === n.key || _[t.dir].includes(n.key) && (t.onOpenChange(!0), null === (u = t.content) || void 0 === u || u.focus(), n.preventDefault());\n    })\n  }))) : null;\n}); /*#__PURE__*/\nconst Y = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n      __scopeMenu: t,\n      disabled: r = !1,\n      textValue: u,\n      ...c\n    } = e,\n    a = K(\"MenuItem\", t),\n    i = T(t),\n    l = E.useRef(null),\n    d = m(n, l),\n    [p, f] = E.useState(\"\");\n  return E.useEffect(() => {\n    const e = l.current;\n    var n;\n    e && f((null !== (n = e.textContent) && void 0 !== n ? n : \"\").trim());\n  }, [c.children]), /*#__PURE__*/E.createElement(I.ItemSlot, {\n    scope: t,\n    disabled: r,\n    textValue: null != u ? u : p\n  }, /*#__PURE__*/E.createElement(o.Item, w({\n    asChild: !0\n  }, i, {\n    focusable: !r\n  }), /*#__PURE__*/E.createElement(s.div, w({\n    role: \"menuitem\",\n    \"aria-disabled\": r || void 0,\n    \"data-disabled\": r ? \"\" : void 0\n  }, c, {\n    ref: d,\n    onPointerMove: M(e.onPointerMove, J(e => {\n      if (r) a.onItemLeave(e);else if (a.onItemEnter(e), !e.defaultPrevented) {\n        e.currentTarget.focus();\n      }\n    })),\n    onPointerLeave: M(e.onPointerLeave, J(e => a.onItemLeave(e)))\n  }))));\n});\nexport const MenuCheckboxItem = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n    checked: t = !1,\n    onCheckedChange: r,\n    ...o\n  } = e; /*#__PURE__*/\n  return E.createElement(H, {\n    scope: e.__scopeMenu,\n    checked: t\n  }, /*#__PURE__*/E.createElement(MenuItem, w({\n    role: \"menuitemcheckbox\",\n    \"aria-checked\": t\n  }, o, {\n    ref: n,\n    \"data-state\": q(t),\n    onSelect: M(o.onSelect, () => null == r ? void 0 : r(!t), {\n      checkForDefaultPrevented: !1\n    })\n  })));\n}); /*#__PURE__*/\nconst [Z, z] = D(\"MenuRadioGroup\", {\n  value: void 0,\n  onValueChange: () => {}\n});\nexport const MenuRadioGroup = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n      value: r,\n      onValueChange: o,\n      ...u\n    } = e,\n    c = t(o); /*#__PURE__*/\n  return E.createElement(Z, {\n    scope: e.__scopeMenu,\n    value: r,\n    onValueChange: c\n  }, /*#__PURE__*/E.createElement(MenuGroup, w({}, u, {\n    ref: n\n  })));\n}); /*#__PURE__*/\nexport const MenuRadioItem = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n      value: t,\n      ...r\n    } = e,\n    o = z(\"MenuRadioItem\", e.__scopeMenu),\n    u = t === o.value; /*#__PURE__*/\n  return E.createElement(H, {\n    scope: e.__scopeMenu,\n    checked: u\n  }, /*#__PURE__*/E.createElement(MenuItem, w({\n    role: \"menuitemradio\",\n    \"aria-checked\": u\n  }, r, {\n    ref: n,\n    \"data-state\": q(u),\n    onSelect: M(r.onSelect, () => {\n      var e;\n      return null === (e = o.onValueChange) || void 0 === e ? void 0 : e.call(o, t);\n    }, {\n      checkForDefaultPrevented: !1\n    })\n  })));\n}); /*#__PURE__*/\nconst [H, W] = D(\"MenuItemIndicator\", {\n  checked: !1\n});\nexport const MenuItemIndicator = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n      __scopeMenu: t,\n      forceMount: r,\n      ...o\n    } = e,\n    u = W(\"MenuItemIndicator\", t); /*#__PURE__*/\n  return E.createElement(l, {\n    present: r || u.checked\n  }, /*#__PURE__*/E.createElement(s.span, w({}, o, {\n    ref: n,\n    \"data-state\": q(u.checked)\n  })));\n}); /*#__PURE__*/\nexport const MenuSeparator = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n    __scopeMenu: t,\n    ...r\n  } = e; /*#__PURE__*/\n  return E.createElement(s.div, w({\n    role: \"separator\",\n    \"aria-orientation\": \"horizontal\"\n  }, r, {\n    ref: n\n  }));\n}); /*#__PURE__*/\nexport const MenuArrow = /*#__PURE__*/E.forwardRef((e, n) => {\n  const {\n      __scopeMenu: t,\n      ...r\n    } = e,\n    o = O(t); /*#__PURE__*/\n  return E.createElement(a.Arrow, w({}, o, r, {\n    ref: n\n  }));\n}); /*#__PURE__*/\nfunction j(e) {\n  return e ? \"open\" : \"closed\";\n}\nfunction q(e) {\n  return e ? \"checked\" : \"unchecked\";\n}\nfunction J(e) {\n  return n => \"mouse\" === n.pointerType ? e(n) : void 0;\n}\nexport const Root = Menu;\nexport const Sub = MenuSub;\nexport const Anchor = MenuAnchor;\nexport const SubTrigger = MenuSubTrigger;\nexport const Content = MenuContent;\nexport const Group = MenuGroup;\nexport const Label = MenuLabel;\nexport const Item = MenuItem;\nexport const CheckboxItem = MenuCheckboxItem;\nexport const RadioGroup = MenuRadioGroup;\nexport const RadioItem = MenuRadioItem;\nexport const ItemIndicator = MenuItemIndicator;\nexport const Separator = MenuSeparator;\nexport const Arrow = MenuArrow;","map":{"version":3,"mappings":"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","names":["SELECTION_KEYS","LAST_KEYS","FIRST_LAST_KEYS","SUB_OPEN_KEYS","ltr","rtl","SUB_CLOSE_KEYS","Collection","useCollection","createCollectionScope","createCollection","createMenuContext","createMenuScope","createContextScope","createPopperScope","createRovingFocusGroupScope","usePopperScope","useRovingFocusGroupScope","MenuProvider","useMenuContext","Menu","props","__scopeMenu","open","children","onOpenChange","modal","popperScope","content","setContent","React","useState","isUsingKeyboardRef","useRef","handleOpenChange","useCallbackRef","computedDirection","useDirection","dir","useEffect","handleKeyDown","current","document","addEventListener","handlePointer","capture","once","removeEventListener","_react","_radixUiReactPopper","Root","$e9e2cf92950df0b951e7bac95d18$var$MenuProvider","scope","isSubmenu","onContentChange","onRootClose","useCallback","MenuSub","parentMenuContext","trigger","setTrigger","contentId","useId","onTriggerChange","triggerId","MenuAnchor","forwardRef","forwardedRef","anchorProps","Anchor","_babelRuntimeHelpersEsmExtends","ref","MenuContentProvider","useMenuContentContext","MenuContent","forceMount","contentProps","context","$e9e2cf92950df0b951e7bac95d18$var$Collection","Provider","Presence","present","Slot","$e9e2cf92950df0b951e7bac95d18$var$MenuSubContent","$e9e2cf92950df0b951e7bac95d18$var$MenuRootContent","MenuRootContent","$e9e2cf92950df0b951e7bac95d18$var$MenuRootContentModal","$e9e2cf92950df0b951e7bac95d18$var$MenuRootContentNonModal","MenuRootContentModal","composedRefs","useComposedRefs","hideOthers","$e9e2cf92950df0b951e7bac95d18$var$MenuContentImpl","trapFocus","disableOutsidePointerEvents","disableOutsideScroll","onFocusOutside","composeEventHandlers","event","preventDefault","checkForDefaultPrevented","onDismiss","MenuRootContentNonModal","MenuSubContent","id","align","side","portalled","onOpenAutoFocus","focus","onCloseAutoFocus","target","onEscapeKeyDown","onKeyDown","isKeyDownInside","currentTarget","contains","isCloseKey","includes","key","MenuContentImpl","loop","onPointerDownOutside","onInteractOutside","allowPinchZoom","rovingFocusGroupScope","getItems","currentItemId","setCurrentItemId","contentRef","timerRef","searchRef","pointerGraceTimerRef","pointerGraceIntentRef","pointerDirRef","lastPointerXRef","PortalWrapper","Portal","Fragment","ScrollLockWrapper","RemoveScroll","scrollLockWrapperProps","undefined","handleTypeaheadSearch","search","items","filter","item","disabled","currentItem","activeElement","currentMatch","find","_items$find","textValue","nextMatch","values","normalizedSearch","length","Array","from","every","char","currentMatchIndex","indexOf","wrappedValues","array","startIndex","Math","max","map","_","index","v","value","toLowerCase","startsWith","getNextMatch","newItem","_items$find2","updateSearch","window","clearTimeout","setTimeout","useFocusGuards","isPointerMovingToSubmenu","_pointerGraceIntentRe","area","point","polygon","x","y","inside","i","j","xi","yi","xj","yj","isPointInPolygon","clientX","clientY","isPointerInGraceArea","_pointerGraceIntentRe2","$e9e2cf92950df0b951e7bac95d18$var$MenuContentProvider","onItemEnter","onItemLeave","onTriggerLeave","onPointerGraceIntentChange","intent","FocusScope","asChild","trapped","onMountAutoFocus","onUnmountAutoFocus","DismissableLayer","_radixUiReactRovingFocus","orientation","currentTabStopId","onCurrentTabStopIdChange","onEntryFocus","Content","role","getOpenState","style","outline","isModifierKey","ctrlKey","altKey","metaKey","isCharacterKey","candidateNodes","reverse","candidates","PREVIOUSLY_FOCUSED_ELEMENT","candidate","focusFirst","onBlur","onPointerMove","whenMouse","pointerXHasChanged","newDir","MenuGroup","groupProps","Primitive","div","MenuLabel","labelProps","MenuItem","onSelect","itemProps","contentContext","isPointerDownRef","$e9e2cf92950df0b951e7bac95d18$var$MenuItemImpl","onClick","menuItem","itemSelectEvent","Event","bubbles","cancelable","dispatchEvent","defaultPrevented","onPointerDown","onPointerUp","click","isTypingAhead","MenuSubTrigger","openTimerRef","clearOpenTimer","pointerGraceTimer","composeRefs","onPointerLeave","contentRect","_context$content","getBoundingClientRect","_context$content2","dataset","rightSide","bleed","contentNearEdge","contentFarEdge","top","bottom","MenuItemImpl","textContent","setTextContent","trim","ItemSlot","Item","focusable","MenuCheckboxItem","checked","onCheckedChange","checkboxItemProps","$e9e2cf92950df0b951e7bac95d18$var$ItemIndicatorProvider","getCheckedState","RadioGroupProvider","useRadioGroupContext","onValueChange","MenuRadioGroup","handleValueChange","$e9e2cf92950df0b951e7bac95d18$var$RadioGroupProvider","MenuRadioItem","radioItemProps","_context$onValueChang","ItemIndicatorProvider","useItemIndicatorContext","MenuItemIndicator","itemIndicatorProps","indicatorContext","span","MenuSeparator","separatorProps","MenuArrow","arrowProps","Arrow","handler","pointerType","Sub","SubTrigger","Group","Label","CheckboxItem","RadioGroup","RadioItem","ItemIndicator","Separator"],"sources":["C:\\Users\\weida\\Desktop\\playground_CC\\node_modules\\@aws-amplify\\ui-react\\node_modules\\@radix-ui\\react-dropdown-menu\\node_modules\\@radix-ui\\react-menu\\dist\\packages\\react\\menu\\src\\Menu.tsx"],"sourcesContent":["import * as React from 'react';\nimport { RemoveScroll } from 'react-remove-scroll';\nimport { hideOthers } from 'aria-hidden';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs, composeRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { useDirection } from '@radix-ui/react-use-direction';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { useId } from '@radix-ui/react-id';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst SELECTION_KEYS = ['Enter', ' '];\nconst FIRST_KEYS = ['ArrowDown', 'PageUp', 'Home'];\nconst LAST_KEYS = ['ArrowUp', 'PageDown', 'End'];\nconst FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nconst SUB_OPEN_KEYS: Record<Direction, string[]> = {\n  ltr: [...SELECTION_KEYS, 'ArrowRight'],\n  rtl: [...SELECTION_KEYS, 'ArrowLeft'],\n};\nconst SUB_CLOSE_KEYS: Record<Direction, string[]> = {\n  ltr: ['ArrowLeft'],\n  rtl: ['ArrowRight'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Menu\n * -----------------------------------------------------------------------------------------------*/\n\nconst MENU_NAME = 'Menu';\n\ntype ItemData = { disabled: boolean; textValue: string };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  MenuItemElement,\n  ItemData\n>(MENU_NAME);\n\ntype ScopedProps<P> = P & { __scopeMenu?: Scope };\nconst [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [\n  createCollectionScope,\n  createPopperScope,\n  createRovingFocusGroupScope,\n]);\nconst usePopperScope = createPopperScope();\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\ntype MenuRootContextValue = {\n  isSubmenu: false;\n  isUsingKeyboardRef: React.RefObject<boolean>;\n  dir: Direction;\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  content: MenuContentElement | null;\n  onContentChange(content: MenuContentElement | null): void;\n  onRootClose(): void;\n  modal: boolean;\n};\n\ntype MenuSubContextValue = Omit<MenuRootContextValue, 'isSubmenu'> & {\n  isSubmenu: true;\n  contentId: string;\n  triggerId: string;\n  trigger: MenuSubTriggerElement | null;\n  onTriggerChange(trigger: MenuSubTriggerElement | null): void;\n};\n\nconst [MenuProvider, useMenuContext] = createMenuContext<\n  MenuRootContextValue | MenuSubContextValue\n>(MENU_NAME);\n\ninterface MenuProps {\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n  dir?: Direction;\n  modal?: boolean;\n  children?: React.ReactNode;\n}\n\nconst Menu: React.FC<MenuProps> = (props: ScopedProps<MenuProps>) => {\n  const { __scopeMenu, open = false, children, onOpenChange, modal = true } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const isUsingKeyboardRef = React.useRef(false);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  const computedDirection = useDirection(content, props.dir);\n\n  React.useEffect(() => {\n    // Capture phase ensures we set the boolean before any side effects execute\n    // in response to the key or pointer event as they might depend on this value.\n    const handleKeyDown = () => {\n      isUsingKeyboardRef.current = true;\n      document.addEventListener('pointerdown', handlePointer, { capture: true, once: true });\n      document.addEventListener('pointermove', handlePointer, { capture: true, once: true });\n    };\n    const handlePointer = () => (isUsingKeyboardRef.current = false);\n    document.addEventListener('keydown', handleKeyDown, { capture: true });\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown, { capture: true });\n      document.removeEventListener('pointerdown', handlePointer, { capture: true });\n      document.removeEventListener('pointermove', handlePointer, { capture: true });\n    };\n  }, []);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        isSubmenu={false}\n        isUsingKeyboardRef={isUsingKeyboardRef}\n        dir={computedDirection}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n        onRootClose={React.useCallback(() => handleOpenChange(false), [handleOpenChange])}\n        modal={modal}\n      >\n        {children}\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenu.displayName = MENU_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst SUB_NAME = 'MenuSub';\n\ninterface MenuSubProps {\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n  children?: React.ReactNode;\n}\n\nconst MenuSub: React.FC<MenuSubProps> = (props: ScopedProps<MenuSubProps>) => {\n  const { __scopeMenu, children, open = false, onOpenChange } = props;\n  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const [trigger, setTrigger] = React.useState<MenuSubTriggerElement | null>(null);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n\n  // Prevent the parent menu from reopening with open submenus.\n  React.useEffect(() => {\n    if (parentMenuContext.open === false) handleOpenChange(false);\n    return () => handleOpenChange(false);\n  }, [parentMenuContext.open, handleOpenChange]);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        isSubmenu={true}\n        isUsingKeyboardRef={parentMenuContext.isUsingKeyboardRef}\n        dir={parentMenuContext.dir}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n        onRootClose={parentMenuContext.onRootClose}\n        contentId={useId()}\n        trigger={trigger}\n        onTriggerChange={setTrigger}\n        triggerId={useId()}\n        modal={false}\n      >\n        {children}\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenuSub.displayName = SUB_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'MenuAnchor';\n\ntype MenuAnchorElement = React.ElementRef<typeof PopperPrimitive.Anchor>;\ntype PopperAnchorProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Anchor>;\ninterface MenuAnchorProps extends PopperAnchorProps {}\n\nconst MenuAnchor = React.forwardRef<MenuAnchorElement, MenuAnchorProps>(\n  (props: ScopedProps<MenuAnchorProps>, forwardedRef) => {\n    const { __scopeMenu, ...anchorProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Anchor {...popperScope} {...anchorProps} ref={forwardedRef} />;\n  }\n);\n\nMenuAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'MenuContent';\n\ntype MenuContentContextValue = {\n  onItemEnter(event: React.PointerEvent): void;\n  onItemLeave(event: React.PointerEvent): void;\n  onTriggerLeave(event: React.PointerEvent): void;\n  searchRef: React.RefObject<string>;\n  pointerGraceTimerRef: React.MutableRefObject<number>;\n  onPointerGraceIntentChange(intent: GraceIntent | null): void;\n};\nconst [MenuContentProvider, useMenuContentContext] =\n  createMenuContext<MenuContentContextValue>(CONTENT_NAME);\n\ntype MenuContentElement = MenuRootContentElement | MenuSubContentElement;\n/**\n * We purposefully don't union MenuRootContent and MenuSubContent props here because\n * they have conflicting prop types. We agreed that we would allow MenuSubContent to\n * accept props that it would just ignore.\n */\ninterface MenuContentProps extends MenuRootContentProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuContent = React.forwardRef<MenuContentElement, MenuContentProps>(\n  (props: ScopedProps<MenuContentProps>, forwardedRef) => {\n    const { forceMount, ...contentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            {context.isSubmenu ? (\n              <MenuSubContent {...contentProps} ref={forwardedRef} />\n            ) : (\n              <MenuRootContent {...contentProps} ref={forwardedRef} />\n            )}\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuRootContentElement = MenuRootContentTypeElement;\ninterface MenuRootContentProps\n  extends Omit<MenuRootContentTypeProps, keyof MenuContentImplPrivateProps> {}\n\nconst MenuRootContent = React.forwardRef<MenuRootContentElement, MenuRootContentProps>(\n  (props: ScopedProps<MenuRootContentProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    return context.modal ? (\n      <MenuRootContentModal {...props} ref={forwardedRef} />\n    ) : (\n      <MenuRootContentNonModal {...props} ref={forwardedRef} />\n    );\n  }\n);\n\ntype MenuRootContentTypeElement = MenuContentImplElement;\ninterface MenuRootContentTypeProps\n  extends Omit<\n    MenuContentImplProps,\n    'trapFocus' | 'disableOutsidePointerEvents' | 'disableOutsideScroll'\n  > {}\n\nconst MenuRootContentModal = React.forwardRef<MenuRootContentTypeElement, MenuRootContentTypeProps>(\n  (props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuRootContentTypeElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    // Hide everything from ARIA except the `MenuContent`\n    React.useEffect(() => {\n      const content = ref.current;\n      if (content) return hideOthers(content);\n    }, []);\n\n    return (\n      <MenuContentImpl\n        {...props}\n        ref={composedRefs}\n        // we make sure we're not trapping once it's been closed\n        // (closed !== unmounted when animating out)\n        trapFocus={context.open}\n        // make sure to only disable pointer events when open\n        // this avoids blocking interactions while animating out\n        disableOutsidePointerEvents={context.open}\n        disableOutsideScroll\n        // When focus is trapped, a `focusout` event may still happen.\n        // We make sure we don't trigger our `onDismiss` in such case.\n        onFocusOutside={composeEventHandlers(\n          props.onFocusOutside,\n          (event) => event.preventDefault(),\n          { checkForDefaultPrevented: false }\n        )}\n        onDismiss={() => context.onOpenChange(false)}\n      />\n    );\n  }\n);\n\nconst MenuRootContentNonModal = React.forwardRef<\n  MenuRootContentTypeElement,\n  MenuRootContentTypeProps\n>((props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  return (\n    <MenuContentImpl\n      {...props}\n      ref={forwardedRef}\n      trapFocus={false}\n      disableOutsidePointerEvents={false}\n      disableOutsideScroll={false}\n      onDismiss={() => context.onOpenChange(false)}\n    />\n  );\n});\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuSubContentElement = MenuContentImplElement;\ninterface MenuSubContentProps\n  extends Omit<\n    MenuContentImplProps,\n    | keyof MenuContentImplPrivateProps\n    | 'align'\n    | 'side'\n    | 'portalled'\n    | 'disabledOutsidePointerEvents'\n    | 'disableOutsideScroll'\n    | 'trapFocus'\n    | 'onCloseAutoFocus'\n  > {}\n\nconst MenuSubContent = React.forwardRef<MenuSubContentElement, MenuSubContentProps>(\n  (props: ScopedProps<MenuSubContentProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuSubContentElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    return context.isSubmenu ? (\n      <MenuContentImpl\n        id={context.contentId}\n        aria-labelledby={context.triggerId}\n        {...props}\n        ref={composedRefs}\n        align=\"start\"\n        side={context.dir === 'rtl' ? 'left' : 'right'}\n        portalled\n        disableOutsidePointerEvents={false}\n        disableOutsideScroll={false}\n        trapFocus={false}\n        onOpenAutoFocus={(event) => {\n          // when opening a submenu, focus content for keyboard users only\n          if (context.isUsingKeyboardRef.current) ref.current?.focus();\n          event.preventDefault();\n        }}\n        // The menu might close because of focusing another menu item in the parent menu. We\n        // don't want it to refocus the trigger in that case so we handle trigger focus ourselves.\n        onCloseAutoFocus={(event) => event.preventDefault()}\n        onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) => {\n          // We prevent closing when the trigger is focused to avoid triggering a re-open animation\n          // on pointer interaction.\n          if (event.target !== context.trigger) context.onOpenChange(false);\n        })}\n        onEscapeKeyDown={composeEventHandlers(props.onEscapeKeyDown, context.onRootClose)}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          // Submenu key events bubble through portals. We only care about keys in this menu.\n          const isKeyDownInside = event.currentTarget.contains(event.target as HTMLElement);\n          const isCloseKey = SUB_CLOSE_KEYS[context.dir].includes(event.key);\n          if (isKeyDownInside && isCloseKey) {\n            context.onOpenChange(false);\n            // We focus manually because we prevented it in `onCloseAutoFocus`\n            context.trigger?.focus();\n            // prevent window from scrolling\n            event.preventDefault();\n          }\n        })}\n      />\n    ) : null;\n  }\n);\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype RemoveScrollProps = React.ComponentProps<typeof RemoveScroll>;\ntype MenuContentImplElement = React.ElementRef<typeof PopperPrimitive.Content>;\ntype FocusScopeProps = Radix.ComponentPropsWithoutRef<typeof FocusScope>;\ntype DismissableLayerProps = Radix.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype RovingFocusGroupProps = Radix.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype PopperContentProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ntype MenuContentImplPrivateProps = {\n  onOpenAutoFocus?: FocusScopeProps['onMountAutoFocus'];\n  onDismiss?: DismissableLayerProps['onDismiss'];\n};\ninterface MenuContentImplProps\n  extends MenuContentImplPrivateProps,\n    PopperContentProps,\n    Omit<DismissableLayerProps, 'onDismiss'> {\n  /**\n   * Whether focus should be trapped within the `MenuContent`\n   * (default: false)\n   */\n  trapFocus?: FocusScopeProps['trapped'];\n\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n\n  /**\n   * @see https://github.com/theKashey/react-remove-scroll#usage\n   */\n  allowPinchZoom?: RemoveScrollProps['allowPinchZoom'];\n\n  /**\n   * Whether scrolling outside the `MenuContent` should be prevented\n   * (default: `false`)\n   */\n  disableOutsideScroll?: boolean;\n\n  /**\n   * The direction of navigation between menu items.\n   * @defaultValue ltr\n   */\n  dir?: RovingFocusGroupProps['dir'];\n\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: RovingFocusGroupProps['loop'];\n\n  /**\n   * Whether the `MenuContent` should render in a `Portal`\n   * (default: `true`)\n   */\n  portalled?: boolean;\n}\n\nconst MenuContentImpl = React.forwardRef<MenuContentImplElement, MenuContentImplProps>(\n  (props: ScopedProps<MenuContentImplProps>, forwardedRef) => {\n    const {\n      __scopeMenu,\n      loop = false,\n      trapFocus,\n      onOpenAutoFocus,\n      onCloseAutoFocus,\n      disableOutsidePointerEvents,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      disableOutsideScroll,\n      allowPinchZoom,\n      portalled,\n      ...contentProps\n    } = props;\n    const context = useMenuContext(CONTENT_NAME, __scopeMenu);\n    const popperScope = usePopperScope(__scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const getItems = useCollection(__scopeMenu);\n    const [currentItemId, setCurrentItemId] = React.useState<string | null>(null);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);\n    const timerRef = React.useRef(0);\n    const searchRef = React.useRef('');\n    const pointerGraceTimerRef = React.useRef(0);\n    const pointerGraceIntentRef = React.useRef<GraceIntent | null>(null);\n    const pointerDirRef = React.useRef<Side>('right');\n    const lastPointerXRef = React.useRef(0);\n\n    const PortalWrapper = portalled ? Portal : React.Fragment;\n    const ScrollLockWrapper = disableOutsideScroll ? RemoveScroll : React.Fragment;\n    const scrollLockWrapperProps = disableOutsideScroll ? { allowPinchZoom } : undefined;\n\n    const handleTypeaheadSearch = (key: string) => {\n      const search = searchRef.current + key;\n      const items = getItems().filter((item) => !item.disabled);\n      const currentItem = document.activeElement;\n      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;\n      const values = items.map((item) => item.textValue);\n      const nextMatch = getNextMatch(values, search, currentMatch);\n      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;\n\n      // Reset `searchRef` 1 second after it was last updated\n      (function updateSearch(value: string) {\n        searchRef.current = value;\n        window.clearTimeout(timerRef.current);\n        if (value !== '') timerRef.current = window.setTimeout(() => updateSearch(''), 1000);\n      })(search);\n\n      if (newItem) {\n        /**\n         * Imperative focus during keydown is risky so we prevent React's batching updates\n         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n         */\n        setTimeout(() => (newItem as HTMLElement).focus());\n      }\n    };\n\n    React.useEffect(() => {\n      return () => window.clearTimeout(timerRef.current);\n    }, []);\n\n    // Make sure the whole tree has focus guards as our `MenuContent` may be\n    // the last element in the DOM (beacuse of the `Portal`)\n    useFocusGuards();\n\n    const isPointerMovingToSubmenu = React.useCallback((event: React.PointerEvent) => {\n      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;\n      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);\n    }, []);\n\n    return (\n      <PortalWrapper>\n        <ScrollLockWrapper {...scrollLockWrapperProps}>\n          <MenuContentProvider\n            scope={__scopeMenu}\n            searchRef={searchRef}\n            onItemEnter={React.useCallback(\n              (event) => {\n                if (isPointerMovingToSubmenu(event)) event.preventDefault();\n              },\n              [isPointerMovingToSubmenu]\n            )}\n            onItemLeave={React.useCallback(\n              (event) => {\n                if (isPointerMovingToSubmenu(event)) return;\n                contentRef.current?.focus();\n                setCurrentItemId(null);\n              },\n              [isPointerMovingToSubmenu]\n            )}\n            onTriggerLeave={React.useCallback(\n              (event) => {\n                if (isPointerMovingToSubmenu(event)) event.preventDefault();\n              },\n              [isPointerMovingToSubmenu]\n            )}\n            pointerGraceTimerRef={pointerGraceTimerRef}\n            onPointerGraceIntentChange={React.useCallback((intent) => {\n              pointerGraceIntentRef.current = intent;\n            }, [])}\n          >\n            <FocusScope\n              asChild\n              trapped={trapFocus}\n              onMountAutoFocus={composeEventHandlers(onOpenAutoFocus, (event) => {\n                // when opening, explicitly focus the content area only and leave\n                // `onEntryFocus` in  control of focusing first item\n                event.preventDefault();\n                contentRef.current?.focus();\n              })}\n              onUnmountAutoFocus={onCloseAutoFocus}\n            >\n              <DismissableLayer\n                asChild\n                disableOutsidePointerEvents={disableOutsidePointerEvents}\n                onEscapeKeyDown={onEscapeKeyDown}\n                onPointerDownOutside={onPointerDownOutside}\n                onFocusOutside={onFocusOutside}\n                onInteractOutside={onInteractOutside}\n                onDismiss={onDismiss}\n              >\n                <RovingFocusGroup.Root\n                  asChild\n                  {...rovingFocusGroupScope}\n                  dir={context.dir}\n                  orientation=\"vertical\"\n                  loop={loop}\n                  currentTabStopId={currentItemId}\n                  onCurrentTabStopIdChange={setCurrentItemId}\n                  onEntryFocus={(event) => {\n                    // only focus first item when using keyboard\n                    if (!context.isUsingKeyboardRef.current) event.preventDefault();\n                  }}\n                >\n                  <PopperPrimitive.Content\n                    role=\"menu\"\n                    aria-orientation=\"vertical\"\n                    data-state={getOpenState(context.open)}\n                    dir={context.dir}\n                    {...popperScope}\n                    {...contentProps}\n                    ref={composedRefs}\n                    style={{ outline: 'none', ...contentProps.style }}\n                    onKeyDown={composeEventHandlers(contentProps.onKeyDown, (event) => {\n                      // submenu key events bubble through portals. We only care about keys in this menu.\n                      const target = event.target as HTMLElement;\n                      const isKeyDownInside = event.currentTarget.contains(target);\n                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n                      const isCharacterKey = event.key.length === 1;\n                      if (isKeyDownInside) {\n                        // menus should not be navigated using tab key so we prevent it\n                        if (event.key === 'Tab') event.preventDefault();\n                        if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);\n                      }\n                      // focus first/last item based on key pressed\n                      const content = contentRef.current;\n                      if (event.target !== content) return;\n                      if (!FIRST_LAST_KEYS.includes(event.key)) return;\n                      event.preventDefault();\n                      const items = getItems().filter((item) => !item.disabled);\n                      const candidateNodes = items.map((item) => item.ref.current!);\n                      if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();\n                      focusFirst(candidateNodes);\n                    })}\n                    onBlur={composeEventHandlers(props.onBlur, (event) => {\n                      // clear search buffer when leaving the menu\n                      if (!event.currentTarget.contains(event.target)) {\n                        window.clearTimeout(timerRef.current);\n                        searchRef.current = '';\n                      }\n                    })}\n                    onPointerMove={composeEventHandlers(\n                      props.onPointerMove,\n                      whenMouse((event) => {\n                        const target = event.target as HTMLElement;\n                        const pointerXHasChanged = lastPointerXRef.current !== event.clientX;\n\n                        // We don't use `event.movementX` for this check because Safari will\n                        // always return `0` on a pointer event.\n                        if (event.currentTarget.contains(target) && pointerXHasChanged) {\n                          const newDir = event.clientX > lastPointerXRef.current ? 'right' : 'left';\n                          pointerDirRef.current = newDir;\n                          lastPointerXRef.current = event.clientX;\n                        }\n                      })\n                    )}\n                  />\n                </RovingFocusGroup.Root>\n              </DismissableLayer>\n            </FocusScope>\n          </MenuContentProvider>\n        </ScrollLockWrapper>\n      </PortalWrapper>\n    );\n  }\n);\n\nMenuContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'MenuGroup';\n\ntype MenuGroupElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface MenuGroupProps extends PrimitiveDivProps {}\n\nconst MenuGroup = React.forwardRef<MenuGroupElement, MenuGroupProps>(\n  (props: ScopedProps<MenuGroupProps>, forwardedRef) => {\n    const { __scopeMenu, ...groupProps } = props;\n    return <Primitive.div role=\"group\" {...groupProps} ref={forwardedRef} />;\n  }\n);\n\nMenuGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'MenuLabel';\n\ntype MenuLabelElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuLabelProps extends PrimitiveDivProps {}\n\nconst MenuLabel = React.forwardRef<MenuLabelElement, MenuLabelProps>(\n  (props: ScopedProps<MenuLabelProps>, forwardedRef) => {\n    const { __scopeMenu, ...labelProps } = props;\n    return <Primitive.div {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nMenuLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'MenuItem';\nconst ITEM_SELECT = 'menu.itemSelect';\n\ntype MenuItemElement = MenuItemImplElement;\ninterface MenuItemProps extends Omit<MenuItemImplProps, 'onSelect'> {\n  onSelect?: (event: Event) => void;\n}\n\nconst MenuItem = React.forwardRef<MenuItemElement, MenuItemProps>(\n  (props: ScopedProps<MenuItemProps>, forwardedRef) => {\n    const { disabled = false, onSelect, ...itemProps } = props;\n    const ref = React.useRef<HTMLDivElement>(null);\n    const context = useMenuContext(ITEM_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(ITEM_NAME, props.__scopeMenu);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const isPointerDownRef = React.useRef(false);\n\n    const handleSelect = () => {\n      const menuItem = ref.current;\n      if (!disabled && menuItem) {\n        const itemSelectEvent = new Event(ITEM_SELECT, { bubbles: true, cancelable: true });\n        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });\n        menuItem.dispatchEvent(itemSelectEvent);\n        if (itemSelectEvent.defaultPrevented) {\n          isPointerDownRef.current = false;\n        } else {\n          context.onRootClose();\n        }\n      }\n    };\n\n    return (\n      <MenuItemImpl\n        {...itemProps}\n        ref={composedRefs}\n        disabled={disabled}\n        onClick={composeEventHandlers(props.onClick, handleSelect)}\n        onPointerDown={(event) => {\n          props.onPointerDown?.(event);\n          isPointerDownRef.current = true;\n        }}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          // Pointer down can move to a different menu item which should activate it on pointer up.\n          // We dispatch a click for selection to allow composition with click based triggers and to\n          // prevent Firefox from getting stuck in text selection mode when the menu closes.\n          if (!isPointerDownRef.current) event.currentTarget?.click();\n        })}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          const isTypingAhead = contentContext.searchRef.current !== '';\n          if (disabled || (isTypingAhead && event.key === ' ')) return;\n          if (SELECTION_KEYS.includes(event.key)) {\n            event.currentTarget.click();\n            /**\n             * We prevent default browser behaviour for selection keys as they should trigger\n             * a selection only:\n             * - prevents space from scrolling the page.\n             * - if keydown causes focus to move, prevents keydown from firing on the new target.\n             */\n            event.preventDefault();\n          }\n        })}\n      />\n    );\n  }\n);\n\nMenuItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_TRIGGER_NAME = 'MenuSubTrigger';\n\ntype MenuSubTriggerElement = MenuItemImplElement;\ninterface MenuSubTriggerProps extends MenuItemImplProps {}\n\nconst MenuSubTrigger = React.forwardRef<MenuSubTriggerElement, MenuSubTriggerProps>(\n  (props: ScopedProps<MenuSubTriggerProps>, forwardedRef) => {\n    const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const openTimerRef = React.useRef<number | null>(null);\n    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;\n    const scope = { __scopeMenu: props.__scopeMenu };\n\n    const clearOpenTimer = React.useCallback(() => {\n      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);\n      openTimerRef.current = null;\n    }, []);\n\n    React.useEffect(() => clearOpenTimer, [clearOpenTimer]);\n\n    React.useEffect(() => {\n      const pointerGraceTimer = pointerGraceTimerRef.current;\n      return () => {\n        window.clearTimeout(pointerGraceTimer);\n        onPointerGraceIntentChange(null);\n      };\n    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);\n\n    return context.isSubmenu ? (\n      <MenuAnchor asChild {...scope}>\n        <MenuItemImpl\n          id={context.triggerId}\n          aria-haspopup=\"menu\"\n          aria-expanded={context.open}\n          aria-controls={context.contentId}\n          data-state={getOpenState(context.open)}\n          {...props}\n          ref={composeRefs(forwardedRef, context.onTriggerChange)}\n          // This is redundant for mouse users but we cannot determine pointer type from\n          // click event and we cannot use pointerup event (see git history for reasons why)\n          onClick={(event) => {\n            props.onClick?.(event);\n            if (props.disabled || event.defaultPrevented) return;\n            /**\n             * We manually focus because iOS Safari doesn't always focus on click (e.g. buttons)\n             * and we rely heavily on `onFocusOutside` for submenus to close when switching\n             * between separate submenus.\n             */\n            event.currentTarget.focus();\n            if (!context.open) context.onOpenChange(true);\n          }}\n          onPointerMove={composeEventHandlers(\n            props.onPointerMove,\n            whenMouse((event) => {\n              contentContext.onItemEnter(event);\n              if (event.defaultPrevented) return;\n              if (!props.disabled && !context.open && !openTimerRef.current) {\n                contentContext.onPointerGraceIntentChange(null);\n                openTimerRef.current = window.setTimeout(() => {\n                  context.onOpenChange(true);\n                  clearOpenTimer();\n                }, 100);\n              }\n            })\n          )}\n          onPointerLeave={composeEventHandlers(\n            props.onPointerLeave,\n            whenMouse((event) => {\n              clearOpenTimer();\n\n              const contentRect = context.content?.getBoundingClientRect();\n              if (contentRect) {\n                // TODO: make sure to update this when we change positioning logic\n                const side = context.content?.dataset.side as Side;\n                const rightSide = side === 'right';\n                const bleed = rightSide ? -5 : +5;\n                const contentNearEdge = contentRect[rightSide ? 'left' : 'right'];\n                const contentFarEdge = contentRect[rightSide ? 'right' : 'left'];\n\n                contentContext.onPointerGraceIntentChange({\n                  area: [\n                    // Apply a bleed on clientX to ensure that our exit point is\n                    // consistently within polygon bounds\n                    { x: event.clientX + bleed, y: event.clientY },\n                    { x: contentNearEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.bottom },\n                    { x: contentNearEdge, y: contentRect.bottom },\n                  ],\n                  side,\n                });\n\n                window.clearTimeout(pointerGraceTimerRef.current);\n                pointerGraceTimerRef.current = window.setTimeout(\n                  () => contentContext.onPointerGraceIntentChange(null),\n                  300\n                );\n              } else {\n                contentContext.onTriggerLeave(event);\n                if (event.defaultPrevented) return;\n\n                // There's 100ms where the user may leave an item before the submenu was opened.\n                contentContext.onPointerGraceIntentChange(null);\n              }\n            })\n          )}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            const isTypingAhead = contentContext.searchRef.current !== '';\n            if (props.disabled || (isTypingAhead && event.key === ' ')) return;\n            if (SUB_OPEN_KEYS[context.dir].includes(event.key)) {\n              context.onOpenChange(true);\n              // The trigger may hold focus if opened via pointer interaction\n              // so we ensure content is given focus again when switching to keyboard.\n              context.content?.focus();\n              // prevent window from scrolling\n              event.preventDefault();\n            }\n          })}\n        />\n      </MenuAnchor>\n    ) : null;\n  }\n);\n\nMenuSubTrigger.displayName = SUB_TRIGGER_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuItemImplElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuItemImplProps extends PrimitiveDivProps {\n  disabled?: boolean;\n  textValue?: string;\n}\n\nconst MenuItemImpl = React.forwardRef<MenuItemImplElement, MenuItemImplProps>(\n  (props: ScopedProps<MenuItemImplProps>, forwardedRef) => {\n    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;\n    const contentContext = useMenuContentContext(ITEM_NAME, __scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const ref = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    // get the item's `.textContent` as default strategy for typeahead `textValue`\n    const [textContent, setTextContent] = React.useState('');\n    React.useEffect(() => {\n      const menuItem = ref.current;\n      if (menuItem) {\n        setTextContent((menuItem.textContent ?? '').trim());\n      }\n    }, [itemProps.children]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeMenu}\n        disabled={disabled}\n        textValue={textValue ?? textContent}\n      >\n        <RovingFocusGroup.Item asChild {...rovingFocusGroupScope} focusable={!disabled}>\n          <Primitive.div\n            role=\"menuitem\"\n            aria-disabled={disabled || undefined}\n            data-disabled={disabled ? '' : undefined}\n            {...itemProps}\n            ref={composedRefs}\n            /**\n             * We focus items on `pointerMove` to achieve the following:\n             *\n             * - Mouse over an item (it focuses)\n             * - Leave mouse where it is and use keyboard to focus a different item\n             * - Wiggle mouse without it leaving previously focused item\n             * - Previously focused item should re-focus\n             *\n             * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse\n             * wiggles. This is to match native menu implementation.\n             */\n            onPointerMove={composeEventHandlers(\n              props.onPointerMove,\n              whenMouse((event) => {\n                if (disabled) {\n                  contentContext.onItemLeave(event);\n                } else {\n                  contentContext.onItemEnter(event);\n                  if (!event.defaultPrevented) {\n                    const item = event.currentTarget;\n                    item.focus();\n                  }\n                }\n              })\n            )}\n            onPointerLeave={composeEventHandlers(\n              props.onPointerLeave,\n              whenMouse((event) => contentContext.onItemLeave(event))\n            )}\n          />\n        </RovingFocusGroup.Item>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * MenuCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'MenuCheckboxItem';\n\ntype MenuCheckboxItemElement = MenuItemElement;\ninterface MenuCheckboxItemProps extends MenuItemProps {\n  checked?: boolean;\n  onCheckedChange?: (checked: boolean) => void;\n}\n\nconst MenuCheckboxItem = React.forwardRef<MenuCheckboxItemElement, MenuCheckboxItemProps>(\n  (props: ScopedProps<MenuCheckboxItemProps>, forwardedRef) => {\n    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemcheckbox\"\n          aria-checked={checked}\n          {...checkboxItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            checkboxItemProps.onSelect,\n            () => onCheckedChange?.(!checked),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'MenuRadioGroup';\n\nconst [RadioGroupProvider, useRadioGroupContext] = createMenuContext<MenuRadioGroupProps>(\n  RADIO_GROUP_NAME,\n  { value: undefined, onValueChange: () => {} }\n);\n\ntype MenuRadioGroupElement = React.ElementRef<typeof MenuGroup>;\ninterface MenuRadioGroupProps extends MenuGroupProps {\n  value?: string;\n  onValueChange?: (value: string) => void;\n}\n\nconst MenuRadioGroup = React.forwardRef<MenuRadioGroupElement, MenuRadioGroupProps>(\n  (props: ScopedProps<MenuRadioGroupProps>, forwardedRef) => {\n    const { value, onValueChange, ...groupProps } = props;\n    const handleValueChange = useCallbackRef(onValueChange);\n    return (\n      <RadioGroupProvider scope={props.__scopeMenu} value={value} onValueChange={handleValueChange}>\n        <MenuGroup {...groupProps} ref={forwardedRef} />\n      </RadioGroupProvider>\n    );\n  }\n);\n\nMenuRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'MenuRadioItem';\n\ntype MenuRadioItemElement = React.ElementRef<typeof MenuItem>;\ninterface MenuRadioItemProps extends MenuItemProps {\n  value: string;\n}\n\nconst MenuRadioItem = React.forwardRef<MenuRadioItemElement, MenuRadioItemProps>(\n  (props: ScopedProps<MenuRadioItemProps>, forwardedRef) => {\n    const { value, ...radioItemProps } = props;\n    const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);\n    const checked = value === context.value;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemradio\"\n          aria-checked={checked}\n          {...radioItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            radioItemProps.onSelect,\n            () => context.onValueChange?.(value),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_INDICATOR_NAME = 'MenuItemIndicator';\n\nconst [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(ITEM_INDICATOR_NAME, {\n  checked: false,\n});\n\ntype MenuItemIndicatorElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface MenuItemIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuItemIndicator = React.forwardRef<MenuItemIndicatorElement, MenuItemIndicatorProps>(\n  (props: ScopedProps<MenuItemIndicatorProps>, forwardedRef) => {\n    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;\n    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);\n    return (\n      <Presence present={forceMount || indicatorContext.checked}>\n        <Primitive.span\n          {...itemIndicatorProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(indicatorContext.checked)}\n        />\n      </Presence>\n    );\n  }\n);\n\nMenuItemIndicator.displayName = ITEM_INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'MenuSeparator';\n\ntype MenuSeparatorElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuSeparatorProps extends PrimitiveDivProps {}\n\nconst MenuSeparator = React.forwardRef<MenuSeparatorElement, MenuSeparatorProps>(\n  (props: ScopedProps<MenuSeparatorProps>, forwardedRef) => {\n    const { __scopeMenu, ...separatorProps } = props;\n    return (\n      <Primitive.div\n        role=\"separator\"\n        aria-orientation=\"horizontal\"\n        {...separatorProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nMenuSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'MenuArrow';\n\ntype MenuArrowElement = React.ElementRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface MenuArrowProps extends PopperArrowProps {}\n\nconst MenuArrow = React.forwardRef<MenuArrowElement, MenuArrowProps>(\n  (props: ScopedProps<MenuArrowProps>, forwardedRef) => {\n    const { __scopeMenu, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nMenuArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getOpenState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nfunction getCheckedState(checked: boolean) {\n  return checked ? 'checked' : 'unchecked';\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\n/**\n * This is the \"meat\" of the typeahead matching logic. It takes in all the values,\n * the search and the current match, and returns the next match (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through options starting with that character)\n *\n * We also reorder the values by wrapping the array around the current match.\n * This is so we always look forward from the current match, and picking the first\n * match will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current match from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current match still matches.\n */\nfunction getNextMatch(values: string[], search: string, currentMatch?: string) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);\n  const nextMatch = wrappedValues.find((value) =>\n    value.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextMatch !== currentMatch ? nextMatch : undefined;\n}\n\ntype Point = { x: number; y: number };\ntype Polygon = Point[];\ntype Side = 'left' | 'right';\ntype GraceIntent = { area: Polygon; side: Side };\n\n// Determine if a point is inside of a polygon.\n// Based on https://github.com/substack/point-in-polygon\nfunction isPointInPolygon(point: Point, polygon: Polygon) {\n  const { x, y } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n\n    // prettier-ignore\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\nfunction isPointerInGraceArea(event: React.PointerEvent, area?: Polygon) {\n  if (!area) return false;\n  const cursorPos = { x: event.clientX, y: event.clientY };\n  return isPointInPolygon(cursorPos, area);\n}\n\nfunction whenMouse<E>(handler: React.PointerEventHandler<E>): React.PointerEventHandler<E> {\n  return (event) => (event.pointerType === 'mouse' ? handler(event) : undefined);\n}\n\nconst Root = Menu;\nconst Sub = MenuSub;\nconst Anchor = MenuAnchor;\nconst SubTrigger = MenuSubTrigger;\nconst Content = MenuContent;\nconst Group = MenuGroup;\nconst Label = MenuLabel;\nconst Item = MenuItem;\nconst CheckboxItem = MenuCheckboxItem;\nconst RadioGroup = MenuRadioGroup;\nconst RadioItem = MenuRadioItem;\nconst ItemIndicator = MenuItemIndicator;\nconst Separator = MenuSeparator;\nconst Arrow = MenuArrow;\n\nexport {\n  createMenuScope,\n  //\n  Menu,\n  MenuSub,\n  MenuAnchor,\n  MenuSubTrigger,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  //\n  Root,\n  Sub,\n  Anchor,\n  SubTrigger,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n};\nexport type {\n  MenuProps,\n  MenuSubProps,\n  MenuAnchorProps,\n  MenuSubTriggerProps,\n  MenuContentProps,\n  MenuGroupProps,\n  MenuLabelProps,\n  MenuItemProps,\n  MenuCheckboxItemProps,\n  MenuRadioGroupProps,\n  MenuRadioItemProps,\n  MenuItemIndicatorProps,\n  MenuSeparatorProps,\n  MenuArrowProps,\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}